import{L as R,T as P,A as D,cg as W,dr as O,bi as _,$ as G,dG as J,b as Q,b5 as E,f as H,Q as T,c as K,a8 as Y,ce as B}from"./main-BrXQBr3M.js";import{y as V}from"./utils-DuaeuwP5-t1uDCGxn.js";import{c as Z,f as ee}from"./utils-Jw-4AGsF-DGUB3bF1.js";const v={102100:{maxX:20037508342788905e-9,minX:-20037508342788905e-9,plus180Line:new R({paths:[[[20037508342788905e-9,-20037508342788905e-9],[20037508342788905e-9,20037508342788905e-9]]],spatialReference:P.WebMercator}),minus180Line:new R({paths:[[[-20037508342788905e-9,-20037508342788905e-9],[-20037508342788905e-9,20037508342788905e-9]]],spatialReference:P.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new R({paths:[[[180,-180],[180,180]]],spatialReference:P.WGS84}),minus180Line:new R({paths:[[[-180,-180],[-180,180]]],spatialReference:P.WGS84})}};function L(e,t){return Math.ceil((e-t)/(2*t))}function U(e,t){const i=q(e);for(const s of i)for(const n of s)n[0]+=t;return e}function q(e){return _(e)?e.rings:e.paths}async function ne(e,t,i,s){const n=V(e),a=t[0].spatialReference,o={...s,responseType:"json",query:{...n.query,f:"json",sr:G(a),target:JSON.stringify({geometryType:J(t[0]),geometries:t}),cutter:JSON.stringify(i)}},r=await Q(n.path+"/cut",o),{cutIndexes:c,geometries:f=[]}=r.data;return{cutIndexes:c,geometries:f.map(u=>{const m=E(u);return m.spatialReference=a,m})}}async function te(e,t,i){const s=typeof e=="string"?H(e):e,n=t[0].spatialReference,a=J(t[0]),o={...i,query:{...s.query,f:"json",sr:G(n),geometries:JSON.stringify(Z(t))}},{data:r}=await Q(s.path+"/simplify",o);return ee(r.geometries,a,n)}const C=()=>Y.getLogger("esri.geometry.support.normalizeUtils");function se(e){return e.type==="polygon"}function re(e){return e[0].type==="polygon"}function oe(e){return e[0].type==="polyline"}function $(e){const t=[];let i=0,s=0;for(let n=0;n<e.length;n++){const a=e[n];let o=null;for(let r=0;r<a.length;r++)o=a[r],t.push(o),r===0?(i=o[0],s=i):(i=Math.min(i,o[0]),s=Math.max(s,o[0]));o&&t.push([(i+s)/2,0])}return t}function ie(e,t){if(!(e instanceof R||e instanceof T)){const n="straightLineDensify: the input geometry is neither polyline nor polygon";throw C().error(n),new K(n)}const i=q(e),s=[];for(const n of i){const a=[];s.push(a),a.push([n[0][0],n[0][1]]);for(let o=0;o<n.length-1;o++){const r=n[o][0],c=n[o][1],f=n[o+1][0],u=n[o+1][1],m=Math.sqrt((f-r)*(f-r)+(u-c)*(u-c)),p=(u-c)/m,d=(f-r)/m,g=m/t;if(g>1){for(let A=1;A<=g-1;A++){const N=A*t,l=d*N+r,h=p*N+c;a.push([l,h])}const w=(m+Math.floor(g-1)*t)/2,S=d*w+r,F=p*w+c;a.push([S,F])}a.push([f,u])}}return se(e)?new T({rings:s,spatialReference:e.spatialReference}):new R({paths:s,spatialReference:e.spatialReference})}function k(e,t,i){if(t){const s=ie(e,1e6);e=B(s,!0)}return i&&(e=U(e,i)),e}function z(e,t,i){if(Array.isArray(e)){const s=e[0];if(s>t){const n=L(s,t);e[0]=s+n*(-2*t)}else if(s<i){const n=L(s,i);e[0]=s+n*(-2*i)}}else{const s=e.x;if(s>t){const n=L(s,t);e=e.clone().offset(n*(-2*t),0)}else if(s<i){const n=L(s,i);e=e.clone().offset(n*(-2*i),0)}}return e}function ae(e,t){let i=-1;for(let s=0;s<t.cutIndexes.length;s++){const n=t.cutIndexes[s],a=t.geometries[s],o=q(a);for(let r=0;r<o.length;r++){const c=o[r];c.some(f=>{if(f[0]<180)return!0;{let u=0;for(let p=0;p<c.length;p++){const d=c[p][0];u=d>u?d:u}u=Number(u.toFixed(9));const m=-360*L(u,180);for(let p=0;p<c.length;p++){const d=a.getPoint(r,p);a.setPoint(r,p,d.clone().offset(m,0))}return!0}})}if(n===i){if(re(e))for(const r of q(a))e[n]=e[n].addRing(r);else if(oe(e))for(const r of q(a))e[n]=e[n].addPath(r)}else i=n,e[n]=a}return e}async function ce(e,t,i){if(!Array.isArray(e))return ce([e],t);t&&typeof t!="string"&&C().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const s=typeof t=="string"?t:t?.url??D.geometryServiceUrl;let n,a,o,r,c,f,u,m,p=0;const d=[],g=[];for(const l of e)if(l!=null)if(n||(n=l.spatialReference,a=W(n),o=n.isWebMercator,f=o?102100:4326,r=v[f].maxX,c=v[f].minX,u=v[f].plus180Line,m=v[f].minus180Line),a)if(l.type==="mesh")g.push(l);else if(l.type==="point")g.push(z(l.clone(),r,c));else if(l.type==="multipoint"){const h=l.clone();h.points=h.points.map(x=>z(x,r,c)),g.push(h)}else if(l.type==="extent"){const h=l.clone()._normalize(!1,!1,a);g.push(h.rings?new T(h):h)}else if(l.extent){const h=l.extent,x=L(h.xmin,c)*(2*r);let M=x===0?l.clone():U(l.clone(),x);h.offset(x,0);let{xmin:b,xmax:y}=h;b=Number(b.toFixed(9)),y=Number(y.toFixed(9)),h.intersects(u)&&y!==r?(p=y>p?y:p,M=k(M,o),d.push(M),g.push("cut")):h.intersects(m)&&b!==c?(p=y*(2*r)>p?y*(2*r):p,M=k(M,o,360),d.push(M),g.push("cut")):g.push(M)}else g.push(l.clone());else g.push(l);else g.push(l);let w=L(p,r),S=-90;const F=w,A=new R;for(;w>0;){const l=360*w-180;A.addPath([[l,S],[l,-1*S]]),S*=-1,w--}if(d.length>0&&F>0){const l=ae(d,await ne(s,d,A,i)),h=[],x=[];for(let y=0;y<g.length;y++){const X=g[y];if(X!=="cut")x.push(X);else{const I=l.shift(),j=e[y];j!=null&&j.type==="polygon"&&j.rings&&j.rings.length>1&&I.rings.length>=j.rings.length?(h.push(I),x.push("simplify")):x.push(o?O(I):I)}}if(!h.length)return x;const M=await te(s,h,i),b=[];for(let y=0;y<x.length;y++){const X=x[y];X!=="simplify"?b.push(X):b.push(o?O(M.shift()):M.shift())}return b}const N=[];for(let l=0;l<g.length;l++){const h=g[l];if(h!=="cut")N.push(h);else{const x=d.shift();N.push(o===!0?O(x):x)}}return N}function pe(e){if(!e)return null;const t=e.extent;if(!t)return null;const i=e.spatialReference&&W(e.spatialReference);if(!i)return t;const[s,n]=i.valid,a=2*n,{width:o}=t;let r,{xmin:c,xmax:f}=t;if([c,f]=[f,c],e.type==="extent"||o===0||o<=n||o>a||c<s||f>n)return t;switch(e.type){case"polygon":if(!(e.rings.length>1))return t;r=$(e.rings);break;case"polyline":if(!(e.paths.length>1))return t;r=$(e.paths);break;case"multipoint":r=e.points}const u=t.clone();for(let m=0;m<r.length;m++){let p=r[m][0];p<0?(p+=n,f=Math.max(p,f)):(p-=n,c=Math.min(p,c))}return u.xmin=c,u.xmax=f,u.width<o?(u.xmin-=n,u.xmax-=n,u):t}function he(e,t,i){const s=W(i);if(s==null)return e;const[n,a]=s.valid,o=2*a;let r=0,c=0;t>a?r=Math.ceil(Math.abs(t-a)/o):t<n&&(r=-Math.ceil(Math.abs(t-n)/o)),e>a?c=Math.ceil(Math.abs(e-a)/o):e<n&&(c=-Math.ceil(Math.abs(e-n)/o));let f=e+(r-c)*o;const u=f-t;return u>a?f-=o:u<n&&(f+=o),f}function ge(e,t){const i=W(t);if(i){const[s,n]=i.valid,a=n-s;if(e<s)for(;e<s;)e+=a;if(e>n)for(;e>n;)e-=a}return e}export{ce as $,ie as C,U as F,v as X,he as f,pe as l,ge as u,L as w};
