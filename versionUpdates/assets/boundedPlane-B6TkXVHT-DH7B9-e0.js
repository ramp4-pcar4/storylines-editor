import{gh as x,f_ as y,bn as ot,gN as st,gj as A,cE as P,a8 as at}from"./main-BrXQBr3M.js";import{X as k,P as ct}from"./sphere-Cj20syUS-D-Z5ol5q.js";import{z as ut,G as gt,o as bt}from"./mat4-BFStKTjU-uiUWvEP6.js";import{n as D}from"./mat4f64-BaJwL7tQ-k0uMm8LY.js";import{_ as u,N as l,P as p,A as $,g as ft,b as I,k as lt,y as h,r as R,T as C,Z as m,l as B,v as Z}from"./vec32-BuqRmYBM-a_dAxp7z.js";import{M as pt,D as G,R as dt}from"./lineSegment-BJNfNZM5-C_IxAdr_.js";import{Q as E,N as mt,j as ht,S as j,f as s,H as It,g as Nt,D as Pt,d as $t,P as K,U as Mt,C as M,E as T,_ as Tt}from"./plane-B_adY3_o-k_KeEgEV.js";const O=()=>at.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class _t{constructor(){this.plane=E(),this.origin=P(),this.basis1=P(),this.basis2=P()}}const Et=_t;function N(t=et){return{plane:E(t.plane),origin:y(t.origin),basis1:y(t.basis1),basis2:y(t.basis2)}}function St(t,i,n){const r=Bt.get();return r.origin=t,r.basis1=i,r.basis2=n,r.plane=mt(0,0,0,0),v(r),r}function S(t,i=N()){return Q(t.origin,t.basis1,t.basis2,i)}function vt(t,i){u(i.origin,t.origin),u(i.basis1,t.basis1),u(i.basis2,t.basis2),ht(i.plane,t.plane)}function Q(t,i,n,r=N()){return u(r.origin,t),u(r.basis1,i),u(r.basis2,n),v(r),qt(r,"fromValues()"),r}function v(t){j(t.basis2,t.basis1,t.origin,t.plane)}function L(t,i,n){t!==n&&S(t,n);const r=l(s.get(),f(t),i);return p(n.origin,n.origin,r),n.plane[3]-=i,n}function wt(t,i,n){return X(i,n),L(n,F(t,t.origin),n),n}function xt(t,i){const n=t.basis1[0],r=t.basis2[1],[e,o]=t.origin;return ot(e-n,o-r,e+n,o+r,i)}function X(t,i=N()){const n=(t[2]-t[0])/2,r=(t[3]-t[1])/2;return $(i.origin,t[0]+n,t[1]+r,0),$(i.basis1,n,0,0),$(i.basis2,0,r,0),It(0,0,1,0,i.plane),i}function U(t,i,n){return!!Nt(t.plane,i,n)&&it(t,n)}function yt(t,i,n){if(U(t,i,n))return n;const r=W(t,i,s.get());return p(n,i.origin,l(s.get(),i.direction,ft(i.origin,r)/I(i.direction))),n}function W(t,i,n){const r=_.get();rt(t,i,r,_.get());let e=Number.POSITIVE_INFINITY;for(const o of z){const a=q(t,o,w.get()),g=s.get();if(Pt(r,a,g)){const c=lt(s.get(),i.origin,g),b=Math.abs(st(h(i.direction,c)));b<e&&(e=b,u(n,g))}}return e===Number.POSITIVE_INFINITY?J(t,i,n):n}function At(t,i){return(i-t)/i}function J(t,i,n){if(U(t,i,n))return n;const r=_.get(),e=_.get();rt(t,i,r,e);let o=Number.POSITIVE_INFINITY;for(const a of z){const g=q(t,a,w.get()),c=s.get();if($t(r,g,c)){const b=ct(i,c);if(!K(e,c))continue;b<o&&(o=b,u(n,c))}}return Y(t,i.origin)<o&&tt(t,i.origin,n),n}function tt(t,i,n){const r=Mt(t.plane,i,s.get()),e=G(H(t,t.basis1),r,-1,1,s.get()),o=G(H(t,t.basis2),r,-1,1,s.get());return R(n,p(s.get(),e,o),t.origin),n}function nt(t,i,n){const{origin:r,basis1:e,basis2:o}=t,a=R(s.get(),i,r),g=M(e,a),c=M(o,a),b=M(f(t),a);return $(n,g,c,b)}function Y(t,i){const n=nt(t,i,s.get()),{basis1:r,basis2:e}=t,o=I(r),a=I(e),g=Math.max(Math.abs(n[0])-o,0),c=Math.max(Math.abs(n[1])-a,0),b=n[2];return g*g+c*c+b*b}function Ct(t,i){return Math.sqrt(Y(t,i))}function Ot(t,i){let n=Number.NEGATIVE_INFINITY;for(const r of z){const e=q(t,r,w.get()),o=dt(e,i);o>n&&(n=o)}return Math.sqrt(n)}function Vt(t,i){return K(t.plane,i)&&it(t,i)}function jt(t,i,n,r){return Ft(t,n,r)}function F(t,i){const n=-t.plane[3];return M(f(t),i)-n}function kt(t,i,n,r){const e=F(t,i),o=l(zt,f(t),n-e);return p(r,i,o),r}function Rt(t,i){return C(t.basis1,i.basis1)&&C(t.basis2,i.basis2)&&C(t.origin,i.origin)}function Ut(t,i,n){return t!==n&&S(t,n),ut(d,i),gt(d,d),m(n.basis1,t.basis1,d),m(n.basis2,t.basis2,d),m(T(n.plane),T(t.plane),d),m(n.origin,t.origin,i),Tt(n.plane,n.plane,n.origin),n}function Yt(t,i,n,r){return t!==r&&S(t,r),bt(V,i,n),m(r.basis1,t.basis1,V),m(r.basis2,t.basis2,V),v(r),r}function f(t){return T(t.plane)}function Ft(t,i,n){switch(i){case A.X:u(n,t.basis1),B(n,n);break;case A.Y:u(n,t.basis2),B(n,n);break;case A.Z:u(n,f(t))}return n}function it(t,i){const n=R(s.get(),i,t.origin),r=Z(t.basis1),e=Z(t.basis2),o=h(t.basis1,n),a=h(t.basis2,n);return-o-r<0&&o-r<0&&-a-e<0&&a-e<0}function H(t,i){const n=w.get();return u(n.origin,t.origin),u(n.vector,i),n}function q(t,i,n){const{basis1:r,basis2:e,origin:o}=t,a=l(s.get(),r,i.origin[0]),g=l(s.get(),e,i.origin[1]);p(n.origin,a,g),p(n.origin,n.origin,o);const c=l(s.get(),r,i.direction[0]),b=l(s.get(),e,i.direction[1]);return l(n.vector,p(c,c,b),2),n}function qt(t,i){Math.abs(h(t.basis1,t.basis2)/(I(t.basis1)*I(t.basis2)))>1e-6&&O().warn(i,"Provided basis vectors are not perpendicular"),Math.abs(h(t.basis1,f(t)))>1e-6&&O().warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-h(f(t),t.origin)-t.plane[3])>1e-6&&O().warn(i,"Plane offset is not consistent with plane origin")}function rt(t,i,n,r){const e=f(t);j(e,i.direction,i.origin,n),j(T(n),e,i.origin,r)}const et={plane:E(),origin:x(0,0,0),basis1:x(1,0,0),basis2:x(0,1,0)},_=new k(E),w=new k(pt),zt=P(),Bt=new k(()=>N()),z=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=D(),V=D(),Xt=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:Et,altitudeAt:F,axisAt:jt,cameraFrustumCoverage:At,closestPoint:J,closestPointOnSilhouette:W,copy:S,copyWithoutVerify:vt,create:N,distance:Ct,distance2:Y,distanceToSilhouette:Ot,elevate:L,equals:Rt,extrusionContainsPoint:Vt,fromAABoundingRect:X,fromValues:Q,getExtent:xt,intersectRay:U,intersectRayClosestSilhouette:yt,normal:f,projectPoint:tt,projectPointLocal:nt,rotate:Yt,setAltitudeAt:kt,setExtent:wt,transform:Ut,up:et,updateUnboundedPlane:v,wrap:St},Symbol.toStringTag,{value:"Module"}));export{Q as C,S as M,v as N,Xt as U,N as h,X as k,Ct as n};
