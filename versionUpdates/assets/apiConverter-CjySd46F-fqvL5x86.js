import{r as M,C as V,e as h,M as w,U as Z,a as m,b as v}from"./ProjectionTransformation-BocI5WO--BK6m1h3v.js";import{s as P,r as R,E as p,Q as E,L as d}from"./main-BrXQBr3M.js";import{fromGeometryToGXGeometry as g,toGeometry as y}from"./jsonConverter-DldrjI06-DnHtKZHh.js";import"./SimpleGeometryCursor-DSF_YyIm-TAMgMsbK.js";const a="_gxVersion",x=2,C=1;function $(t){return Array.isArray(t)?t[0].spatialReference:t.spatialReference}function A(t){switch(t.type){case"point":return z(t);case"multipoint":return X(t);case"polyline":return I(t);case"polygon":return Y(t);case"extent":return G(t);default:throw new Error(`Unsupported geometry type: ${t.type}`)}}function G(t){if(!t.getCacheValue(a)){const n=new M;n.setCoords(t.xmin,t.ymin,t.xmax,t.ymax),t.hasM&&n.setInterval(x,0,t.mmin,t.mmax),t.hasZ&&n.setInterval(C,0,t.zmin,t.zmax),t.setCacheValue(a,n)}return t.getCacheValue(a)}function X(t){if(!t.getCacheValue(a)){const n=new V,e=new h,s=t.points,r=t.hasM,o=t.hasZ,i=o?3:2;for(let u=0,l=s.length;u<l;u++){const c=s[u];e.setXYCoords(c[0],c[1]),o&&e.setZ(c[2]??0),r&&e.setM(c[i]??NaN),n.add(e)}t.setCacheValue(a,n)}return t.getCacheValue(a)}function z(t){if(!t.getCacheValue(a)){const n=new h;n.setXYCoords(t.x,t.y),t.hasM&&n.setM(t.m),t.hasZ&&n.setZ(t.z),t.setCacheValue(a,n)}return t.getCacheValue(a)}function Y(t){if(!t.getCacheValue(a)){const{curveRings:n,hasM:e,hasZ:s,rings:r}=t,o=g({curveRings:n,hasM:e,hasZ:s,rings:r});t.setCacheValue(a,o)}return t.getCacheValue(a)}function I(t){if(!t.getCacheValue(a)){const{curvePaths:n,hasM:e,hasZ:s,paths:r}=t,o=g({curvePaths:n,hasM:e,hasZ:s,paths:r});t.setCacheValue(a,o)}return t.getCacheValue(a)}function Q(t){if(t.wkid)return w(t.wkid);const n=t.wkt2||t.wkt;return n?Z(n):null}function U(t,n){if(t)switch(t.getGeometryType()){case m.enumPoint:return N(t,n);case m.enumEnvelope:return T(t,n);case m.enumMultiPoint:return k(t,n);case m.enumPolyline:return q(t,n);case m.enumPolygon:return S(t,n)}return null}function T(t,n){if(t.isEmpty())return null;const e=new P({xmin:t.getXMin(),ymin:t.getYMin(),xmax:t.getXMax(),ymax:t.getYMax(),spatialReference:n}),s=t.getDescription();if(s.hasM()){const r=t.queryInterval(x,0);e.mmin=r.vmin,e.mmax=r.vmax}if(s.hasZ()){const r=t.queryInterval(C,0);e.zmin=r.vmin,e.zmax=r.vmax}return e.setCacheValue(a,t),e}function k(t,n){if(t.isEmpty())return null;const e=t.getDescription(),s=e.hasM(),r=e.hasZ(),o=[],i=new h;for(let l=0,c=t.getPointCount();l<c;l++){t.getPointByVal(l,i);const f=[i.getX(),i.getY()];r&&f.push(i.getZ()),s&&f.push(i.getM()),o.push(f)}const u=new R({hasM:s,hasZ:r,points:o,spatialReference:n});return u.setCacheValue(a,t),u}function N(t,n){if(t instanceof v)return new p({x:t.x,y:t.y,spatialReference:n});if(t.isEmpty())return null;const e=new p({x:t.getX(),y:t.getY(),spatialReference:n}),s=t.getDescription();return s.hasM()&&(e.m=t.getM()),s.hasZ()&&(e.z=t.getZ()),e.setCacheValue(a,t),e}function S(t,n){if(t.isEmpty())return null;const e=E.fromJSON({spatialReference:n,...y(t,null)});return e.setCacheValue(a,t),e}function q(t,n){if(t.isEmpty())return null;const e=d.fromJSON({spatialReference:n,...y(t,null)});return e.setCacheValue(a,t),e}export{G as fromExtent,A as fromGeometry,X as fromMultipoint,z as fromPoint,Y as fromPolygon,I as fromPolyline,Q as fromSpatialReference,$ as getSpatialReference,T as toExtent,U as toGeometry,k as toMultipoint,N as toPoint,S as toPolygon,q as toPolyline};
