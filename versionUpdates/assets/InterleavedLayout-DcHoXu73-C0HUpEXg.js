import{J as p,p as _,l as y,X as m,o as F,B as w,T as g,E as b,m as E,A as v,a as A,b as $,O as M,S as T,g as H,L as x,w as z,x as S,M as j,C as B,N as C,P as q,R as D,Y as I,F as L,I as U,U as J,V as N,v as O,j as V,k as P,q as R,D as X,G as Y,H as K,z as Q}from"./BufferView-BBCzkcZS-CjZ-XaYu.js";import{o as W}from"./vec2f64-CEUyUoff-BBc0aQ6D.js";import"./vec42-D8CJyqHG-DnfLTeQH.js";import"./vec4f64-CjUMzAyX-DPYbdAom.js";class Z{constructor(t){this.message=t}toString(){return`AssertException: ${this.message}`}}function tt(i,t="Assertion"){if(!i){const e=new Error(t).stack;throw new Z(`${t} at ${e}`)}}function ut(i,t){i||(t=t||"",console.warn("Verify failed: "+t+`
`+new Error("verify").stack))}function at(i,t,e,s){let r,n=(e[0]-i[0])/t[0],h=(s[0]-i[0])/t[0];n>h&&(r=n,n=h,h=r);let a=(e[1]-i[1])/t[1],u=(s[1]-i[1])/t[1];if(a>u&&(r=a,a=u,u=r),n>u||a>h)return!1;a>n&&(n=a),u<h&&(h=u);let f=(e[2]-i[2])/t[2],o=(s[2]-i[2])/t[2];return f>o&&(r=f,f=o,o=r),!(n>o||f>h)&&(o<h&&(h=o),!(h<0))}function ot(i,t,e,s,r,n=W()){const h=(s[r]-e[r])*(t[0]-i[0])-(s[0]-e[0])*(t[r]-i[r]),a=(s[0]-e[0])*(i[r]-e[r])-(s[r]-e[r])*(i[0]-e[0]);if(h===0)return!1;const u=a/h;return n[0]=i[0]+u*(t[0]-i[0]),n[1]=i[r]+u*(t[r]-i[r]),!0}function ft(i,t){return Math.log(i)/Math.log(t)}function dt(i){return i[0]===1&&i[1]===0&&i[2]===0&&i[3]===0&&i[4]===0&&i[5]===1&&i[6]===0&&i[7]===0&&i[8]===0&&i[9]===0&&i[10]===1&&i[11]===0&&i[15]===1}function l(i){switch(i){case"u8":case"i8":return 1;case"u16":case"i16":return 2;case"u32":case"i32":case"f32":return 4;case"f64":return 8}}class d{constructor(t,e){this.layout=t,this.buffer=typeof e=="number"?new ArrayBuffer(e*t.stride):e;for(const s of t.fields.keys()){const r=t.fields.get(s);this[s]=new r.constructor(this.buffer,r.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(t,e){const s=this[t];return s&&s.elementCount===e.ElementCount&&s.elementType===e.ElementType?s:null}slice(t,e){return new d(this.layout,this.buffer.slice(t*this.stride,e*this.stride))}copyFrom(t,e=0,s=0,r=t.count){const n=this.stride;if(n%4==0){const h=new Uint32Array(t.buffer,e*n,r*n/4);new Uint32Array(this.buffer,s*n,r*n/4).set(h)}else{const h=new Uint8Array(t.buffer,e*n,r*n);new Uint8Array(this.buffer,s*n,r*n).set(h)}return this}get cachedMemory(){return this.byteLength}dispose(){}}class c{constructor(t){this._stride=0,this._lastAligned=0,this._fields=new Map,t&&(this._stride=t.stride,t.fields.forEach(e=>this._fields.set(e[0],{...e[1],constructor:it(e[1].constructor)})))}freeze(){return this}vec2f(t,e){return this._appendField(t,_,e),this}vec2f64(t,e){return this._appendField(t,b,e),this}vec3f(t,e){return this._appendField(t,y,e),this}vec3f64(t,e){return this._appendField(t,E,e),this}vec4f(t,e){return this._appendField(t,m,e),this}vec4f64(t,e){return this._appendField(t,v,e),this}mat3f(t,e){return this._appendField(t,F,e),this}mat3f64(t,e){return this._appendField(t,A,e),this}mat4f(t,e){return this._appendField(t,w,e),this}mat4f64(t,e){return this._appendField(t,$,e),this}vec4u8(t,e){return this._appendField(t,x,e),this}f32(t,e){return this._appendField(t,p,e),this}f64(t,e){return this._appendField(t,g,e),this}u8(t,e){return this._appendField(t,M,e),this}u16(t,e){return this._appendField(t,z,e),this}i8(t,e){return this._appendField(t,L,e),this}vec2i8(t,e){return this._appendField(t,U,e),this}vec2i16(t,e){return this._appendField(t,V,e),this}vec2u8(t,e){return this._appendField(t,T,e),this}vec4u16(t,e){return this._appendField(t,B,e),this}u32(t,e){return this._appendField(t,C,e),this}_appendField(t,e,s){if(this._fields.has(t))return void tt(!1,`${t} already added to vertex buffer layout`);const r=e.ElementCount*l(e.ElementType),n=this._stride;this._stride+=r,this._fields.set(t,{size:r,constructor:e,offset:n,optional:s})}createBuffer(t){return new d(this,t)}createView(t){return new d(this,t)}clone(){const t=new c;return t._stride=this._stride,t._fields=new Map,this._fields.forEach((e,s)=>t._fields.set(s,e)),t.BufferType=this.BufferType,t}get stride(){if(this._lastAligned!==this._fields.size){let t=1;this._fields.forEach(e=>t=Math.max(t,l(e.constructor.ElementType))),this._stride=Math.floor((this._stride+t-1)/t)*t,this._lastAligned=this._fields.size}return this._stride}get fields(){return this._fields}}function ct(){return new c}class lt{constructor(t){this.fields=new Array,t.fields.forEach((e,s)=>{const r={...e,constructor:k(e.constructor)};this.fields.push([s,r])}),this.stride=t.stride}}const et=[p,_,y,m,F,w,g,b,E,v,A,$,M,T,H,x,z,S,j,B,C,q,D,I,L,U,J,N,O,V,P,R,X,Y,K,Q];function k(i){return`${i.ElementType}_${i.ElementCount}`}function it(i){return G.get(i)}const G=new Map;et.forEach(i=>G.set(k(i),i));export{tt as V,ct as a,c,ut as e,lt as h,ft as i,l,dt as n,ot as r,at as s};
