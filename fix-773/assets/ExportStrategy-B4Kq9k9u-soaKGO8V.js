import{a0 as N,br as z,u as w,J as q,t as H,cN as T,e3 as W,ao as $,v as l,S as m,n as k}from"./main-D8UjLOIQ.js";import{a as A}from"./TileInfo-U28GysF5-BdEU3cA-.js";import{h as B}from"./BitmapTechnique-CHUhq2KJ-DbLYWvmN.js";import{k as C}from"./enums-CQnCd4Rx-BzxILyyn.js";import{s as I}from"./TileKey-_zikB14n-BJU6ZqJG.js";const U=Math.PI/180;function V(p){return p*U}function D(p,a){const i=V(a.rotation),r=Math.abs(Math.cos(i)),t=Math.abs(Math.sin(i)),[s,o]=a.size;return p[0]=Math.round(o*t+s*r),p[1]=Math.round(o*r+s*t),p}function J(p,a,i,r){const[t,s]=a,[o,d]=r,e=.5*i;return p[0]=t-e*o,p[1]=s-e*d,p[2]=t+e*o,p[3]=s+e*d,p}const u=$(),c=[0,0],_=new I(0,0,0,0),M={imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let h=class extends N{constructor(a){super(a),this._imagePromise=null,this.bitmaps=[],this.hidpi=M.hidpi,this.imageMaxWidth=M.imageMaxWidth,this.imageMaxHeight=M.imageMaxHeight,this.imageRotationSupported=M.imageRotationSupported,this.imageNormalizationSupported=M.imageNormalizationSupported,this.update=z(async(i,r)=>{if(w(r),!i.stationary||this.destroyed)return;const t=i.state,s=q(t.spatialReference),o=this.hidpi?i.pixelRatio:1,d=t.worldScreenWidth>0,e=d&&this.imageNormalizationSupported&&t.worldScreenWidth<t.size[0],f=Math.round((this.imageMaxWidth??0)/o),x=Math.round((this.imageMaxHeight??0)/o);e?(c[0]=t.worldScreenWidth,c[1]=t.size[1]):this.imageRotationSupported?(c[0]=t.size[0],c[1]=t.size[1]):D(c,t);const S=Math.floor(c[0])>f||Math.floor(c[1])>x,v=s&&(t.extent.xmin<s.valid[0]||t.extent.xmax>s.valid[1]),R=!this.imageNormalizationSupported&&v,y=!S&&!R,b=this.imageRotationSupported?t.rotation:0,E=this.container.children.slice();if(y){const n=e?t.paddedViewState.center:t.center;this._imagePromise=this._singleExport(t,c,n,t.resolution,b,o,r)}else{let n=Math.min(f,x);d&&(n=Math.min(t.worldScreenWidth,n),n=Math.round(t.worldScreenWidth/Math.ceil(t.worldScreenWidth/n))),this._imagePromise=this._tiledExport(t,n,o,r)}try{const n=await this._imagePromise??[];w(r);const P=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=n;for(const g of E)n.includes(g)||P.push(g.fadeOut().then(()=>{g.remove(),g.destroy()}));for(const g of n)P.push(g.fadeIn());await Promise.all(P)}catch(n){this._imagePromise=null,H(n)}},5e3),this.updateExports=z(async i=>{const r=[];for(const t of this.container.children){if(!t.visible||!t.stage)return;r.push(i(t).then(()=>{t.invalidateTexture(),t.requestRender()}))}this._imagePromise=T(r).then(()=>this._imagePromise=null),await this._imagePromise})}destroy(){this.bitmaps.forEach(a=>a.destroy()),this.bitmaps=[]}get updating(){return!this.destroyed&&this._imagePromise!==null}async _export(a,i,r,t,s,o){const d=await this.fetchSource(a,Math.floor(i*s),Math.floor(r*s),{rotation:t,pixelRatio:s,signal:o});w(o);const e=new B(null,!0);return e.x=a.xmin,e.y=a.ymax,e.resolution=a.width/i,e.rotation=t,e.pixelRatio=s,e.opacity=0,this.container.addChild(e),await e.setSourceAsync(d,o),w(o),e}async _singleExport(a,i,r,t,s,o,d){J(u,r,t,i);const e=W(u,a.spatialReference);return[await this._export(e,i[0],i[1],s,o,d)]}_tiledExport(a,i,r,t){const s=A.create({size:i,spatialReference:a.spatialReference,scales:[a.scale]}),o=new C(s),d=o.getTileCoverage(a);if(!d)return null;const e=[];return d.forEach((f,x,S,v)=>{_.set(f,x,S,0),o.getTileBounds(u,_);const R=W(u,a.spatialReference);e.push(this._export(R,i,i,0,r,t).then(y=>(v!==0&&(_.set(f,x,S,v),o.getTileBounds(u,_),y.x=u[0],y.y=u[3]),y)))}),Promise.all(e)}};l([m()],h.prototype,"_imagePromise",void 0),l([m()],h.prototype,"bitmaps",void 0),l([m()],h.prototype,"container",void 0),l([m()],h.prototype,"fetchSource",void 0),l([m()],h.prototype,"hidpi",void 0),l([m()],h.prototype,"imageMaxWidth",void 0),l([m()],h.prototype,"imageMaxHeight",void 0),l([m()],h.prototype,"imageRotationSupported",void 0),l([m()],h.prototype,"imageNormalizationSupported",void 0),l([m()],h.prototype,"requestUpdate",void 0),l([m()],h.prototype,"updating",null),h=l([k("esri.views.2d.layers.support.ExportStrategy")],h);export{h};
