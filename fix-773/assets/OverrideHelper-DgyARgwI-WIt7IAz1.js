import{i as v,b1 as b}from"./main-D8UjLOIQ.js";import{x as M}from"./colorUtils-Eg6lOlXm-DMJZAu4r.js";import{o as C}from"./FieldsIndex-Bt0Y8aWr-DcDROz7E.js";import{$ as I}from"./ArcadeExpression-XjY3x7KV-CPieOIwH.js";import{S as x,L as d,w as S,p as k,Z as O,Q as h,b as N}from"./utils-BfXZnjCE-YHhxTa7x.js";import P from"./callExpressionWithFeature-Bk8k1lJI-BsNYGGFF.js";import"./vec42-D8CJyqHG-DnfLTeQH.js";import"./common-CYWrYyJl-E8-sukrT.js";import"./vec4f64-DD-nkcCV-CSNWKRqG.js";import"./UnknownTimeZone-DxjyzFvs-DtNVLQoo.js";import"./timeZoneUtils-d5p0Jda1-BeP90iup.js";import"./TimeOnly-CGkId3bj-BgQ9WVmM.js";import"./enum-g1DWyQyu-C22wI6Gv.js";import"./defaultCIMValues-BcSaJjm--aGYX5ruf.js";import"./enums-a_LDTPYU-CBIcy3mM.js";import"./quantizationUtils-D907S7Bm-eKXd3Pim.js";const T=m=>{if(!m)return[0,0,0,0];const{r:e,g:r,b:i,a:s}=m;return[e,r,i,255*s]};class t{static findApplicableOverrides(e,r,i){if(e&&r){if(e.primitiveName){let s=!1;for(const o of i)if(o.primitiveName===e.primitiveName){s=!0;break}if(!s)for(const o of r)o.primitiveName===e.primitiveName&&i.push(o)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const s of e.effects)t.findApplicableOverrides(s,r,i);if(e.symbolLayers)for(const s of e.symbolLayers)t.findApplicableOverrides(s,r,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const s of e.effects)t.findApplicableOverrides(s,r,i);if(e.markerPlacement&&t.findApplicableOverrides(e.markerPlacement,r,i),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const s of e.markerGraphics)t.findApplicableOverrides(s,r,i),t.findApplicableOverrides(s.symbol,r,i)}else e.type==="CIMCharacterMarker"?t.findApplicableOverrides(e.symbol,r,i):e.type==="CIMHatchFill"?t.findApplicableOverrides(e.lineSymbol,r,i):e.type==="CIMPictureMarker"&&t.findApplicableOverrides(e.animatedSymbolProperties,r,i)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&x(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const i=d(e),s=e.primitiveName,o=[];for(const a of r)a.primitiveName===s&&o.push(d(a));return{type:"cim-effect-param",effect:i,overrides:S(o)}}static async resolveSymbolOverrides(e,r,i,s,o,a,c){if(!e?.symbol)return null;let{symbol:p,primitiveOverrides:l}=e;const f=!!l;if(!f&&!s)return p;p=v(p),l=v(l);let y=!0;if(r||(r={attributes:{}},y=!1),f){if(y||(l=l.filter(n=>!n.valueExpressionInfo?.expression.includes("$feature"))),c||(l=l.filter(n=>!n.valueExpressionInfo?.expression.includes("$view"))),l.length>0){const n=k(r.attributes),u={spatialReference:i,fields:n,geometryType:o};await t.createRenderExpressions(l,u),t.evaluateOverrides(l,r,o??"esriGeometryPoint",a,c,new C(n))}t.applyOverrides(p,l)}return s&&t.applyDictionaryTextOverrides(p,r,s,null),p}static{this._expressionToRenderExpression=new Map}static async createRenderExpressions(e,r){const i=[];for(const s of e){const o=s.valueExpressionInfo;if(!o||t._expressionToRenderExpression.has(o.expression))continue;const a=I(o.expression,r.spatialReference);i.push(a),a.then(c=>t._expressionToRenderExpression.set(o.expression,c))}i.length>0&&await Promise.all(i)}static evaluateOverrides(e,r,i,s,o,a){const c={$view:{scale:o?.scale}};for(const p of e){p.value&&typeof p.value=="object"&&M(p.value)&&(p.propertyName==="Color"||p.propertyName==="StrokeColor")&&(p.value=T(p.value));const l=p.valueExpressionInfo;if(!l)continue;const f=t._expressionToRenderExpression.get(l.expression);f&&(p.value=P(f,r,c,i,a,s))}}static applyDictionaryTextOverrides(e,r,i,s,o="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const a=e.symbolLayers;if(!a)return;for(const c of a)c&&c.type==="CIMVectorMarker"&&t.applyDictionaryTextOverrides(c,r,i,s,e.type==="CIMTextSymbol"?e.textCase:o)}break;case"CIMVectorMarker":{const a=e.markerGraphics;if(!a)return;for(const c of a)c&&t.applyDictionaryTextOverrides(c,r,i,s)}break;case"CIMMarkerGraphic":{const a=e.textString;if(a&&a.includes("[")){const c=O(a,i);e.textString=h(r,c,s,o)}}}}static applyOverrides(e,r,i,s){if(e.primitiveName){for(const o of r)if(o.primitiveName===e.primitiveName){const a=N(o.propertyName);if(s&&s.push({cim:e,nocapPropertyName:a,value:e[a]}),i){let c=!1;for(const p of i)p.primitiveName===e.primitiveName&&(c=!0);c||i.push(o)}o.value!=null&&(e[a]=o.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const o of e.effects)t.applyOverrides(o,r,i,s);if(e.symbolLayers)for(const o of e.symbolLayers)t.applyOverrides(o,r,i,s);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const o of e.effects)t.applyOverrides(o,r,i,s);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const o of e.markerGraphics)t.applyOverrides(o,r,i,s),t.applyOverrides(o.symbol,r,i,s)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const i of e)i.value!==void 0&&(r+=`${i.primitiveName}${i.propertyName}${JSON.stringify(i.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map(i=>Number(i));if(e==="Color"){const i=new b(r).toRgba();return i[3]*=255,i}return r}}export{t as OverrideHelper};
