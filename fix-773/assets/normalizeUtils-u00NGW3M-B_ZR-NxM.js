import{f as D,J as z,B as S,aQ as J,bv as W,bu as X,N as Y,aW as U,M as H,Z,h as Q,a3 as _,db as E}from"./main-D8UjLOIQ.js";import{p as L,f as R,t as j,u as k}from"./normalizeUtilsCommon-ClagynAA-C5v37AXV.js";import{m as G}from"./utils-BO8hgPs3-CT_Uv3UC.js";import{c as K,f as V}from"./utils-DpLVEUvg-DN_Ioqdv.js";async function $(e,t,l,s){const n=G(e),i=t[0].spatialReference,o={...s,responseType:"json",query:{...n.query,f:"json",sr:X(i),target:JSON.stringify({geometryType:W(t[0]),geometries:t}),cutter:JSON.stringify(l)}},r=await Y(n.path+"/cut",o),{cutIndexes:f,geometries:a=[]}=r.data;return{cutIndexes:f,geometries:a.map(u=>{const m=U(u);return m.spatialReference=i,m})}}async function ee(e,t,l){const s=typeof e=="string"?H(e):e,n=t[0].spatialReference,i=W(t[0]),o={...l,query:{...s.query,f:"json",sr:X(n),geometries:JSON.stringify(K(t))}},{data:r}=await Y(s.path+"/simplify",o);return V(r.geometries,i,n)}const C=()=>_.getLogger("esri.geometry.support.normalizeUtils");function ne(e){return e.type==="polygon"}function te(e){return e[0].type==="polygon"}function se(e){return e[0].type==="polyline"}function B(e){const t=[];let l=0,s=0;for(let n=0;n<e.length;n++){const i=e[n];let o=null;for(let r=0;r<i.length;r++)o=i[r],t.push(o),r===0?(l=o[0],s=l):(l=Math.min(l,o[0]),s=Math.max(s,o[0]));o&&t.push([(l+s)/2,0])}return t}function re(e,t){if(!(e instanceof S||e instanceof Z)){const n="straightLineDensify: the input geometry is neither polyline nor polygon";throw C().error(n),new Q("internal:geometry",n)}const l=j(e),s=[];for(const n of l){const i=[];s.push(i),i.push([n[0][0],n[0][1]]);for(let o=0;o<n.length-1;o++){const r=n[o][0],f=n[o][1],a=n[o+1][0],u=n[o+1][1],m=Math.sqrt((a-r)*(a-r)+(u-f)*(u-f)),p=(u-f)/m,d=(a-r)/m,g=m/t;if(g>1){for(let N=1;N<=g-1;N++){const q=N*t,c=d*q+r,h=p*q+f;i.push([c,h])}const b=(m+Math.floor(g-1)*t)/2,v=d*b+r,A=p*b+f;i.push([v,A])}i.push([a,u])}}return ne(e)?new Z({rings:s,spatialReference:e.spatialReference}):new S({paths:s,spatialReference:e.spatialReference})}function F(e,t,l){if(t){const s=re(e,1e6);e=E(s,!0)}return l&&(e=k(e,l)),e}function O(e,t,l){if(Array.isArray(e)){const s=e[0];if(s>t){const n=R(s,t);e[0]=s+n*(-2*t)}else if(s<l){const n=R(s,l);e[0]=s+n*(-2*l)}}else{const s=e.x;if(s>t){const n=R(s,t);e=e.clone().offset(n*(-2*t),0)}else if(s<l){const n=R(s,l);e=e.clone().offset(n*(-2*l),0)}}return e}function oe(e,t){let l=-1;for(let s=0;s<t.cutIndexes.length;s++){const n=t.cutIndexes[s],i=t.geometries[s],o=j(i);for(let r=0;r<o.length;r++){const f=o[r];f.some(a=>{if(a[0]<180)return!0;{let u=0;for(let p=0;p<f.length;p++){const d=f[p][0];u=d>u?d:u}u=Number(u.toFixed(9));const m=-360*R(u,180);for(let p=0;p<f.length;p++){const d=i.getPoint(r,p);i.setPoint(r,p,d.clone().offset(m,0))}return!0}})}if(n===l){if(te(e))for(const r of j(i))e[n]=e[n].addRing(r);else if(se(e))for(const r of j(i))e[n]=e[n].addPath(r)}else l=n,e[n]=i}return e}async function ie(e,t,l){if(!Array.isArray(e))return ie([e],t);t&&typeof t!="string"&&C().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const s=typeof t=="string"?t:t?.url??D.geometryServiceUrl;let n,i,o,r,f,a,u,m,p=0;const d=[],g=[];for(const c of e)if(c!=null)if(n||(n=c.spatialReference,i=z(n),o=n.isWebMercator,a=o?102100:4326,r=L[a].maxX,f=L[a].minX,u=L[a].plus180Line,m=L[a].minus180Line),i)if(c.type==="mesh")g.push(c);else if(c.type==="point")g.push(O(c.clone(),r,f));else if(c.type==="multipoint"){const h=c.clone();h.points=h.points.map(x=>O(x,r,f)),g.push(h)}else if(c.type==="extent"){const h=c.clone()._normalize(!1,!1,i);g.push(h.rings?new Z(h):h)}else if(c.extent){const h=c.extent,x=R(h.xmin,f)*(2*r);let M=x===0?c.clone():k(c.clone(),x);h.offset(x,0);let{xmin:w,xmax:y}=h;w=Number(w.toFixed(9)),y=Number(y.toFixed(9)),h.intersects(u)&&y!==r?(p=y>p?y:p,M=F(M,o),d.push(M),g.push("cut")):h.intersects(m)&&w!==f?(p=y*(2*r)>p?y*(2*r):p,M=F(M,o,360),d.push(M),g.push("cut")):g.push(M)}else g.push(c.clone());else g.push(c);else g.push(c);let b=R(p,r),v=-90;const A=b,N=new S;for(;b>0;){const c=360*b-180;N.addPath([[c,v],[c,-1*v]]),v*=-1,b--}if(d.length>0&&A>0){const c=oe(d,await $(s,d,N,l)),h=[],x=[];for(let y=0;y<g.length;y++){const P=g[y];if(P!=="cut")x.push(P);else{const I=c.shift(),T=e[y];T!=null&&T.type==="polygon"&&T.rings&&T.rings.length>1&&I.rings.length>=T.rings.length?(h.push(I),x.push("simplify")):x.push(o?J(I):I)}}if(!h.length)return x;const M=await ee(s,h,l),w=[];for(let y=0;y<x.length;y++){const P=x[y];P!=="simplify"?w.push(P):w.push(o?J(M.shift()):M.shift())}return w}const q=[];for(let c=0;c<g.length;c++){const h=g[c];if(h!=="cut")q.push(h);else{const x=d.shift();q.push(o===!0?J(x):x)}}return q}function ue(e){if(!e)return null;const t=e.extent;if(!t)return null;const l=e.spatialReference&&z(e.spatialReference);if(!l)return t;const[s,n]=l.valid,i=2*n,{width:o}=t;let r,{xmin:f,xmax:a}=t;if([f,a]=[a,f],e.type==="extent"||o===0||o<=n||o>i||f<s||a>n)return t;switch(e.type){case"polygon":if(!(e.rings.length>1))return t;r=B(e.rings);break;case"polyline":if(!(e.paths.length>1))return t;r=B(e.paths);break;case"multipoint":r=e.points}const u=t.clone();for(let m=0;m<r.length;m++){let p=r[m][0];p<0?(p+=n,a=Math.max(p,a)):(p-=n,f=Math.min(p,f))}return u.xmin=f,u.xmax=a,u.width<o?(u.xmin-=n,u.xmax-=n,u):t}function pe(e,t,l){const s=z(l);if(s==null)return e;const[n,i]=s.valid,o=2*i;let r=0,f=0;t>i?r=Math.ceil(Math.abs(t-i)/o):t<n&&(r=-Math.ceil(Math.abs(t-n)/o)),e>i?f=Math.ceil(Math.abs(e-i)/o):e<n&&(f=-Math.ceil(Math.abs(e-n)/o));let a=e+(r-f)*o;const u=a-t;return u>i?a-=o:u<n&&(a+=o),a}function he(e,t){const l=z(t);if(l){const[s,n]=l.valid,i=n-s;if(e<s)for(;e<s;)e+=i;if(e>n)for(;e>n;)e-=i}return e}export{ie as B,re as D,ue as a,he as c,pe as l};
