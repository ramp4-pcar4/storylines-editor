import{X as S,b6 as T,I as F,aW as N,aL as w,i as q,cl as x,v as h,S as d,w as G,aU as z,aX as P,n as j}from"./main-D8UjLOIQ.js";import{m as J}from"./Field-BIQ-quF4-BPjMRpni.js";var R;const v=new F({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryEnvelope:"extent",mesh:"mesh","":null});let c=R=class extends S{constructor(r){super(r),this.displayFieldName=null,this.exceededTransferLimit=!1,this.features=[],this.fields=null,this.geometryType=null,this.hasM=!1,this.hasZ=!1,this.queryGeometry=null,this.spatialReference=null}readFeatures(r,l){return this.readFeaturesWithClass(r,l,T)}writeGeometryType(r,l,s,e){if(r)return void v.write(r,l,s,e);const{features:i}=this;if(i){for(const n of i)if(n?.geometry!=null)return void v.write(n.geometry.type,l,s,e)}}readQueryGeometry(r,l){if(!r)return null;const s=!!r.spatialReference,e=N(r);return e&&!s&&l.spatialReference&&(e.spatialReference=w.fromJSON(l.spatialReference)),e}writeSpatialReference(r,l){if(r)return void(l.spatialReference=r.toJSON());const{features:s}=this;if(s){for(const e of s)if(e&&e.geometry!=null&&e.geometry.spatialReference)return void(l.spatialReference=e.geometry.spatialReference.toJSON())}}clone(){return new R(this.cloneProperties())}cloneProperties(){return q({displayFieldName:this.displayFieldName,exceededTransferLimit:this.exceededTransferLimit,features:this.features,fields:this.fields,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,queryGeometry:this.queryGeometry,spatialReference:this.spatialReference,transform:this.transform})}toJSON(r){const l=this.write();if(l.features&&Array.isArray(r)&&r.length>0)for(let s=0;s<l.features.length;s++){const e=l.features[s];if(e.geometry){const i=r?.[s];e.geometry=i?.toJSON()||e.geometry}}return l}quantize(r){const{scale:[l,s],translate:[e,i]}=r,n=t=>Math.round((t-e)/l),a=t=>Math.round((i-t)/s),f=this.features,m=this._getQuantizationFunction(this.geometryType,n,a);for(let t=0,p=f.length;t<p;t++)m?.(f[t].geometry)||(f.splice(t,1),t--,p--);return this.transform=r,this}unquantize(){const{geometryType:r,features:l,transform:s}=this;if(!s)return this;const{translate:[e,i],scale:[n,a]}=s,f=u=>u*n+e,m=u=>i-u*a;let t=null,p=null;if(this.hasZ&&s?.scale?.[2]!=null){const{translate:[,,u],scale:[,,g]}=s;t=y=>y*g+u}if(this.hasM&&s?.scale?.[3]!=null){const{translate:[,,,u],scale:[,,,g]}=s;p=y=>y==null?y:y*g+u}const o=this._getHydrationFunction(r,f,m,t,p);for(const{geometry:u}of l)u!=null&&o&&o(u);return this.transform=null,this}readFeaturesWithClass(r,l,s){const e=w.fromJSON(l.spatialReference),i=[];for(let n=0;n<r.length;n++){const a=r[n],f=s.fromJSON(a),m=a.geometry?.spatialReference;f.geometry==null||m||(f.geometry.spatialReference=e);const t=a.aggregateGeometries,p=f.aggregateGeometries;if(t&&p!=null)for(const o in p){const u=p[o],g=t[o],y=g?.spatialReference;u==null||y||(u.spatialReference=e)}i.push(f)}return i}_quantizePoints(r,l,s){let e,i;const n=[];for(let a=0,f=r.length;a<f;a++){const m=r[a];if(a>0){const t=l(m[0]),p=s(m[1]);t===e&&p===i||(n.push([t-e,p-i]),e=t,i=p)}else e=l(m[0]),i=s(m[1]),n.push([e,i])}return n.length>0?n:null}_getQuantizationFunction(r,l,s){return r==="point"?e=>(e.x=l(e.x),e.y=s(e.y),e):r==="polyline"||r==="polygon"?e=>{const i=x(e)?e.rings:e.paths,n=[];for(let a=0,f=i.length;a<f;a++){const m=i[a],t=this._quantizePoints(m,l,s);t&&n.push(t)}return n.length>0?(x(e)?e.rings=n:e.paths=n,e):null}:r==="multipoint"?e=>{const i=this._quantizePoints(e.points,l,s);return i&&i.length>0?(e.points=i,e):null}:r==="extent"?e=>e:null}_getHydrationFunction(r,l,s,e,i){return r==="point"?n=>{n.x=l(n.x),n.y=s(n.y),e&&(n.z=e(n.z))}:r==="polyline"||r==="polygon"?n=>{const a=x(n)?n.rings:n.paths;let f,m;for(let t=0,p=a.length;t<p;t++){const o=a[t];for(let u=0,g=o.length;u<g;u++){const y=o[u];u>0?(f+=y[0],m+=y[1]):(f=y[0],m=y[1]),y[0]=l(f),y[1]=s(m)}}if(e&&i)for(let t=0,p=a.length;t<p;t++){const o=a[t];for(let u=0,g=o.length;u<g;u++){const y=o[u];y[2]=e(y[2]),y[3]=i(y[3])}}else if(e)for(let t=0,p=a.length;t<p;t++){const o=a[t];for(let u=0,g=o.length;u<g;u++){const y=o[u];y[2]=e(y[2])}}else if(i)for(let t=0,p=a.length;t<p;t++){const o=a[t];for(let u=0,g=o.length;u<g;u++){const y=o[u];y[2]=i(y[2])}}}:r==="extent"?n=>{n.xmin=l(n.xmin),n.ymin=s(n.ymin),n.xmax=l(n.xmax),n.ymax=s(n.ymax),e&&n.zmax!=null&&n.zmin!=null&&(n.zmax=e(n.zmax),n.zmin=e(n.zmin)),i&&n.mmax!=null&&n.mmin!=null&&(n.mmax=i(n.mmax),n.mmin=i(n.mmin))}:r==="multipoint"?n=>{const a=n.points;let f,m;for(let t=0,p=a.length;t<p;t++){const o=a[t];t>0?(f+=o[0],m+=o[1]):(f=o[0],m=o[1]),o[0]=l(f),o[1]=s(m)}if(e&&i)for(let t=0,p=a.length;t<p;t++){const o=a[t];o[2]=e(o[2]),o[3]=i(o[3])}else if(e)for(let t=0,p=a.length;t<p;t++){const o=a[t];o[2]=e(o[2])}else if(i)for(let t=0,p=a.length;t<p;t++){const o=a[t];o[2]=i(o[2])}}:null}};h([d({type:String,json:{write:!0}})],c.prototype,"displayFieldName",void 0),h([d({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],c.prototype,"exceededTransferLimit",void 0),h([d({type:[T],json:{write:!0}})],c.prototype,"features",void 0),h([G("features")],c.prototype,"readFeatures",null),h([d({type:[J],json:{write:!0}})],c.prototype,"fields",void 0),h([d({type:["point","multipoint","polyline","polygon","extent","mesh"],json:{read:{reader:v.read}}})],c.prototype,"geometryType",void 0),h([z("geometryType")],c.prototype,"writeGeometryType",null),h([d({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],c.prototype,"hasM",void 0),h([d({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],c.prototype,"hasZ",void 0),h([d({types:P,json:{write:!0}})],c.prototype,"queryGeometry",void 0),h([G("queryGeometry")],c.prototype,"readQueryGeometry",null),h([d({type:w,json:{write:!0}})],c.prototype,"spatialReference",void 0),h([z("spatialReference")],c.prototype,"writeSpatialReference",null),h([d({json:{write:!0}})],c.prototype,"transform",void 0),c=R=h([j("esri.rest.support.FeatureSet")],c),c.prototype.toJSON.isDefaultToJSON=!0;export{c};
