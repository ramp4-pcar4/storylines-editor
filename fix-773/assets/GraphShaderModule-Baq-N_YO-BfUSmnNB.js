import{j as J}from"./enums-CQnCd4Rx-BzxILyyn.js";import{a3 as Bt,jc as Jt,W as Wt,h as Zt,v as w}from"./main-D8UjLOIQ.js";import{Y as Qt,_ as te}from"./Texture-D5XWO2GQ-DFkJKk2N.js";import"./enums-wEDHPbCF-Cf76M5_x.js";import"./FramebufferObject-D3QloItC-BvXrGTNY.js";import{X as ee}from"./ProgramTemplate-C4wmhGXE-Dwy69-qx.js";import{v as ne}from"./ShaderBuilder-CU5v4tk1-qD9qPa-X.js";let Be=class{constructor(){this.drawPhase=J.MAP|J.HITTEST|J.HIGHLIGHT|J.DEBUG}startup(){}shutdown(e){}};function re(e){return e.split(" ").map((t,n)=>n>0?t.charAt(0).toUpperCase()+t.slice(1):t).join("")}function ie(e,t){const n=[];for(n.push(t);n.length;){const r=n.pop();if(typeof r=="object"&&!e.has(r.uid)){e.add(r.uid);for(const i of r.children)n.push(i)}}}let E=class nt{constructor(){this.uid=nt.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}static{this.NodeCount=0}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(t){return t=re(t),this._debugName=t,this.isImplicit&&this.children[0]instanceof nt&&this.children[0].setDebugName(t),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(t){t._debugName=this._debugName,t._isMutable=this._isMutable,t.isImplicit=this.isImplicit,t.uid=this.uid}};function o(e){return typeof e=="object"?e.clone():e}let m=class extends E{constructor(){super(...arguments),this.shaderType="primitive-node"}},se=class Ot extends E{constructor(t){super(),this.child=t,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const t=new Ot(o(this.child));return this.cloneInto(t),t}};class Pt extends E{constructor(t,n,r){super(),this.property=t,this.target=n,this.returnType=r,this.shaderType="property-access-node"}get children(){const t=[this.target];return typeof this.property!="string"&&t.push(this.property),t}clone(){const t=new Pt(this.property,o(this.target),this.returnType);return this.cloneInto(t),t}}let oe=class jt extends E{constructor(t,n,r,i){super(),this.x=t,this.y=n,this.target=r,this.returnType=i,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const t=new jt(this.x,this.y,o(this.target),this.returnType);return this.cloneInto(t),t}};class Ft extends E{constructor(t,n,r){super(),this.condition=t,this.ifTrue=n,this.ifFalse=r,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const t=o(this.ifTrue),n=this.ifFalse?o(this.ifFalse):null,r=new Ft(this.condition,t,n);return this.cloneInto(r),r}}let ae=class Dt extends E{constructor(t,n,r,i){super(),this.captureList=t,this.returnType=n,this.generator=i,this.shaderType="block-node",r&&(this.subgraph=new se(r))}get children(){return Object.keys(this.captureList).map(t=>this.captureList[t]).concat(this.subgraph??[])}clone(){const t={};for(const r in this.captureList)t[r]=o(this.captureList[r]);const n=new Dt(t,this.returnType,this.subgraph?o(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(n),n}},F=class zt extends E{constructor(t,n,r,i,s,a=!1){super(),this.token=t,this._children=n,this.isInfix=r,this.isPropertyAccess=i,this.returnType=s,this.isTernary=a,this.shaderType="function-node"}get children(){return this._children}clone(){const t=new zt(this.token,this._children.map(o),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(t),t}};var q,rt,it,st,ot,at,ct,ut,ht,dt,pt,lt,ft,yt;function ce(e){switch(e.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return _;case"float":case"vec2":case"vec3":case"vec4":return l;case"int":case"ivec2":case"ivec3":case"ivec4":return y;case"uint":case"uvec2":case"uvec3":case"uvec4":return Q;default:throw new Error("Unable to handle type")}}function ue(e){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const n of t)if(n.includes(e))return n.map(r=>pe[r]);throw new Error("Unable to find type family")}function Lt(e){return new Proxy(e,{get(t,n){if(n==="constructor")return new Proxy(t.constructor,{construct:(r,i,s)=>Lt(new r(...i))});if(n in t)return t[n];if(typeof n=="string"){const r=ue(e.type);return $(e,n,r[n.length-1])}}})}function I(e){return new Proxy(e,{construct:(t,n,r)=>Lt(new t(...n))})}function he(e){return new Proxy(e,{get(t,n){if(n in t)return t[n];if(typeof n=="string"){const r=parseInt(n,10);if(!isNaN(r))return $(e,`[${r}]`,e.elementType.constructor)}}})}function de(e){return new Proxy(e,{construct:(t,n,r)=>he(new t(...n))})}class mt extends Error{}let gt=class extends m{static{q=this}static{this.type="array"}constructor(e,t){super(),this.elementType=e,this.size=t,this.children=[],this.type="array"}clone(){const e=new q(this.elementType,this.size);return super.cloneInto(e),e}get(e,t){const n=new y(e),r=t!=null?new y(t):null;return r!=null?tt(this,n,r,ce(this.elementType.constructor)):$(this,n,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(e,t,n){return ye(this,e,t,n)}glslFindIndex(e,t,n){return me(this,e,t,n)}static ofType(e,t){const n={construct:(r,i)=>new q(new e,t)};return new Proxy(q,n)}};gt=q=w([de],gt);class bt extends m{static{this.type="array-2d"}constructor(t,n,r,i=!1){super(),this.elementType=t,this.xSize=n,this.ySize=r,this.isRowMajor=i,this.children=[],this.type="array-2d"}clone(){const t=new bt(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(t),t}get size(){return this.xSize*this.ySize}get(t,n){return this.isRowMajor?this._getRowMajor(t,n):this._getColumnMajor(t,n)}_getColumnMajor(t,n){const r=new y(t);return $(this,new y(n).add(r.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(t,n){const r=new y(t),i=new y(n);return $(this,r.add(i.multiply(this.ySize)),this.elementType.constructor)}static ofType(t,n,r,i=!1){return new Proxy(gt,{construct:(s,a)=>new bt(new t,n,r,i)})}}class Gt extends m{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}static{this.type="sampler2D"}clone(){const t=new Gt;return t.children=this.children.map(o),super.cloneInto(t),t}}let l=class A extends m{static{this.type="float"}constructor(t){super(),this.type="float",this.children=[t]}clone(){const t=new A(o(this.children[0]));return super.cloneInto(t),t}multiply(t){return M(this,typeof t=="number"?g(t,A):t)}divide(t){return Y(this,typeof t=="number"?g(t,A):t)}add(t){return B(this,typeof t=="number"?g(t,A):t)}subtract(t){return X(this,typeof t=="number"?g(t,A):t)}},R=class extends m{static{rt=this}static{this.type="vec2"}constructor(e,t){super(),this.type="vec2",this.children=[e,t].filter(n=>n!=null)}clone(){const e=new rt(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}get 0(){return $(this,"[0]",l)}get 1(){return $(this,"[1]",l)}get 2(){throw new mt}get 3(){throw new mt}multiply(e){return M(this,typeof e=="number"?g(e,l):e)}divide(e){return Y(this,typeof e=="number"?g(e,l):e)}add(e){return B(this,typeof e=="number"?g(e,l):e)}subtract(e){return X(this,typeof e=="number"?g(e,l):e)}};R=rt=w([I],R);let Z=class extends m{static{it=this}static{this.type="vec3"}constructor(e,t,n){super(),this.type="vec3",this.children=[e,t,n].filter(r=>r!=null)}get 0(){return $(this,"[0]",l)}get 1(){return $(this,"[1]",l)}get 2(){return $(this,"[2]",l)}get 3(){throw new mt}clone(){const e=new it(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}multiply(e){return M(this,typeof e=="number"?g(e,l):e)}divide(e){return Y(this,typeof e=="number"?g(e,l):e)}add(e){return B(this,typeof e=="number"?g(e,l):e)}subtract(e){return X(this,typeof e=="number"?g(e,l):e)}};Z=it=w([I],Z);let C=class extends m{static{st=this}static{this.type="vec4"}constructor(e,t,n,r){super(),this.type="vec4",this.children=[e,t,n,r].filter(i=>i!=null)}clone(){const e=new st(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}get 0(){return $(this,"[0]",l)}get 1(){return $(this,"[1]",l)}get 2(){return $(this,"[2]",l)}get 3(){return $(this,"[3]",l)}multiply(e){return M(this,typeof e=="number"?g(e,l):e)}divide(e){return Y(this,typeof e=="number"?g(e,l):e)}add(e){return B(this,typeof e=="number"?g(e,l):e)}subtract(e){return X(this,typeof e=="number"?g(e,l):e)}};C=st=w([I],C);let Q=class extends m{static{ot=this}static{this.type="uint"}constructor(e){super(),this.type="uint",this.children=[e]}clone(){const e=new ot(o(this.children[0]));return super.cloneInto(e),e}};Q=ot=w([I],Q);let wt=class extends m{static{at=this}static{this.type="uvec2"}constructor(e,t){super(),this.type="uvec2",this.children=[e,t].filter(n=>n!=null)}clone(){const e=new at(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}};wt=at=w([I],wt);let vt=class extends m{static{ct=this}static{this.type="uvec3"}constructor(e,t,n){super(),this.type="uvec3",this.children=[e,t,n].filter(r=>r!=null)}clone(){const e=new ct(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}};vt=ct=w([I],vt);let xt=class extends m{static{ut=this}static{this.type="uvec4"}constructor(e,t,n,r){super(),this.type="uvec4",this.children=[e,t,n,r].filter(i=>i!=null)}clone(){const e=new ut(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}};xt=ut=w([I],xt);class _ extends m{static{this.type="bool"}constructor(t){super(),this.type="bool",this.children=[t]}and(t){return _e(this,t)}or(t){return be(this,t)}xor(t){return ve(this,t)}clone(){const t=new _(o(this.children[0]));return super.cloneInto(t),t}}let _t=class extends m{static{ht=this}static{this.type="bvec2"}constructor(e,t){super(),this.type="bvec2",this.children=[e,t].filter(n=>n!=null)}all(){return Et(this)}any(){return Kt(this)}clone(){const e=new ht(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}};_t=ht=w([I],_t);let $t=class extends m{static{dt=this}static{this.type="bvec3"}constructor(e,t,n){super(),this.type="bvec3",this.children=[e,t,n].filter(r=>r!=null)}all(){return Et(this)}any(){return Kt(this)}clone(){const e=new dt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}};function g(e,t){return typeof e=="number"?new t(e):e}$t=dt=w([I],$t);let It=class extends m{static{pt=this}static{this.type="bvec4"}constructor(e,t,n,r){super(),this.type="bvec4",this.children=[e,t,n,r].filter(i=>i!=null)}all(){return Et(this)}any(){return Kt(this)}clone(){const e=new pt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}};It=pt=w([I],It);class y extends m{static{this.type="int"}constructor(t){super(),this.type="int",this.children=[t]}multiply(t){return M(this,g(t,y))}add(t){return B(this,g(t,y))}subtract(t){return X(this,g(t,y))}divide(t){return Y(this,g(t,y))}clone(){const t=new y(o(this.children[0]));return super.cloneInto(t),t}}let Nt=class extends m{static{lt=this}static{this.type="ivec2"}constructor(e,t){super(),this.type="ivec2",this.children=[e,t].filter(n=>n!=null)}clone(){const e=new lt(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}};Nt=lt=w([I],Nt);let Tt=class extends m{static{ft=this}static{this.type="ivec3"}constructor(e,t,n){super(),this.type="ivec3",this.children=[e,t,n].filter(r=>r!=null)}clone(){const e=new ft(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}};Tt=ft=w([I],Tt);let Mt=class extends m{static{yt=this}static{this.type="ivec4"}constructor(e,t,n,r){super(),this.type="ivec4",this.children=[e,t,n,r].filter(i=>i!=null)}clone(){const e=new yt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}};Mt=yt=w([I],Mt);class qt extends m{static{this.type="mat2"}constructor(t,n,r,i){super(),this.type="mat2",this.children=[t,n,r,i]}clone(){const t=new qt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get(t,n){return tt(this,new y(t),new y(n),l)}multiply(t){return M(this,t)}}class H extends m{static{this.type="mat3"}static identity(){return new H(1,0,0,0,1,0,0,0,1)}static fromRotation(t){const n=Ne(t),r=Ie(t);return new H(r,n,0,fe(n),r,0,0,0,1)}constructor(t,n,r,i,s,a,u,c,h){super(),this.type="mat3",this.children=[t,n,r,i,s,a,u,c,h]}add(t){return B(this,t)}multiply(t){return M(this,t)}get(t,n){return tt(this,new y(t),new y(n),l)}clone(){const t=new H(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]));return super.cloneInto(t),t}}class W extends m{static{this.type="mat4"}static identity(){return new W(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(t,n,r,i,s,a,u,c,h,d,p,v,S,N,k,P){super(),this.type="mat4",this.children=[t,n,r,i,s,a,u,c,h,d,p,v,S,N,k,P]}static fromColumns(t,n,r,i){return new W(t.x,t.y,t.z,t.w,n.x,n.y,n.z,n.w,r.x,r.y,r.z,r.w,i.x,i.y,i.z,i.w)}multiply(t){return M(this,t)}get(t,n){return tt(this,new y(t),new y(n),l)}clone(){const t=new W(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]),o(this.children[9]),o(this.children[10]),o(this.children[11]),o(this.children[12]),o(this.children[13]),o(this.children[14]),o(this.children[15]));return super.cloneInto(t),t}}const pe={float:l,vec2:R,vec3:Z,vec4:C,int:y,ivec2:Nt,ivec3:Tt,ivec4:Mt,uint:Q,uvec2:wt,uvec3:vt,uvec4:xt,bool:_,bvec2:_t,bvec3:$t,bvec4:It},Oe=(...e)=>new y(...e),le=(...e)=>new l(...e),je=(...e)=>new R(...e),De=(...e)=>new Z(...e),ze=(...e)=>new C(...e),Le=(...e)=>new H(...e);function $(e,t,n){const r=new n(new Pt(t,e,n));return r.isImplicit=!0,r}function tt(e,t,n,r){const i=new r(new oe(t,n,e,r));return i.isImplicit=!0,i}function b(e,t,n,r=null){if(r){const s=new r,a=new r(new F(e,[t,n],!0,!1,s));return a.isImplicit=!0,a}if(t.type==="float"||t.type==="int"){const s=new n.constructor(new F(e,[t,n],!0,!1,n.constructor));return s.isImplicit=!0,s}if((t.type==="mat2"||t.type==="mat3"||t.type==="mat4")&&n.type!=="float"){const s=new n.constructor(new F(e,[t,n],!0,!1,n.constructor));return s.isImplicit=!0,s}const i=new t.constructor(new F(e,[t,n],!0,!1,t.constructor));return i.isImplicit=!0,i}function f(e,t,n=t.constructor){const r=new n(new F(e,[t],!1,!1,n));return r.isImplicit=!0,r}function T(e,t,n,r=t.constructor){const i=new r(new F(e,[t,n],!1,!1,r));return i.isImplicit=!0,i}function et(e,t,n,r,i=t.constructor){const s=new i(new F(e,[t,n,r],!1,!1,i));return s.isImplicit=!0,s}function fe(e){return M(e,le(-1))}function Ct(e,t,n,r){return new t(new ae(e,t,n,r))}function ye(e,t,n=0,r=e.size){const i=new y(n).setMutable().setDebugName("FindIndexIterator"),s=t(e.get(i)).setDebugName("FindIndexPredicate");return Ct({iter:i},y,s,({out:a,iter:u,subgraph:c})=>`
${a} = -1;

for (; ${u} < ${r}; ${u}++) {

${c.body}

  if (${c.varName}) {
    ${a} = ${u};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function me(e,t,n=0,r=e.size){return Ct({array:e},y,null,({out:i,array:s})=>`
${i} = -1;
for (int i = ${n}; i < ${r}; i++) {
  bool condition;
  ${t({array:s,i:"i",out:"condition"})}
  if (condition) {
    ${i} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function ge(e,t,n){const r=typeof t=="function"?t():t,i=typeof n=="function"?n():n,s=new r.constructor(new Ft(e,r,i));return s.isImplicit=!0,s}function Ge(...e){const t=e.map(([u,c])=>typeof c=="function"?[u,c()]:[u,c]),n=t[0][1].constructor,r=t.findIndex(u=>u[0]===!0);if(r===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const i=t.slice(0,r),s=t[r][1],a=new n(i.reduceRight((u,c)=>ge(c[0],c[1],u),s));return a.isImplicit=!0,a}function M(e,t){return b("*",e,t)}function Y(e,t){return b("/",e,t)}function B(e,t){return b("+",e,t)}function X(e,t){return b("-",e,t)}function qe(e,t){return b("%",e,t)}function He(e,t){return b("<<",e,t)}function Re(e,t){return b(">>",e,t)}function Ye(e,t){return b("&",e,t)}function Xe(e,t){return b("|",e,t)}function Je(e,t){return b("^",e,t)}function We(e){return f("~",e)}function Ze(e,t){return b("==",e,t,_)}function Qe(e,t){return b("!=",e,t,_)}function tn(e,t){return b("<",e,t,_)}function en(e,t){return b("<=",e,t,_)}function nn(e,t){return b(">",e,t,_)}function rn(e,t){return b(">=",e,t,_)}function be(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,n)=>we(t,n),e[0])}function we(e,t){return b("||",e,t,_)}function ve(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,n)=>xe(t,n),e[0])}function xe(e,t){return b("^^",e,t,_)}function _e(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,n)=>$e(t,n),e[0])}function $e(e,t){return b("&&",e,t,_)}function sn(e){return f("abs",e)}function on(e){return f("acos",e)}function an(e){return f("acosh",e)}function Et(e){return f("all",e,_)}function Kt(e){return f("any",e,_)}function cn(e){return f("asin",e)}function un(e){return f("asinh",e)}function hn(e,t){return t==null?f("atan",e):T("atan",e,t,e.constructor)}function dn(e){return f("atanh",e)}function pn(e){return f("ceil",e)}function ln(e,t,n){return et("clamp",e,t,n,e.constructor)}function Ie(e){return f("cos",e)}function fn(e){return f("cosh",e)}function yn(e,t){return T("distance",e,t,l)}function mn(e,t){return T("dot",e,t,l)}function gn(e){return f("exp",e)}function bn(e){return f("floor",e)}function wn(e){return f("fract",e)}function vn(e){return f("length",e,l)}function xn(e){return f("log",e)}function _n(e){return f("log2",e)}function $n(e,t){return T("max",e,t)}function In(e,t){return T("min",e,t)}function Nn(e,t,n){return et("mix",e,t,n)}function Tn(e,t){return T("mod",e,t)}function Mn(e){return f("normalize",e)}function Sn(e){return e.type==="bool"?f("!",e):f("not",e)}function kn(e,t){return T("pow",e,t)}function Pn(e){return f("round",e)}function Fn(e){return f("sign",e)}function Ne(e){return f("sin",e)}function Cn(e){return f("sinh",e)}function En(e,t,n){return et("smoothstep",e,t,n)}function Kn(e){return f("sqrt",e)}function Un(e,t){return T("step",e,t,t.constructor)}function An(e){return f("tan",e)}function Vn(e){return f("tanh",e)}function Bn(e,t,n){return et("texelFetch",e,t,n,C)}function On(e,t){return T("texture",e,t,C)}function jn(e,t){const{initialValue:n,xRange:r,yRange:i,callback:s}=t,[a,u]=r,[c,h]=i,d=new y(0).setMutable().setDebugName("iterX"),p=new y(0).setMutable().setDebugName("iterY"),v=n.setMutable().setDebugName("accumulator"),S=s(v,e.get(d,p),d,p).setDebugName("callback");return Ct({iterX:d,iterY:p,accumulator:v},n.constructor,S,({out:N,iterX:k,iterY:P,accumulator:j,subgraph:D})=>`
for (${P} = ${c}; ${P} < ${h}; ${P}++) {
  for (${k} = ${a}; ${k} < ${u}; ${k}++) {

  ${D.body}

  ${j} = ${D.varName};
  }
}
${N} = ${j};
`).setDebugName("reduce2DBody")}const z=5;function x(e,t,n){const r=t.split(`
`);for(const i of r)if(i.trim().length){{let s="";n!=null&&(s+=`/*id:${n??"000"}*/   `),e.body+=s.padEnd(14)}e.body+=" ".repeat(e.indent)+i+`
`}}class At{write(t){for(const n of t.rootOutputNodes())t.shouldPruneOutputNode(n)||(n.variableName=this._write(t,n.node));return t}_createVarName(t,n){let r="";return typeof n!="boolean"&&typeof n!="number"&&n.debugInfo.name&&(r=`${n.debugInfo.name}_`),`${r}v${t.varCount++}`}_write(t,n,r=!1){if(typeof n=="number"||typeof n=="boolean")return n.toString();let i=t.getEmit(n);if(i)return i;switch(n.shaderType){case"scope-node":i=this._writeScopeNode(t,n);break;case"primitive-node":i=this._writePrimitiveNode(t,n,r);break;case"function-node":i=this._writeFunctionNode(t,n);break;case"property-access-node":i=this._writePropertyAccessNode(t,n);break;case"property-access-2d-node":i=this._writePropertyAccess2DNode(t,n);break;case"text-node":i=n.text;break;case"block-node":i=this._writeBlockNode(t,n);break;case"condition-node":i=this._writeConditionNode(t,n)}return t.setEmit(n,i),i}_writeScopeNode(t,n){const r=new n.child.constructor;r.setDebugName(n.debugInfo.name);const i=this._write(t,r,!0);return x(t,`{ /*ScopeStart: ${n.uid} ${n.debugInfo.name}*/`),t.indent+=2,x(t,`${i} = ${this._write(t,n.child)};`),t.indent-=2,x(t,`} /*ScopeEnd: ${n.uid} ${n.debugInfo.name}*/`),i}_writeConditionNode(t,n){const r=new n.ifTrue.constructor,i=this._write(t,r,!0);x(t,`if (${this._write(t,n.condition)}) {`),t.indent+=2;const s=t.createSubgraphContext(),a=this._write(s,n.ifTrue);if(t.body+=s.body,a&&x(t,`${i} = ${a};`),t.indent-=2,x(t,"}"),n.ifFalse){x(t,"else {"),t.indent+=2;const u=t.createSubgraphContext(),c=this._write(u,n.ifFalse);t.body+=u.body,c&&x(t,`${i} = ${c};`),t.indent-=2,x(t,"}")}return i}_writeBlockNode(t,n){const{captureList:r,generator:i,returnType:s}=n,a={};for(const d in r){if(!r[d])continue;const p=this._write(t,r[d]);a[d]=p}const u=new s,c=this._write(t,u,!0);if(a.out=c,n.subgraph){const d=t.createSubgraphContext(),p=this._write(d,n.subgraph.child),v=d.body;a.subgraph={varName:p,body:v}}const h=i(a);return x(t,`{
`),t.indent+=2,x(t,h),t.indent-=2,x(t,`}
`),c}_writePropertyAccessNode(t,n){const r=this._write(t,n.target);return typeof n.property=="string"&&n.property.includes("[")?`${r}${n.property}`:typeof n.property!="string"?`${r}[${this._write(t,n.property)}]`:`${r}.${n.property}`}_writePropertyAccess2DNode(t,n){return`${this._write(t,n.target)}[${this._write(t,n.x)}][${this._write(t,n.y)}]`}_writeFunctionNode(t,n){const r=n.returnType.type;if(n.isInfix){const[a,u]=n.children.map(h=>this._write(t,h)),c=this._createVarName(t,n);return x(t,`${r.padEnd(z)} ${c} = ${a} ${n.token} ${u};`,n.uid),c}const i=n.children.map(a=>this._write(t,a)).join(", "),s=this._createVarName(t,n);return x(t,`${r.padEnd(z)} ${s} = ${n.token}(${i});`,n.uid),s}_writePrimitiveNode(t,n,r=!1){const i=t.getInput(n);if(i)return i.isUsed=!0,i.variableName;const s=n.children.length===1&&n.children[0]?.type===n.type;if(!n.isMutable&&(n.isImplicit||s))return this._write(t,n.children[0]);const a=this._createVarName(t,n);if(r)return x(t,`${n.type.padEnd(z)} ${a};`,n.uid),a;const u=!n.debugInfo.name&&!n.isMutable;if(u&&n.type==="float"&&typeof n.children[0]=="number")return Number.isInteger(n.children[0])?n.children[0].toFixed(1):n.children[0].toString();if(u&&n.type==="int"&&typeof n.children[0]=="number"&&Number.isInteger(n.children[0]))return n.children[0].toString();const c=n.children.map(h=>this._write(t,h)).join(", ");return n.type==="array"?(x(t,`${n.type.padEnd(z)} ${a} = [${c}];`,n.uid),a):u?`${n.type}(${c})`:(x(t,`${n.type.padEnd(z)} ${a} = ${n.type}(${c});`,n.uid),a)}}let K=class Ht{constructor(t,n,r){this.variableName=t,this.variableInputType=n,this.node=r,this.type="shader-input",this.isUsed=!1}clone(){return new Ht(this.variableName,this.variableInputType,o(this.node))}},U=class Rt{constructor(t,n,r){this.outVariableName=t,this.outVariableType=n,this.node=r,this.type="shader-output"}clone(){const t=new Rt(this.outVariableName,this.outVariableType,o(this.node));return t.variableName=this.variableName,t}};class V{static createVertex(t,n,r,i,s,a){const u=[];for(const h in t){const d=t[h],p=r.get(h);p?u.push(new K(p,"builtin",d)):u.push(new K("a_"+h,"in",d))}for(const h of i){const d=h.uniformHydrated;u.push(new K(h.uniformName,"uniform",d))}const c=[];for(const h in n){const d=n[h];h==="glPosition"?c.push(new U("gl_Position","builtin",d)):h==="glPointSize"?c.push(new U("gl_PointSize","builtin",d)):c.push(new U("v_"+h,"out",d))}return new V(u,c,s,a)}static createFragment(t,n,r,i,s,a){const u=[],c=Array.from(s.rootOutputNodes());for(const d in t){const p=t[d],v=r.get(d);if(v){u.push(new K(v,"builtin",p));continue}const S=c.find(N=>N.node===p);S&&u.push(new K(S.outVariableName,"in",p))}for(const d of i){const p=d.uniformHydrated;u.push(new K(d.uniformName,"uniform",p))}const h=[];for(const d in n){const p=n[d],v=r.get(d);d==="discard"?h.push(new U(null,"discard",p)):v?h.push(new U(v,"builtin",p)):h.push(new U(d,"out",p))}return new V(u,h,a)}constructor(t,n,r,i){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const s of t)this._inputShaderTypesByNodeUid.set(s.node.uid,s);this._outputShaderTypes=n,this._transformFeedbackBindings=r,this._transformFeedbackNames=new Set(r.map(s=>"v_"+s.propertyKey)),this._usedInFragmentShader=i}shouldPruneOutputNode(t){return!!this._usedInFragmentShader&&t.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(t.outVariableName)&&!this._usedInFragmentShader.has(t.node.uid)}setEmit(t,n){this._nodeEmitMap.set(t.uid,n)}getEmit(t){return this._nodeEmitMap.get(t.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(t){return this._inputShaderTypesByNodeUid.get(t.uid)}*rootOutputNodes(){for(const t of this._outputShaderTypes)yield t}*nodes(){const t=[];for(const n of this._outputShaderTypes.values())t.push(n.node);for(;t.length;){const n=t.pop();typeof n!="number"&&typeof n!="boolean"&&t.push(...n.children.filter(Boolean)),yield n}}*nodesOfTypeOrFunction(){for(const t of this.nodes())typeof t!="number"&&typeof t!="boolean"&&(yield t)}createSubgraphContext(){const t=this.clone();return t.body="",t.indent=this.indent+2,t._nodeEmitMap=new Map(this._nodeEmitMap),t}clone(){const t=new V([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return t._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,t.indent=this.indent,t.body=this.body,t.varCount=this.varCount,t._nodeEmitMap=this._nodeEmitMap,t}insertVertexShader(t){t.vertex.code.add(""),this._insertInputs(t,"vertex"),t.vertex.code.add(""),t.vertex.code.add("// OUTPUTS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const n of this.rootOutputNodes()){const r=n.outVariableType==="builtin";this.shouldPruneOutputNode(n)||(r?t.vertex.code.add(`// ${n.outVariableType.padEnd(7)} ${n.node.type.padEnd(9)} ${n.outVariableName};`):t.vertex.code.add(`${n.outVariableType.padEnd(10)} ${n.node.type.padEnd(9)} ${n.outVariableName};`))}t.vertex.code.add(""),t.vertex.code.add("void main() {"),t.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const n of this.rootOutputNodes())this.shouldPruneOutputNode(n)||t.vertex.code.add(`  ${n.outVariableName} = ${n.variableName};`);t.vertex.code.add("}")}insertFragmentShader(t){this._insertInputs(t,"fragment"),t.fragment.code.add(""),t.fragment.code.add("// OUTPUTS: "),t.fragment.code.add("// --------------------------------------------------------- ");let n=0;for(const r of this.rootOutputNodes())r.outVariableType==="builtin"?t.fragment.code.add(`// ${r.outVariableType.padEnd(7)} ${r.node.type.padEnd(9)} ${r.outVariableName};`):t.outputs.add(r.outVariableName,r.node.type,n++);t.fragment.code.add(""),t.fragment.code.add("void main() {"),t.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const r of this.rootOutputNodes())r.outVariableType==="discard"?(t.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),t.fragment.code.add(`  if (${r.variableName}) {`),t.fragment.code.add("    discard;"),t.fragment.code.add("  }"),t.fragment.code.add("  ")):t.fragment.code.add(`  ${r.outVariableName} = ${r.variableName};`);t.fragment.code.add("}")}_insertInputs(t,n){t[n].code.add("// INPUTS: "),t[n].code.add("// --------------------------------------------------------- ");for(const r of this.inputs())r.isUsed&&r.variableInputType!=="builtin"&&(r.node.type==="array"?t[n].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}];`):r.node.type==="array-2d"?t[n].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}]; // Emulated 2D Array. Not supported by ES3.0`):t[n].code.add(`${r.variableInputType.padEnd(10)} ${r.node.type.padEnd(9)} ${r.variableName};`))}}function Te(e,t,n){const r=new Qt(t.width,t.height);return r.dataType=t.dataType,t.depth&&(r.depth=t.depth),t.flipped&&(r.flipped=t.flipped),t.hasMipmap&&(r.hasMipmap=t.hasMipmap),r.internalFormat=t.internalFormat,t.isImmutable&&(r.isImmutable=t.isImmutable),t.isOpaque&&(r.isOpaque=t.isOpaque),t.maxAnisotropy&&(r.maxAnisotropy=t.maxAnisotropy),r.pixelFormat=t.pixelFormat,t.preMultiplyAlpha&&(r.preMultiplyAlpha=t.preMultiplyAlpha),t.samplingMode&&(r.samplingMode=t.samplingMode),t.target&&(r.target=t.target),r.uniform=t.uniform,t.unpackAlignment&&(r.unpackAlignment=t.unpackAlignment),t.wrapMode&&(r.wrapMode=t.wrapMode),new te(e,r,n)}const Me=()=>Bt.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function L(e,t,n){const r=t.length;if(r!==n){const i=new Zt("Invalid Uniform",`Invalid length, expected ${n} but got ${r}`,{uniformName:e,values:t});Me().errorOnce(i)}}class Vt{constructor(t,n,r,i,s,a){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=t,this.fragmentShader=n,this._locations=r,this._locationInfo=i,this._uniformBindings=s,this._transformFeedbackBindings=a}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(t){this._uniforms=t}cleanupTemporaryTextures(){for(const t of this._temporaryTextures)t.dispose();this._temporaryTextures=[]}bind(t){const n=this._uniforms;if(!this._program){const i=new Map;for(const[a,u]of this._locations)i.set(a,u);const s=[];for(const a of this._transformFeedbackBindings??[]){const{index:u,propertyKey:c}=a;s[u]=`v_${c}`}this._program=new ee(t,this.vertexShader,this.fragmentShader,i,new Map,s)}const r=this._program;t.useProgram(r);for(const i of this._uniformBindings){const{shaderModulePath:s,uniformName:a,uniformType:u,uniformArrayLength:c}=i,h=Wt(s,n);if(h==null){if(u==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${s}`)}switch(u==="array"||u==="array-2d"?i.uniformArrayElementType:u){case"sampler2D":{const{unit:d,texture:p}=h;if(r.setUniform1i(a,d),"type"in p)t.bindTexture(p,d);else{const v=Te(t,p.descriptor,p.data);t.bindTexture(v,d)}break}case"int":if(!c){r.setUniform1i(a,h);break}L(i.uniformName,h,c),r.setUniform1iv(a,h);break;case"float":if(!c){r.setUniform1f(a,h);break}L(i.uniformName,h,c),r.setUniform1fv(a,h);break;case"vec2":if(!c){r.setUniform2f(a,h[0],h[1]);break}L(i.uniformName,h,c),r.setUniform2fv(a,h.flat());break;case"vec3":if(!c){r.setUniform3f(a,h[0],h[1],h[2]);break}L(i.uniformName,h,c),r.setUniform3fv(a,h.flat());break;case"vec4":if(!c){r.setUniform4f(a,h[0],h[1],h[2],h[3]);break}L(i.uniformName,h,c),r.setUniform4fv(a,h.flat());break;case"mat3":r.setUniformMatrix3fv(a,h);break;case"mat4":r.setUniformMatrix4fv(a,h);break;default:throw new Error(`Unable to set uniform for type ${u}`)}}}}function G(e){return new e}function O(e,t,n){const r=e.constructor[t]??[];e.constructor.hasOwnProperty(t)||Object.defineProperty(e.constructor,t,{value:r.slice()}),e.constructor[t].push(n)}function Dn(e,t){return(n,r)=>{O(n,"locations",{typeCtor:t,propertyKey:r,parameterIndex:null,index:e})}}const Se=e=>(t,n)=>{O(t,"builtins",{builtin:e,propertyKey:n})},zn=e=>(t,n,r)=>{O(t,"inputs",{inputCtor:e,propertyKey:n,parameterIndex:r})},Ln=e=>(t,n)=>{O(t,"uniforms",{typeCtor:e,propertyKey:n})},Gn=e=>(t,n)=>{O(t,"options",{typeCtor:e,propertyKey:n})},qn=(e,t)=>{O(e,"defines",{propertyKey:t})},St=(e,t)=>(n,r)=>{n.constructor.builtins.push({builtin:e,propertyKey:r,typeCtor:t})};let ke=class{static{this.builtins=[]}};w([St("gl_VertexID",y)],ke.prototype,"glVertexID",void 0);class Rn{}let kt=class{static{this.builtins=[]}};w([St("gl_FragCoord",C)],kt.prototype,"glFragCoord",void 0),w([St("gl_PointCoord",R)],kt.prototype,"glPointCoord",void 0);class Pe{}w([Se("gl_FragDepth")],Pe.prototype,"glFragDepth",void 0);let Yn=class{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},Xn=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const e=this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===0);if(!e)throw new Error("Unable to find vertex input parameter");return e}get computeInput(){return this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="vertex"&&e.parameterIndex===1)}get fragmentInput(){const e=this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="fragment");if(!e)throw new Error("Unable to find fragment input parameter");return e}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const e=new Map,t=new Set;for(const n of this.locations)t.has(n.index)?Bt.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${n.propertyKey} to ${n.index}. Index already in use`,{locationsMap:e}):(e.set(n.propertyKey,n.index),t.add(n.index));return e}get locationInfo(){if(!this._locationInfo){const e=this.locationsMap,t=Array.from(e.entries()).map(([i,s])=>`${i}.${s}`).join("."),n=Jt(t),r=this.computeAttributes;this._locationInfo={hash:n,stringHash:t,locations:e,computeAttributeMap:r}}return this._locationInfo}get renamedLocationsMap(){const e=new Map;for(const t of this.locations)e.set("a_"+t.propertyKey,t.index);return e}get optionPropertyKeys(){if(!this._optionPropertyKeys){const e=new Set;for(const t of this._options)e.add(t.propertyKey);this._optionPropertyKeys=e}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(e,t,n,r){try{const{vertex:i,fragment:s,uniformBindings:a}=this._generateShaders(e,t,n,r);return new Vt(i,s,this.renamedLocationsMap,this.locationInfo,a,this.transformFeedbackBindings)}catch{return new Vt("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(e){const t=this._options.find(r=>r.propertyKey===e);if(t)return{type:"option",className:t.typeCtor};const n=this._uniforms.find(r=>r.propertyKey===e);if(!n)throw new Error(`Unable to find uniform class type for property: ${e}`);return{type:"required",className:n.typeCtor}}getShaderKey(e,t,n,r){const i=Object.keys(e).map(c=>`${c}.${e[c]}`).join("."),s=Object.keys(n).map(c=>`${c}.${n[c]}`).join("."),a=Object.keys(r).map(c=>`${c}.${r[c]}`).join("."),u=Object.keys(t).filter(c=>this.optionPropertyKeys.has(c)&&t[c]).join(".");return`${this.type}.${i}.${s}.${a}.${u}`}_generateShaders(e,t,n,r){const i=[];this._setDefines(n),this._setOptionalUniforms(i,t),this._setRequiredUniforms(i);const s=this._hydrateVertexInput(r),a=this._injectPackPrecisionFactor(s,e),u=this._hydrateComputeInput(),c=u&&this._injectComputePackPrecisionFactor(u,e),h=this.vertex(a,c),d=this._hydrateFragmentInput(h),p=this.fragment(d),v=new Set;for(const Yt in p){const Xt=p[Yt];ie(v,Xt)}const S=this._getVertexInputBuiltins(),N=V.createVertex({...s,...u},h,S,i,this.transformFeedbackBindings,v);new At().write(N);const k=this._getFragmentInputBuiltins(p);k.set("glPointCoord","gl_PointCoord");const P=V.createFragment(d,p,k,i,N,this.transformFeedbackBindings);new At().write(P);const j=this._createShaderBuilder(N,P),D=j.generate("vertex"),Ut=j.generate("fragment");return this.logShader&&(console.log(D),console.log(Ut)),{vertex:D,fragment:Ut,uniformBindings:i}}_setDefines(e){for(const t in e)this[t]=e[t]}_setOptionalUniforms(e,t){for(const n of this._options)t[n.propertyKey]?this[n.propertyKey]=this._hydrateUniformGroup(e,n):this[n.propertyKey]=null}_setRequiredUniforms(e){for(const t of this._uniforms)this[t.propertyKey]=this._hydrateUniformGroup(e,t)}_hydrateUniformGroup(e,t){const n=new t.typeCtor;for(const r of n._uniforms??[]){const i=G(r.typeCtor),s=`u_${t.propertyKey}_${r.propertyKey}`,a=i.type,u=[t.propertyKey,r.propertyKey].join(".");if("type"in r.typeCtor&&r.typeCtor.type==="array"){const c=i;e.push({shaderModulePath:u,uniformName:s,uniformType:a,uniformArrayLength:c.size,uniformArrayElementType:c.elementType.type,uniformHydrated:i})}else if("type"in r.typeCtor&&r.typeCtor.type==="array-2d"){const c=i;e.push({shaderModulePath:u,uniformName:s,uniformType:a,uniformArrayLength:c.size,uniformArrayElementType:c.elementType.type,uniformHydrated:i})}else e.push({shaderModulePath:u,uniformName:s,uniformType:a,uniformHydrated:i});n[r.propertyKey]=i}return n}_hydrateVertexInput(e){const t=this.vertexInput.inputCtor,n=t.locations.reduce((r,i)=>e[i.propertyKey]===!1?r:{...r,[i.propertyKey]:G(i.typeCtor)},{});for(const{propertyKey:r,typeCtor:i}of t.builtins){const s=G(i);n[r]=s}return n}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((e,t)=>({...e,[t.propertyKey]:G(t.typeCtor)}),{})}_injectPackPrecisionFactor(e,t){const n={};for(const r in e){const i=e[r],s=t[r];if(s){if(i.type!=="float"&&i.type!=="vec2"&&i.type!=="vec3"&&i.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);n[r]=i.divide(new l(s))}else n[r]=i}return n}_injectComputePackPrecisionFactor(e,t){const n={},r=new Map;for(const i in this.computeAttributes)for(const s of this.computeAttributes[i]??[])r.set(s,i);for(const i in e){const s=e[i],a=r.get(i);if(!a)continue;const u=t[a];if(u){if(s.type!=="float"&&s.type!=="vec2"&&s.type!=="vec3"&&s.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);n[i]=s.divide(new l(u))}else n[i]=s}return n}_hydrateFragmentInput(e){const t={};for(const n in e)t[n]=e[n];for(const{propertyKey:n,typeCtor:r}of kt.builtins){const i=G(r);t[n]=i}return t}_getVertexInputBuiltins(){const e=this.vertexInput.inputCtor,t=new Map;for(const{builtin:n,propertyKey:r}of e.builtins)t.set(r,n);return t}_getFragmentInputBuiltins(e){const t=e.constructor,n=new Map;for(const r of t.builtins??[])n.set(r.propertyKey,r.builtin);return n}_createShaderBuilder(e,t){const n=new ne;return this._insertDebugInfo(n),e.insertVertexShader(n),t.insertFragmentShader(n),n}_insertDebugInfo(e){e.vertex.code.add("// DEFINES: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._defines)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`);e.vertex.code.add(""),e.vertex.code.add("// OPTIONS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._options)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`)}};export{Un as $,Le as A,Gt as B,en as C,H as D,Sn as E,Vt as F,be as G,_e as H,Kn as I,Mn as J,Ye as K,ge as L,Ln as M,je as N,Ze as O,C as P,Pe as Q,Z as R,On as S,Dn as T,R as U,qt as V,qn as W,Ne as X,Gn as Y,gt as Z,_,In as a,Yn as a0,Oe as a1,pn as a2,ke as a3,Rn as a4,rn as a5,zn as a6,kt as a7,Pn as a8,qe as a9,bt as aA,M as aa,hn as ab,ze as ac,De as ad,Fn as ae,jn as af,Qe as ag,ve as ah,Je as ai,We as aj,He as ak,Xe as al,Vn as am,An as an,Cn as ao,fn as ap,dn as aq,un as ar,cn as as,an as at,on as au,gn as av,_n as aw,xn as ax,Nt as ay,Bn as az,nn as b,Xn as c,$n as d,En as e,Nn as f,W as g,sn as h,yn as i,tn as j,bn as k,Be as l,Re as m,wn as n,Ge as o,l as p,Ie as q,ln as r,mn as s,kn as t,vn as u,Tn as v,Ct as w,le as x,y,fe as z};
