import{a0 as T,N as D,a6 as q,ai as z,ba as _,an as S,d6 as L,Y as x,d7 as P,h as u,p as I,s as M,Q as C,i as U,d8 as N,v as d,S as y,n as k}from"./main-D8UjLOIQ.js";import{G as j}from"./ByteSizeUnit-DL8UhsB0-B2-AmVRx.js";import{i as E}from"./LRUCache-DPWdPNTF-Du_Z0yHt.js";import{e as H}from"./TileKey-B_6qmYK--BtZdR-Xy.js";import{c as J}from"./memoryEstimations-DeWfxwaV-DpFMiS4z.js";function R(e,t=!1){return e<=N?t?new Array(e).fill(0):new Array(e):new Uint32Array(e)}class w{constructor(t){G(t);const{location:a,data:i}=t;this.location=Object.freeze(U(a));const l=this.location.width,r=this.location.height;let o=!0,s=!0;const c=Math.ceil(l*r/32),n=R(c);let h=0;for(let f=0;f<i.length;f++){const p=f%32;i[f]?(s=!1,n[h]|=1<<p):o=!1,p===31&&++h}s?(this._availability="unavailable",this.byteSize=40):o?(this._availability="available",this.byteSize=40):(this._availability=n,this.byteSize=40+J(n))}getAvailability(t,a){if(this._availability==="unavailable"||this._availability==="available")return this._availability;const i=(t-this.location.top)*this.location.width+(a-this.location.left),l=i%32,r=i>>5,o=this._availability;return r<0||r>o.length?"unknown":o[r]&1<<l?"available":"unavailable"}static fromDefinition(t,a){const i=t.service.request||D,{row:l,col:r,width:o,height:s}=t,c={query:{f:"json"}};return a=a?{...c,...a}:c,i(F(t),a).then(n=>n.data).catch(n=>{if(n?.details?.httpStatus===422)return{location:{top:l,left:r,width:o,height:s},valid:!0,data:new Array(o*s).fill(0)};throw n}).then(n=>{if(n.location&&(n.location.top!==l||n.location.left!==r||n.location.width!==o||n.location.height!==s))throw new u("tilemap:location-mismatch","Tilemap response for different location than requested",{response:n,definition:{top:l,left:r,width:o,height:s}});return w.fromJSON(n)})}static fromJSON(t){return Object.freeze(new w(t))}}function $(e){return`${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}function F(e){let t;if(e.service.tileServers?.length){const i=e.service.tileServers;t=`${i&&i.length?i[e.row%i.length]:e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}else t=`${e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`;const a=e.service.query;return a&&(t=`${t}?${a}`),t}function G(e){if(!e?.location)throw new u("tilemap:missing-location","Location missing from tilemap response");if(e.valid===!1)throw new u("tilemap:invalid","Tilemap response was marked as invalid");if(!e.data)throw new u("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(e.data))throw new u("tilemap:data-mismatch","Data must be an array of numbers");if(e.data.length!==e.location.width*e.location.height)throw new u("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}var v;function A(e,t,a){return new u("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:a})}let m=class extends T{static{v=this}constructor(e){super(e),this._pendingTilemapRequests={},this.request=D,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new E(2*j.MEGABYTES),this.addHandles(q(()=>{const{layer:e}=this;return[e?.parsedUrl,e?.tileServers,e?.apiKey,e?.customParameters]},()=>this._initializeTilemapDefinition(),z))}get effectiveMinLOD(){return this.minLOD??this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}getAvailability(e,t,a){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return"unavailable";const i=this._tilemapFromCache(e,t,a,this._tmpTilemapDefinition);return i?i.getAvailability(t,a):"unknown"}fetchAvailability(e,t,a,i){return!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD?Promise.reject(A(e,t,a)):this._fetchTilemap(e,t,a,i).catch(l=>l).then(l=>{if(l instanceof w){const r=l.getAvailability(t,a);if(r==="unavailable")throw A(e,t,a);return r}if(_(l))throw l;return"unknown"})}fetchAvailabilityUpsample(e,t,a,i,l){i.level=e,i.row=t,i.col=a;const r=this.layer.tileInfo;r.updateTileInfo(i);const o=this.fetchAvailability(e,t,a,l).catch(s=>{if(_(s))throw s;if(r.upsampleTile(i))return this.fetchAvailabilityUpsample(i.level,i.row,i.col,i,l);throw s});return this._fetchAvailabilityUpsamplePrefetch(i.id,e,t,a,l,o),o}async _fetchAvailabilityUpsamplePrefetch(e,t,a,i,l,r){if(!this._prefetchingEnabled||e==null)return;const o=`prefetch-${e}`;if(this.hasHandles(o))return;const s=new AbortController;r.then(()=>s.abort(),()=>s.abort());let c=!1;const n=S(()=>{c||(c=!0,s.abort())});if(this.addHandles(n,o),await L(10,s.signal).catch(()=>{}),c||(c=!0,this.removeHandles(o)),x(s))return;const h=new H(e,t,a,i),f={...l,signal:s.signal},p=this.layer.tileInfo;for(let O=0;v._prefetches.length<v._maxPrefetch&&p.upsampleTile(h);++O){const b=this.fetchAvailability(h.level,h.row,h.col,f);v._prefetches.push(b);const g=()=>{v._prefetches.removeUnordered(b)};b.then(g,g)}}static{this._maxPrefetch=4}static{this._prefetches=new P({initialSize:v._maxPrefetch})}_fetchTilemap(e,t,a,i){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return Promise.reject(new u("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const l=this._tmpTilemapDefinition,r=this._tilemapFromCache(e,t,a,l);if(r)return Promise.resolve(r);const o=i?.signal;return i={...i,signal:null},new Promise((s,c)=>{I(o,()=>c(M()));const n=$(l);let h=this._pendingTilemapRequests[n];if(!h){h=w.fromDefinition(l,i).then(p=>(this._tilemapCache.put(n,p,p.byteSize),p));const f=()=>{delete this._pendingTilemapRequests[n]};this._pendingTilemapRequests[n]=h,h.then(f,f)}h.then(s,c)})}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const{parsedUrl:e,apiKey:t,customParameters:a}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:C({...e.query,...a,token:t??e.query?.token}),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,t,a,i){i.level=e,i.row=t-t%this.size,i.col=a-a%this.size;const l=$(i);return this._tilemapCache.get(l)}get test(){}};d([y({constructOnly:!0})],m.prototype,"layer",void 0),d([y({constructOnly:!0})],m.prototype,"minLOD",void 0),d([y({constructOnly:!0})],m.prototype,"maxLOD",void 0),d([y({constructOnly:!0})],m.prototype,"request",void 0),d([y({constructOnly:!0})],m.prototype,"size",void 0),m=v=d([k("esri.layers.support.TilemapCache")],m);export{m as u};
