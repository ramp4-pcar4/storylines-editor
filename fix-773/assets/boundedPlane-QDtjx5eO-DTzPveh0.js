import{gJ as T,gL as Y,a3 as rt,dn as $,cq as st,gV as at,gU as q}from"./main-D8UjLOIQ.js";import{X as R,P as ct}from"./sphere-zPMQWhGG-C71NzDQ7.js";import{z as ut,G as gt,s as bt}from"./mat4-OOmHNWi7-Bnj6TIOE.js";import{n as X}from"./mat4f64-xsZDPPj0-Dq35B4BL.js";import{_ as u,y as h,b as I,Y as m,L as l,P as p,r as C,A as M,g as ft,R as x,W as lt,v as B,l as k}from"./vec32-Cj8pVsU0-BmYyqgTW.js";import{E as K,S as pt,M as dt}from"./lineSegment-BAWQVP9P-DeXzNZgW.js";import{y as E,t as O,K as mt,$ as y,Y as ht,i as It,o as Pt,d as $t,e as W,w as Mt,a as Nt,s as yt}from"./plane-Cf3Koz3c-CFwUi6Ll.js";import{q as s,b as N}from"./vectorStacks-5ZZtmT9E-D2GdqudT.js";const A=()=>rt.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class wt{constructor(){this.plane=E(),this.origin=$(),this.basis1=$(),this.basis2=$()}}const Et=wt;function P(t=ot){return{plane:E(t.plane),origin:Y(t.origin),basis1:Y(t.basis1),basis2:Y(t.basis2)}}function _t(t,i,n){const e=Bt.get();return e.origin=t,e.basis1=i,e.basis2=n,e.plane=mt(0,0,0,0),v(e),e}function _(t,i=P()){return Z(t.origin,t.basis1,t.basis2,i)}function vt(t,i){u(i.origin,t.origin),u(i.basis1,t.basis1),u(i.basis2,t.basis2),Mt(i.plane,t.plane)}function Z(t,i,n,e=P()){return u(e.origin,t),u(e.basis1,i),u(e.basis2,n),v(e),jt(e,"fromValues()"),e}function v(t){O(t.basis2,t.basis1,t.origin,t.plane)}function H(t,i,n){t!==n&&_(t,n);const e=l(s.get(),f(t),i);return p(n.origin,n.origin,e),n.plane[3]-=i,n}function St(t,i,n){return D(i,n),H(n,U(t,t.origin),n),n}function Tt(t,i){const n=t.basis1[0],e=t.basis2[1],[o,r]=t.origin;return st(o-n,r-e,o+n,r+e,i)}function D(t,i=P()){const n=(t[2]-t[0])/2,e=(t[3]-t[1])/2;return M(i.origin,t[0]+n,t[1]+e,0),M(i.basis1,n,0,0),M(i.basis2,0,e,0),$t(0,0,1,0,i.plane),i}function F(t,i,n){return!!Pt(t.plane,i,n)&&it(t,n)}function Yt(t,i,n){if(F(t,i,n))return n;const e=J(t,i,s.get());return p(n,i.origin,l(s.get(),i.direction,ft(i.origin,e)/I(i.direction))),n}function J(t,i,n){const e=w.get();et(t,i,e,w.get());let o=Number.POSITIVE_INFINITY;for(const r of z){const a=j(t,r,S.get()),g=s.get();if(Nt(e,a,g)){const c=lt(s.get(),i.origin,g),b=Math.abs(at(h(i.direction,c)));b<o&&(o=b,u(n,g))}}return o===Number.POSITIVE_INFINITY?Q(t,i,n):n}function qt(t,i){return(i-t)/i}function Q(t,i,n){if(F(t,i,n))return n;const e=w.get(),o=w.get();et(t,i,e,o);let r=Number.POSITIVE_INFINITY;for(const a of z){const g=j(t,a,S.get()),c=s.get();if(yt(e,g,c)){const b=ct(i,c);if(!W(o,c))continue;b<r&&(r=b,u(n,c))}}return G(t,i.origin)<r&&tt(t,i.origin,n),n}function tt(t,i,n){const e=It(t.plane,i,s.get()),o=K(L(t,t.basis1),e,-1,1,s.get()),r=K(L(t,t.basis2),e,-1,1,s.get());return C(n,p(s.get(),o,r),t.origin),n}function nt(t,i,n){const{origin:e,basis1:o,basis2:r}=t,a=C(s.get(),i,e),g=N(o,a),c=N(r,a),b=N(f(t),a);return M(n,g,c,b)}function G(t,i){const n=nt(t,i,s.get()),{basis1:e,basis2:o}=t,r=I(e),a=I(o),g=Math.max(Math.abs(n[0])-r,0),c=Math.max(Math.abs(n[1])-a,0),b=n[2];return g*g+c*c+b*b}function xt(t,i){return Math.sqrt(G(t,i))}function At(t,i){let n=Number.NEGATIVE_INFINITY;for(const e of z){const o=j(t,e,S.get()),r=pt(o,i);r>n&&(n=r)}return Math.sqrt(n)}function Vt(t,i){return W(t.plane,i)&&it(t,i)}function Ot(t,i,n,e){return Ut(t,n,e)}function U(t,i){const n=-t.plane[3];return N(f(t),i)-n}function Rt(t,i,n,e){const o=U(t,i),r=l(zt,f(t),n-o);return p(e,i,r),e}function Ct(t,i){return x(t.basis1,i.basis1)&&x(t.basis2,i.basis2)&&x(t.origin,i.origin)}function Ft(t,i,n){return t!==n&&_(t,n),ut(d,i),gt(d,d),m(n.basis1,t.basis1,d),m(n.basis2,t.basis2,d),m(y(n.plane),y(t.plane),d),m(n.origin,t.origin,i),ht(n.plane,n.plane,n.origin),n}function Gt(t,i,n,e){return t!==e&&_(t,e),bt(V,i,n),m(e.basis1,t.basis1,V),m(e.basis2,t.basis2,V),v(e),e}function f(t){return y(t.plane)}function Ut(t,i,n){switch(i){case q.X:u(n,t.basis1),k(n,n);break;case q.Y:u(n,t.basis2),k(n,n);break;case q.Z:u(n,f(t))}return n}function it(t,i){const n=C(s.get(),i,t.origin),e=B(t.basis1),o=B(t.basis2),r=h(t.basis1,n),a=h(t.basis2,n);return-r-e<0&&r-e<0&&-a-o<0&&a-o<0}function L(t,i){const n=S.get();return u(n.origin,t.origin),u(n.vector,i),n}function j(t,i,n){const{basis1:e,basis2:o,origin:r}=t,a=l(s.get(),e,i.origin[0]),g=l(s.get(),o,i.origin[1]);p(n.origin,a,g),p(n.origin,n.origin,r);const c=l(s.get(),e,i.direction[0]),b=l(s.get(),o,i.direction[1]);return l(n.vector,p(c,c,b),2),n}function jt(t,i){Math.abs(h(t.basis1,t.basis2)/(I(t.basis1)*I(t.basis2)))>1e-6&&A().warn(i,"Provided basis vectors are not perpendicular"),Math.abs(h(t.basis1,f(t)))>1e-6&&A().warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-h(f(t),t.origin)-t.plane[3])>1e-6&&A().warn(i,"Plane offset is not consistent with plane origin")}function et(t,i,n,e){const o=f(t);O(o,i.direction,i.origin,n),O(y(n),o,i.origin,e)}const ot={plane:E(),origin:T(0,0,0),basis1:T(1,0,0),basis2:T(0,1,0)},w=new R(E),S=new R(dt),zt=$(),Bt=new R(()=>P()),z=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=X(),V=X(),Jt=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:Et,altitudeAt:U,axisAt:Ot,cameraFrustumCoverage:qt,closestPoint:Q,closestPointOnSilhouette:J,copy:_,copyWithoutVerify:vt,create:P,distance:xt,distance2:G,distanceToSilhouette:At,elevate:H,equals:Ct,extrusionContainsPoint:Vt,fromAABoundingRect:D,fromValues:Z,getExtent:Tt,intersectRay:F,intersectRayClosestSilhouette:Yt,normal:f,projectPoint:tt,projectPointLocal:nt,rotate:Gt,setAltitudeAt:Rt,setExtent:St,transform:Ft,up:ot,updateUnboundedPlane:v,wrap:_t},Symbol.toStringTag,{value:"Module"}));export{Z as C,_ as M,v as N,Jt as U,P as h,D as k,xt as n};
