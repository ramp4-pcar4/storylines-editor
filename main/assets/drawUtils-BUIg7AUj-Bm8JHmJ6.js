import{gI as I,ck as R,ld as k,ba as F}from"./main-D7vwjMDX.js";function z(n,o,a,e){if(n.type==="point")return n.x+=o,n.y+=a,n.hasZ&&e!=null&&(n.z+=e),n;if(n.type==="multipoint"){const r=n.points;for(let x=0;x<r.length;x++)r[x]=w(r[x],o,a,e);return n}if(n.type==="extent")return n.xmin+=o,n.xmax+=o,n.ymin+=a,n.ymax+=a,n;const m=I(n),t=n.type==="polyline"?n.paths:n.rings;for(let r=0;r<m.length;r++){const x=m[r];for(let i=0;i<x.length;i++)x[i]=w(x[i],o,a,e)}return"paths"in n?n.paths=t:n.rings=t,n}function $(n,o,a,e,m){const t=n.clone(),r=e.resolution;if(t.type==="point"){if(m)z(t,o*r,-a*r);else{const x=e.state.transform,i=e.state.inverseTransform,s=x[0]*t.x+x[2]*t.y+x[4],y=x[1]*t.x+x[3]*t.y+x[5];t.x=i[0]*(s+o)+i[2]*(y+a)+i[4],t.y=i[1]*(s+o)+i[3]*(y+a)+i[5]}return t}if(t.type==="multipoint"){if(m)z(t,o*r,-a*r);else{const x=t.points,i=e.state.transform,s=e.state.inverseTransform;for(let y=0;y<x.length;y++){const p=x[y],c=i[0]*p[0]+i[2]*p[1]+i[4],d=i[1]*p[0]+i[3]*p[1]+i[5],f=s[0]*(c+o)+s[2]*(d+a)+s[4],u=s[1]*(c+o)+s[3]*(d+a)+s[5];x[y]=Z(p,f,u,void 0)}}return t}if(t.type==="extent"){if(m)z(t,o*r,-a*r);else{const x=e.state.transform,i=e.state.inverseTransform,s=x[0]*t.xmin+x[2]*t.ymin+x[4],y=x[1]*t.xmin+x[3]*t.ymin+x[5],p=x[0]*t.xmax+x[2]*t.ymax+x[4],c=x[1]*t.xmax+x[3]*t.ymax+x[5];t.xmin=i[0]*(s+o)+i[2]*(y+a)+i[4],t.ymin=i[1]*(s+o)+i[3]*(y+a)+i[5],t.xmax=i[0]*(p+o)+i[2]*(c+a)+i[4],t.ymax=i[1]*(p+o)+i[3]*(c+a)+i[5]}return t}if(m)z(t,o*r,-a*r);else{const x=I(t),i=t.type==="polyline"?t.paths:t.rings,s=e.state.transform,y=e.state.inverseTransform;for(let p=0;p<x.length;p++){const c=x[p];for(let d=0;d<c.length;d++){const f=c[d],u=s[0]*f[0]+s[2]*f[1]+s[4],h=s[1]*f[0]+s[3]*f[1]+s[5],v=y[0]*(u+o)+y[2]*(h+a)+y[4],g=y[1]*(u+o)+y[3]*(h+a)+y[5];c[d]=Z(f,v,g,void 0)}}"paths"in t?t.paths=i:t.rings=i}return t}function j(n,o,a,e){if(n.type==="point"){const{x:f,y:u}=n,h=e?e[0]:f,v=e?e[1]:u,g=n.clone(),M=(f-h)*o+h,l=(u-v)*a+v;return g.x=M,g.y=l,g}if(n.type==="multipoint"){const f=I(n),u=R(),[h,v,g,M]=k(u,[f]),l=e?e[0]:(h+g)/2,T=e?e[1]:(M+v)/2,q=n.clone(),K=q.points;for(let b=0;b<K.length;b++){const L=K[b],[A,B]=L,D=(A-l)*o+l,E=(B-T)*a+T;K[b]=Z(L,D,E,void 0)}return q}if(n.type==="extent"){const{xmin:f,xmax:u,ymin:h,ymax:v}=n,g=e?e[0]:(f+u)/2,M=e?e[1]:(v+h)/2,l=n.clone();if(l.xmin=(f-g)*o+g,l.ymax=(v-M)*a+M,l.xmax=(u-g)*o+g,l.ymin=(h-M)*a+M,l.xmin>l.xmax){const T=l.xmin,q=l.xmax;l.xmin=q,l.xmax=T}if(l.ymin>l.ymax){const T=l.ymin,q=l.ymax;l.ymin=q,l.ymax=T}return l}const m=I(n),t=R(),[r,x,i,s]=k(t,m),y=e?e[0]:(r+i)/2,p=e?e[1]:(s+x)/2,c=n.clone(),d=c.type==="polyline"?c.paths:c.rings;for(let f=0;f<m.length;f++){const u=m[f];for(let h=0;h<u.length;h++){const v=u[h],[g,M]=v,l=(g-y)*o+y,T=(M-p)*a+p;d[f][h]=Z(v,l,T,void 0)}}return"paths"in c?c.paths=d:c.rings=d,c}function C(n,o,a,e,m,t){const r=Math.sqrt((a-n)*(a-n)+(e-o)*(e-o));return Math.sqrt((m-n)*(m-n)+(t-o)*(t-o))/r}function G(n,o,a,e=!1){const m=Math.atan2(o.y-a.y,o.x-a.x)-Math.atan2(n.y-a.y,n.x-a.x),t=Math.atan2(Math.sin(m),Math.cos(m));return e?t:F(t)}function w(n,o,a,e){return Z(n,n[0]+o,n[1]+a,n[2]!=null&&e!=null?n[2]+e:void 0)}function Z(n,o,a,e){const m=[o,a];return n.length>2&&m.push(e??n[2]),n.length>3&&m.push(n[3]),m}export{$ as I,j as J,C as K,G as L};
