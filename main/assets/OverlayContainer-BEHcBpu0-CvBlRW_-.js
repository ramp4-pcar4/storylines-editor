import{r as I}from"./common-CYWrYyJl-E8-sukrT.js";import{R as Q,E as Z,C as V,G as J,D as X}from"./mat3-CC4Foazl-BWjyqE2v.js";import{e as Y,E as tt,m as et}from"./MapView-BGOJJ8ch-Dje0kJEZ.js";import{e as st}from"./vec2f32-CVhmN3Me-DxoqVD7C.js";import{t as ot}from"./vec3f32-BS0cezmI-B_madU1n.js";import{l as it}from"./normalizeUtils-Bxmy9MNI-DBdQVIGZ.js";import{v as o,hF as L,aG as rt,aA as nt}from"./main-BNyfiy7F.js";import{N as at}from"./WGLContainer-LxgEo4I_-CLS4cGDP.js";import{T as pt,s as N,P as dt}from"./FeatureCommandQueue-DzV-HBIG-MSdGS75L.js";import{t as F,v as p,aw as B,ax as lt,ar as y,C as W,M as ht,S as R,a_ as ct,ay as ut,aC as ft,a4 as vt,L as mt,a7 as xt,bd as yt,b9 as gt,D as wt}from"./UpdateTracking2D-Du_WIf4G-D2umhCAm.js";import{L as _t,D,I as U,T as Mt}from"./enums-DBi1-Mm2-CUS1pvQe.js";class O extends lt{}o([F(0,y)],O.prototype,"pos",void 0),o([F(1,y)],O.prototype,"uv",void 0);class St extends yt{}class k extends W{}o([p(ht)],k.prototype,"dvs",void 0);class v extends W{}o([p(y)],v.prototype,"perspective",void 0),o([p(y)],v.prototype,"texSize",void 0),o([p(R)],v.prototype,"wrapAroundShift",void 0),o([p(R)],v.prototype,"opacity",void 0),o([p(ct)],v.prototype,"texture",void 0);class x extends ut{vertex(t){const s=t.uv.divide(this.config.texSize),e=new R(1).add(ft(s,this.config.perspective)),a=new vt(t.pos.add(new y(this.config.wrapAroundShift,0)),1),i=this.transform.dvs.multiply(a);return{uv:s,glPosition:new mt(i.xy.multiply(e),0,e)}}fragment(t){const s=xt(this.config.texture,t.uv).multiply(this.config.opacity),e=new gt;return e.glFragColor=s,e}}o([p(k)],x.prototype,"transform",void 0),o([p(v)],x.prototype,"config",void 0),o([L(0,B(O))],x.prototype,"vertex",null),o([L(0,B(St))],x.prototype,"fragment",null);let bt=class extends pt{constructor(){super(...arguments),this.type=wt.Overlay,this._mesh=null,this.shaders={overlay:new x}}render(n,t){const{context:s,painter:e}=n,a=this._getMesh(n,t);e.setPipelineState(N);const{isWrapAround:i,wrapAroundShift:d}=t.config,l={...t.config,wrapAroundShift:0},u={shader:this.shaders.overlay,uniforms:{transform:t.transform,config:l},defines:null,optionalAttributes:null,useComputeBuffer:!1};e.setPipelineState({...N,stencil:{write:!1,test:{compare:_t.EQUAL,op:{fail:D.KEEP,zFail:D.KEEP,zPass:D.REPLACE},ref:0,mask:255}}}),e.submitDrawMeshUntyped(s,u,a),i&&(l.wrapAroundShift=d,e.submitDrawMeshUntyped(s,u,a))}shutdown(){nt(this._mesh)}_getMesh(n,t){const{context:s}=n;if(this._mesh){const e=this._mesh.vertexBuffers.get("positions");if(!e)throw new Error("Buffer not found");e.setData(t.position)}else{const e=t.index!=null?t.index.length:t.position.length/2;this._mesh=new dt(s,{vertex:{positions:t.position,uvs:t.tex},index:t.index!=null?{index:t.index}:void 0,groups:[{attributes:[{name:"pos",count:2,type:U.FLOAT,location:0,vertex:"positions",stride:8,offset:0},{name:"tex",count:2,type:U.UNSIGNED_SHORT,location:1,vertex:"uvs",stride:4,offset:0}],index:t.index!=null?"index":void 0,primitive:Mt.TRIANGLE_STRIP}],parts:[{group:0,start:0,count:e}]})}return this._mesh}};class It extends at{constructor(){super(...arguments),this._viewStateId=-1,this._dvsMat3=Y(),this._overlayTechnique=new bt}get dvsMat3(){return this._dvsMat3}beforeRender(t){this._updateMatrices(t),this._updateOverlays(t,this.children);for(const s of this.children)s.beforeRender(t)}doRender(t){if(t.drawPhase!==tt.MAP||!this.visible)return;super.doRender(t);const s=this._overlayTechnique;for(const e of this.children)e.draw(t,s)}onDetach(){this._overlayTechnique.shutdown()}_updateMatrices(t){const{state:s}=t,{id:e,size:a,pixelRatio:i,resolution:d,rotation:l,viewpoint:u,displayMat3:M}=s;if(this._viewStateId===e)return;const g=I(l),h=i*a[0],f=i*a[1];this._localOrigin=u.targetGeometry.clone();const{x:m,y:S}=this._localOrigin,w=it(m,s.spatialReference);this._localOrigin.x=w,this._localOrigin.y=S;const b=d*h,A=d*f,r=Q(this._dvsMat3);Z(r,r,M),V(r,r,st(h/2,f/2)),J(r,r,ot(h/b,-f/A,1)),X(r,r,-g),this._viewStateId=e}_updateOverlays(t,s){const{state:e}=t,{rotation:a,spatialReference:i,worldScreenWidth:d,size:l,viewpoint:u}=e,M=this._localOrigin;let g,h=0;const f=rt(i);if(f&&i.isWrappable){const m=l[0],S=l[1],w=I(a),b=Math.abs(Math.cos(w)),A=Math.abs(Math.sin(w)),r=Math.round(m*b+S*A),[C,$]=f.valid,c=et(i),{x:z,y:q}=u.targetGeometry,K=[z,q],E=[0,0];e.toScreen(E,K);const _=[0,0];let P;P=r>d?.5*d:.5*r;const G=Math.floor((z+.5*c)/c),j=C+G*c,H=$+G*c,T=[E[0]+P,0];e.toMap(_,T),_[0]>H&&(h=c),T[0]=E[0]-P,e.toMap(_,T),_[0]<j&&(h=-c),g={worldWidth:c,xBounds:[C,$]}}for(const m of s)m.updateDrawCoords(M,h,i,g)}}export{It as A};
