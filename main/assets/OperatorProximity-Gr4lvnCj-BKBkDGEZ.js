import{G as y,R as p,Z as f,v as d,s as C}from"./Point2D-CaHJVGk1-JqvJXjLr.js";import{Envelope2D as V}from"./Envelope2D-DlBzXkgv-eKRxGysX.js";import{ax as G,aw as b}from"./ProjectionTransformation-DQ4GElxa-CiIu67D1.js";function T(){return N(new d,-1,Number.NaN)}function N(r,e,n){return{m_coordinate:r.clone(),m_vertexIndex:e,m_geometryIndex:0,m_distance:n,m_bRightSide:!1,isEmpty:R}}function R(){return Number.isNaN(this.m_distance)}function P(r,e,n=-1,s=-1){if(r.isEmpty())return 3;const t=r.getGeometryType();if(C(t))return D(r,e,n,s);if(t===f.enumPolygon)return q(r,e,n,s);if(t===f.enumPolyline)return A(r,e,n,s);if(t===f.enumEnvelope){const o=new V;return r.queryEnvelope(o),o.contains(e)?o.containsExclusive(e)?1:2:0}return 3}function D(r,e,n,s){if(n>=0||s>=0)return y("");if(r.isDegenerate(0))return r.getStartXY().equals(e)?2:3;if(!r.isCurve()){const c=d.orientationRobust(e,r.getStartXY(),r.getEndXY());return c<0?1:c>0?0:2}const t=r.getClosestCoordinate(e,!1),o=r.getTangent(t),u=r.getCoord2D(t),a=d.orientationRobust(e,u,u.add(o));return a<0?1:a>0?0:2}function q(r,e,n,s){(n>=0||s>=0)&&y("");const t=new V;r.queryEnvelope(t);const o=b(r,e,0);return o===0?0:o===1?1:2}function A(r,e,n,s){(n<0&&s>=0||n>=0&&s<0)&&y("");const t=r.querySegmentIterator();if(n<0){let u=Number.MAX_VALUE,a=0;for(;t.nextPath();)for(;t.hasNextSegment();){const c=t.nextSegment(),i=c.getClosestCoordinate(e,!1),g=c.getCoord2D(i),x=d.sqrDistance(g,e);x<u?(a=1,n=t.getStartPointIndex(),s=t.getPathIndex(),u=x):x===u&&a++}if(a===0)return 3;if(a===1)return t.resetToVertex(n,s),P(t.nextSegment(),e)}const o=X(e,t,n,s);if(o.i1!==-1&&o.i2===-1)return o.bRight1?1:0;if(o.i1!==-1&&o.i2!==-1){if(o.bRight1===o.bRight2)return o.bRight1?1:0;{t.resetToVertex(o.i1,-1);const u=t.nextSegment().getTangent(1);t.resetToVertex(o.i2,-1);const a=t.nextSegment().getTangent(0);return u.crossProduct(a)>=0?1:0}}return t.resetToVertex(n,s),P(t.nextSegment(),e)}function v(r,e,n){for(r.resetToVertex(e,n);r.hasNextSegment();)if(!r.nextSegment().isDegenerate(0))return r.getStartPointIndex();for(r.resetToVertex(e,n);r.hasPreviousSegment();)if(!r.previousSegment().isDegenerate(0))return r.getStartPointIndex();return-1}function E(r,e){for(r.resetToVertex(e,-1),r.nextSegment();r.hasNextSegment();)if(!r.nextSegment().isDegenerate(0))return r.getStartPointIndex();return-1}function w(r,e){for(r.resetToVertex(e,-1);r.hasPreviousSegment();)if(!r.previousSegment().isDegenerate(0))return r.getStartPointIndex();return-1}function X(r,e,n,s){const t={i1:-1,i2:-1,bRight1:!1,bRight2:!1};if(t.i1=v(e,n,s),t.i1!==-1){e.resetToVertex(t.i1,-1);const o=e.nextSegment(),u=o.getClosestCoordinate(r,!1),a=o.getCoord2D(u),c=d.sqrDistance(a,r);{const i=a.clone();i.subThis(o.getStartXY());const g=r.clone();g.subThis(o.getStartXY()),t.bRight1=i.crossProduct(g)<0}if(t.i2=E(e,t.i1),t.i2!==-1){e.resetToVertex(t.i2,-1);const i=e.nextSegment(),g=i.getClosestCoordinate(r,!1),x=i.getCoord2D(g);if(d.sqrDistance(x,r)>c)t.i2=-1;else{const m=x.clone();m.subThis(i.getStartXY());const l=r.clone();l.subThis(i.getStartXY()),t.bRight2=m.crossProduct(l)<0}}if(t.i2===-1&&(t.i2=w(e,t.i1),t.i2!==-1)){e.resetToVertex(t.i2,-1);const i=e.nextSegment(),g=i.getClosestCoordinate(r,!1),x=i.getCoord2D(g);if(d.sqrDistance(x,r)>c)t.i2=-1;else{const m=x.clone();m.subThis(i.getStartXY());const l=r.clone();l.subThis(i.getStartXY()),t.bRight2=m.crossProduct(l)<0;const h=t.i1;t.i1=t.i2,t.i2=h;const S=t.bRight1;t.bRight1=t.bRight2,t.bRight2=S}}}return t}class M{getOperatorType(){return 10500}accelerateGeometry(e,n,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}getNearestCoordinate(e,n,s,t){if(n.isNAN()&&y("NAN xy coordinates are not allowed"),e.isEmpty())return T();switch(e.getGeometryType()){case f.enumPoint:return this.pointGetNearestVertex(e,n);case f.enumMultiPoint:return this.multiVertexGetNearestVertex(e,n);case f.enumPolyline:case f.enumPolygon:return this.multiPathGetNearestCoordinate(e,n,s,t);default:p("")}}getNearestVertex(e,n){if(n.isNAN()&&y("NAN xy coordinates are not allowed"),e.isEmpty())return T();switch(e.getGeometryType()){case f.enumPoint:return this.pointGetNearestVertex(e,n);case f.enumMultiPoint:case f.enumPolyline:case f.enumPolygon:return this.multiVertexGetNearestVertex(e,n);default:p("")}}getNearestVertices(e,n,s,t){if(t===0&&y(""),n.isNAN()&&y("NAN xy coordinates are not allowed"),e.isEmpty())return[];switch(e.getGeometryType()){case f.enumPoint:return this.pointGetNearestVertices(e,n,s,t);case f.enumMultiPoint:case f.enumPolyline:case f.enumPolygon:return this.multiVertexGetNearestVertices(e,n,s,t);default:p("")}}multiPathGetNearestCoordinate(e,n,s,t){if(e.getGeometryType()===f.enumPolygon&&s){const m=new V;e.queryEnvelope(m);const l=G(null,m,!1);let h;if(h=b(e,n,t?0:l),h!==0){const S=N(n,-1,0);return t&&(S.m_bRightSide=!0),S}}const o=e.querySegmentIterator(),u=new d;let a=-1,c=-1,i=Number.MAX_VALUE,g=0;for(;o.nextPath();)for(;o.hasNextSegment();){const m=o.nextSegment(),l=m.getClosestCoordinate(n,!1),h=m.getCoord2D(l),S=d.sqrDistance(h,n);S<i?(g=1,u.assign(h),a=o.getStartPointIndex(),c=o.getPathIndex(),i=S):S===i&&g++}a===-1&&y("");const x=N(u,a,Math.sqrt(i));if(t)if(e.getGeometryType()!==f.enumPolygon){let m=!1;if(g>1){const l=P(e,n,a,c);m=l!==0&&l!==3}else{o.resetToVertex(a,c);const l=o.nextSegment();m=P(l,n)!==0}x.m_bRightSide=m}else s||b(e,n,0)!==0&&(x.m_bRightSide=!0);return x}pointGetNearestVertex(e,n){const s=e.getXY(),t=d.distance(s,n);return N(s,0,t)}multiVertexGetNearestVertex(e,n){const s=e.getAttributeStreamRef(0),t=e.getPointCount();let o=-1;const u=new d;let a=Number.MAX_VALUE;const c=new d;for(let i=0;i<t;i++){s.queryPoint2D(2*i,c);const g=d.sqrDistance(c,n);g<a&&(u.assign(c),o=i,a=g)}return N(u,o,Math.sqrt(a))}pointGetNearestVertices(e,n,s,t){const o=[];if(t!==0){const u=s*s,a=e.getXY(),c=d.sqrDistance(a,n);c<=u&&o.push(N(a,0,Math.sqrt(c)))}return o}multiVertexGetNearestVertices(e,n,s,t){const o=[];if(t!==0){const u=e.getAttributeStreamRef(0),a=e.getPointCount();o.length=t+1;const c=s*s;for(let i=0;i<a;i++){const g=u.read(2*i),x=u.read(2*i+1),m=n.x-g,l=n.y-x,h=m*m+l*l;h<=c&&o.push(N(d.construct(g,x),i,Math.sqrt(h)))}o.sort((i,g)=>i.m_distance-g.m_distance)}return o.slice(0,t)}}export{M as v};
