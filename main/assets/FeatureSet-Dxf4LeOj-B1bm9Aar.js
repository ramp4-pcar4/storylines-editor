import{by as F,v as h,I as d,ao as T,J as z,U as G,d0 as N,T as v,t as S,Y as P,b5 as j,z as q,bi as x}from"./main-DK5A1thH.js";import{y as J}from"./Field-Cj6Pz3TI-Ca9WushU.js";var R;const w=new F({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryEnvelope:"extent",mesh:"mesh","":null});let c=R=class extends P{constructor(r){super(r),this.displayFieldName=null,this.exceededTransferLimit=!1,this.features=[],this.fields=null,this.geometryType=null,this.hasM=!1,this.hasZ=!1,this.queryGeometry=null,this.spatialReference=null}readFeatures(r,l){return this.readFeaturesWithClass(r,l,T)}writeGeometryType(r,l,s,e){if(r)return void w.write(r,l,s,e);const{features:o}=this;if(o){for(const n of o)if(n?.geometry!=null)return void w.write(n.geometry.type,l,s,e)}}readQueryGeometry(r,l){if(!r)return null;const s=!!r.spatialReference,e=j(r);return e&&!s&&l.spatialReference&&(e.spatialReference=v.fromJSON(l.spatialReference)),e}writeSpatialReference(r,l){if(r)return void(l.spatialReference=r.toJSON());const{features:s}=this;if(s){for(const e of s)if(e&&e.geometry!=null&&e.geometry.spatialReference)return void(l.spatialReference=e.geometry.spatialReference.toJSON())}}clone(){return new R(this.cloneProperties())}cloneProperties(){return q({displayFieldName:this.displayFieldName,exceededTransferLimit:this.exceededTransferLimit,features:this.features,fields:this.fields,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,queryGeometry:this.queryGeometry,spatialReference:this.spatialReference,transform:this.transform})}toJSON(r){const l=this.write();if(l.features&&Array.isArray(r)&&r.length>0)for(let s=0;s<l.features.length;s++){const e=l.features[s];if(e.geometry){const o=r?.[s];e.geometry=o?.toJSON()||e.geometry}}return l}quantize(r){const{scale:[l,s],translate:[e,o]}=r,n=t=>Math.round((t-e)/l),a=t=>Math.round((o-t)/s),f=this.features,m=this._getQuantizationFunction(this.geometryType,n,a);for(let t=0,y=f.length;t<y;t++)m?.(f[t].geometry)||(f.splice(t,1),t--,y--);return this.transform=r,this}unquantize(){const{geometryType:r,features:l,transform:s}=this;if(!s)return this;const{translate:[e,o],scale:[n,a]}=s,f=p=>p*n+e,m=p=>o-p*a;let t=null,y=null;if(this.hasZ&&s?.scale?.[2]!=null){const{translate:[,,p],scale:[,,g]}=s;t=u=>u*g+p}if(this.hasM&&s?.scale?.[3]!=null){const{translate:[,,,p],scale:[,,,g]}=s;y=u=>u==null?u:u*g+p}const i=this._getHydrationFunction(r,f,m,t,y);for(const{geometry:p}of l)p!=null&&i&&i(p);return this.transform=null,this}readFeaturesWithClass(r,l,s){const e=v.fromJSON(l.spatialReference),o=[];for(let n=0;n<r.length;n++){const a=r[n],f=s.fromJSON(a),m=a.geometry?.spatialReference;f.geometry==null||m||(f.geometry.spatialReference=e);const t=a.aggregateGeometries,y=f.aggregateGeometries;if(t&&y!=null)for(const i in y){const p=y[i],g=t[i],u=g?.spatialReference;p==null||u||(p.spatialReference=e)}o.push(f)}return o}_quantizePoints(r,l,s){let e,o;const n=[];for(let a=0,f=r.length;a<f;a++){const m=r[a];if(a>0){const t=l(m[0]),y=s(m[1]);t===e&&y===o||(n.push([t-e,y-o]),e=t,o=y)}else e=l(m[0]),o=s(m[1]),n.push([e,o])}return n.length>0?n:null}_getQuantizationFunction(r,l,s){return r==="point"?e=>(e.x=l(e.x),e.y=s(e.y),e):r==="polyline"||r==="polygon"?e=>{const o=x(e)?e.rings:e.paths,n=[];for(let a=0,f=o.length;a<f;a++){const m=o[a],t=this._quantizePoints(m,l,s);t&&n.push(t)}return n.length>0?(x(e)?e.rings=n:e.paths=n,e):null}:r==="multipoint"?e=>{const o=this._quantizePoints(e.points,l,s);return o&&o.length>0?(e.points=o,e):null}:r==="extent"?e=>e:null}_getHydrationFunction(r,l,s,e,o){return r==="point"?n=>{n.x=l(n.x),n.y=s(n.y),e&&(n.z=e(n.z))}:r==="polyline"||r==="polygon"?n=>{const a=x(n)?n.rings:n.paths;let f,m;for(let t=0,y=a.length;t<y;t++){const i=a[t];for(let p=0,g=i.length;p<g;p++){const u=i[p];p>0?(f+=u[0],m+=u[1]):(f=u[0],m=u[1]),u[0]=l(f),u[1]=s(m)}}if(e&&o)for(let t=0,y=a.length;t<y;t++){const i=a[t];for(let p=0,g=i.length;p<g;p++){const u=i[p];u[2]=e(u[2]),u[3]=o(u[3])}}else if(e)for(let t=0,y=a.length;t<y;t++){const i=a[t];for(let p=0,g=i.length;p<g;p++){const u=i[p];u[2]=e(u[2])}}else if(o)for(let t=0,y=a.length;t<y;t++){const i=a[t];for(let p=0,g=i.length;p<g;p++){const u=i[p];u[2]=o(u[2])}}}:r==="extent"?n=>{n.xmin=l(n.xmin),n.ymin=s(n.ymin),n.xmax=l(n.xmax),n.ymax=s(n.ymax),e&&n.zmax!=null&&n.zmin!=null&&(n.zmax=e(n.zmax),n.zmin=e(n.zmin)),o&&n.mmax!=null&&n.mmin!=null&&(n.mmax=o(n.mmax),n.mmin=o(n.mmin))}:r==="multipoint"?n=>{const a=n.points;let f,m;for(let t=0,y=a.length;t<y;t++){const i=a[t];t>0?(f+=i[0],m+=i[1]):(f=i[0],m=i[1]),i[0]=l(f),i[1]=s(m)}if(e&&o)for(let t=0,y=a.length;t<y;t++){const i=a[t];i[2]=e(i[2]),i[3]=o(i[3])}else if(e)for(let t=0,y=a.length;t<y;t++){const i=a[t];i[2]=e(i[2])}else if(o)for(let t=0,y=a.length;t<y;t++){const i=a[t];i[2]=o(i[2])}}:null}};h([d({type:String,json:{write:!0}})],c.prototype,"displayFieldName",void 0),h([d({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],c.prototype,"exceededTransferLimit",void 0),h([d({type:[T],json:{write:!0}})],c.prototype,"features",void 0),h([z("features")],c.prototype,"readFeatures",null),h([d({type:[J],json:{write:!0}})],c.prototype,"fields",void 0),h([d({type:["point","multipoint","polyline","polygon","extent","mesh"],json:{read:{reader:w.read}}})],c.prototype,"geometryType",void 0),h([G("geometryType")],c.prototype,"writeGeometryType",null),h([d({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],c.prototype,"hasM",void 0),h([d({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],c.prototype,"hasZ",void 0),h([d({types:N,json:{write:!0}})],c.prototype,"queryGeometry",void 0),h([z("queryGeometry")],c.prototype,"readQueryGeometry",null),h([d({type:v,json:{write:!0}})],c.prototype,"spatialReference",void 0),h([G("spatialReference")],c.prototype,"writeSpatialReference",null),h([d({json:{write:!0}})],c.prototype,"transform",void 0),c=R=h([S("esri.rest.support.FeatureSet")],c),c.prototype.toJSON.isDefaultToJSON=!0;const _=c;export{_ as O};
