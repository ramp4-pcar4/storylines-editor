import{b9 as J,aa as K,v as P,I as q,cE as C,t as W,bc as X}from"./main-D7vwjMDX.js";import{F as U,q as D}from"./globalCss-CFN4F315-DRhKtkbs.js";import{o as G,t as b}from"./quantityUtils-RaoZoCNH-1kEzJw6x.js";import{Q as $,Y as ee,Z as m,u,a0 as _,a1 as f,a2 as F,a3 as z,a4 as S,a5 as te,a6 as R,R as Z,a7 as ie,O as se,a8 as M,z as c,H as y,a9 as H,aa as re,ab as L,ac as oe,r as ne,ad as ae,ae as he,af as pe}from"./SketchViewModel-T2dNp9Tt-QF9qwxQk.js";import{M as j,i as B,P as de,l as ce,y as le,A as ge,f as Q}from"./vec2-BnynUbeJ-CKtGJQAy.js";import{m as Y}from"./geodesicLengthMeasurementUtils-X1SKKkBz-wYjyxMM-.js";import{o as I}from"./vec2f64-CEUyUoff-BBc0aQ6D.js";import{O as fe,r as me,A as ue}from"./vec32-BuqRmYBM-ClpcRCNx.js";import"./Queue-B8H6jIv7-oUuyYSR9.js";import"./signal-DxzURL18-CpTU2B0U.js";import"./Version-BTMwSXf1-pRbtbwqb.js";import"./UpdatingHandles-DBzjq66S-BJQBk2Bl.js";import"./projection-m8vi7Cxv-CyI2jDkU.js";import"./GraphicsLayer-GkJJfSu5-BZxIbWSA.js";import"./GraphicsCollection-rAFZo1AJ-xDpoTuU3.js";import"./Layer-B8q-l4yV-BexM1eQl.js";import"./TimeExtent-gZaEUVeW-B8lK7hOc.js";import"./ScaleRangeLayer-DIxukUBC-C-91RrTO.js";import"./layerContainerType-ChWdCT09-G5sdAsSy.js";import"./jsonUtils-DzmXEA9_-DgFzKCQh.js";import"./parser-hXQyB-Qx-DBEB2hCw.js";import"./mat4f32-CiZjBg9k-CUm34GoR.js";import"./mat4-BFStKTjU-WrlKAspo.js";import"./common-CYWrYyJl-E8-sukrT.js";import"./ElevationInfo-DkWlof50-CKiKbD2K.js";import"./lengthUtils-wU9RRIqK-Dn-cOZRL.js";import"./projectVectorToVector-D0K_S4MR-QWHMdts3.js";import"./projectPointToVector-CG1hALQu-DPSkW3cH.js";import"./geodesicUtils-DV-lFWtb-ID_rpKXS.js";import"./Query-CxQYWcUQ-K9TJdLqp.js";import"./Field-Cj6Pz3TI-CQAvI3hR.js";import"./fieldType-VTpxE-EM-B2R_XePP.js";import"./vec42-D8CJyqHG-DnfLTeQH.js";import"./vec4f64-CjUMzAyX-DPYbdAom.js";import"./plane-B_adY3_o-CH2S3dla.js";import"./mat3f64-Dh9_zhFu-BIT-k8Dm.js";import"./mat4f64-BaJwL7tQ-k0uMm8LY.js";import"./quatf64-C16JxGFv-BKWK1F8U.js";import"./sphere-Cj20syUS-D26RDXx7.js";import"./mat3-DOnW3DjW-C3hbW9XY.js";import"./index-CVKk0WAC-ztfa-lGG.js";import"./draw-store-C1_quxsr-B78dyYVI.js";import"./intl-DLmy-Li5-l7mSy0H0.js";import"./jsxFactory-C5LxVioS-x3eAnntn.js";import"./uuid-Dj9mdEVg-BaKSCiyT.js";import"./layerViewUtils-Bk5QNiAa-ulOsFMKn.js";import"./widget-BgluoE6k-Cmg2jAJ2.js";import"./diffUtils-BSe9IE26-SHg3xJhl.js";import"./ViewingMode-CyR_b1T8-_s7_Gbsk.js";import"./meshVertexSpaceUtils-BwEbYR8F-3vQSP7Nh.js";import"./MeshLocalVertexSpace-DFCiKNRA-m_RitSj4.js";import"./hydratedFeatures-BDT5zTGB-D1Msl1E0.js";import"./Scheduler-Br-2v2ys-9ISnkO6X.js";import"./geometryEngineBase-DueYg7ux-CCeespPx.js";import"./_commonjsHelpers-BITg13Vk-KnjfkSck.js";import"./hydrated-Bae3cp-4-BTtKkc0m.js";import"./mat2d-BQA-1WB--Pnyy0dhf.js";import"./quat-D8L_R4I0-BhK2bIY8.js";import"./drapedUtils-7RfmdK5D-BQR7bVKQ.js";import"./utils-C0LvbFCo-RMQaTNpt.js";import"./substitute-TfjvVaWd-BEVJTbkP.js";class k{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=y.shortLineThreshold*y.shortLineThreshold}snap(e,t){return t.vertexHandle!=null?t.vertexHandle.type!=="vertex"?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(f(e.leftVertex.pos,this.view,t),f(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:i}){return this.squaredShortLineThreshold===0||S(m(t,i,u,this.view),m(e,i,u,this.view))>this.squaredShortLineThreshold}isVertical(e,t,{spatialReference:i}){const s=X(i);return Q(c(e),c(t))*s<y.verticalLineThresholdMeters}squaredProximityThreshold(e){return e==="touch"?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}}class xe extends k{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,o=[];if(s<1)return o;const{spatialReference:n}=t,h=m(e,n,u,this.view),{view:a}=this,p=i.edges[s-1];let d=p;do{if(this.edgeExceedsShortLineThreshold(d,t)){const l=_(d,a,t);this._processCandidateProposal(l.left,l.right,e,h,t,o)}d=d.leftVertex.leftEdge}while(d&&d!==p);return o}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,o=s.component;if(o.edges.length<2)return i;const{view:n}=this,{spatialReference:h}=t,a=m(e,h,u,n),p=s.leftEdge,d=s.rightEdge;p&&d&&this.edgeExceedsShortLineThreshold(p,t)&&this.edgeExceedsShortLineThreshold(d,t)&&this._processCandidateProposal(f(p.leftVertex.pos,n,t),f(d.rightVertex.pos,n,t),e,a,t,i);const l=o.edges[0];let g=l;do{if(g!==s.leftEdge&&g!==s.rightEdge&&this.edgeExceedsShortLineThreshold(g,t)){const v=_(g,n,t);this._processCandidateProposal(v.left,v.right,e,a,t,i)}g=g.rightVertex.rightEdge}while(g&&g!==l);return i}_processCandidateProposal(e,t,i,s,o,n){const{spatialReference:h,pointer:a}=o,p=C();ve(p,e,t,i,o);const d=F(z(p));S(s,m(d,h,u,this.view))<this.squaredProximityThreshold(a)&&n.push(new te({lineStart:e,lineEnd:t,targetPoint:d,isDraped:o.elevationInfo?.mode==="on-the-ground"}))}}function ve(r,e,t,i,s){Ee(r,e,t,i,s)||we(r,i,e,t)}function Ee(r,e,t,i,{spatialReference:s}){const o=R(e,t,s,s);if(o==null)return!1;const n=R(t,i,s,s);if(n==null)return!1;const h=Y(t,i,s);if(h==null)return!1;const a=Math.abs(U.shortestSignedDiff(o,n))>Math.PI/2?D.normalize(o+Math.PI):o;return Z(r,t,s,G(h,"meters"),b(a,"radians","geographic"),"geodesic"),r[2]=i[2],!0}function we(r,e,t,i){ie(e,{start:t,end:i,type:se.LINE},r),r[2]=e[2]}let Ve=class extends k{snapNewVertex(r,e){const t=e.editGeometryOperations.data.components[0],i=t.edges.length,s=t.vertices.length,o=[];if(i<2)return o;const{view:n}=this,h=m(r,e.spatialReference,u,n),a=f(t.vertices[s-1].pos,n,e),p=f(t.vertices[0].pos,n,e),d=t.edges[i-1];let l=d;do{if(this.edgeExceedsShortLineThreshold(l,e)){const g=_(l,n,e);this._checkEdgeForParallelLines(g,a,r,h,e,o),this._checkEdgeForParallelLines(g,p,r,h,e,o)}l=l.leftVertex.leftEdge}while(l&&l!==d);return o}snapExistingVertex(r,e){const t=[],i=e.vertexHandle,s=i.component;if(s.edges.length<3)return t;const{view:o}=this,n=m(r,e.spatialReference,u,o),h=i.leftEdge,a=i.rightEdge,p=s.vertices[0],d=f(p.pos,o,e),l=s.vertices.length,g=s.vertices[l-1],v=f(g.pos,o,e),w=s.edges[0];let x=w;do{if(x!==h&&x!==a&&this.edgeExceedsShortLineThreshold(x,e)){const T=_(x,o,e);h&&this._checkEdgeForParallelLines(T,f(h.leftVertex.pos,o,e),r,n,e,t),a&&this._checkEdgeForParallelLines(T,f(a.rightVertex.pos,o,e),r,n,e,t),i===p?this._checkEdgeForParallelLines(T,v,r,n,e,t):i===g&&this._checkEdgeForParallelLines(T,d,r,n,e,t)}x=x.rightVertex.rightEdge}while(x&&x!==w);return t}_checkEdgeForParallelLines(r,e,t,i,s,o){const n=r.left,h=r.right;if(M(E,c(e),c(n),c(h)),j(E,c(e))<y.parallelLineThreshold)return;M(E,c(t),c(n),c(h),c(e));const{spatialReference:a,pointer:p}=s,d=F(H(E[0],E[1],t[2]));if(S(i,m(d,a,u,this.view))<this.squaredProximityThreshold(p)){if(this.isVertical(d,e,s)||this.isVertical(n,h,s)||ye(r,o))return;o.push(new re({referenceLine:r,lineStart:e,targetPoint:d,isDraped:s.elevationInfo?.mode==="on-the-ground"}))}}};function ye(r,e){const t=r.left,i=r.right;for(const s of e)if(M(E,c(i),c(s.constraint.start),c(s.constraint.end),c(t)),j(E,c(i))<y.parallelLineThreshold)return s.addReferenceLine(r),!0;return!1}const E=I();class Se extends k{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=[];if(i.vertices.length<2)return s;const{view:o}=this,n=m(e,t.spatialReference,u,o),h=i.vertices.at(-1);this._checkForSnappingCandidate(L.LastVertex,s,h.leftEdge,h,h.leftEdge.leftVertex,e,n,t);const a=i.vertices[0];return this._checkForSnappingCandidate(L.FirstVertex,s,a.rightEdge,a,a.rightEdge.rightVertex,e,n,t),s}snapExistingVertex(e,t){const i=[],s=t.vertexHandle;if(s.component.vertices.length<3)return i;const{view:o}=this,n=m(e,t.spatialReference,u,o),h=s.leftEdge,a=s.rightEdge;if(h?.leftVertex.leftEdge){const p=h.leftVertex.leftEdge;this._checkForSnappingCandidate(L.ExistingEdge,i,p,p.rightVertex,p.leftVertex,e,n,t)}if(a?.rightVertex.rightEdge){const p=a.rightVertex.rightEdge;this._checkForSnappingCandidate(L.ExistingEdge,i,p,p.leftVertex,p.rightVertex,e,n,t)}return i}_checkForSnappingCandidate(e,t,i,s,o,n,h,a){if(!this.edgeExceedsShortLineThreshold(i,a))return;const p=this.view,d=f(s.pos,p,a),l=f(o.pos,p,a);Te(N,l,d,n,a),this._checkForSnappingCandidateAlongProjectedRay(e,t,l,d,N,n,h,a)}_checkForSnappingCandidateAlongProjectedRay(e,t,i,s,o,n,h,a){const{spatialReference:p,pointer:d}=a,l=B(O,c(n),c(s)),g=de(o,l)/ce(o),v=le(O,c(s),o,g),w=F(H(v[0],v[1],n[2]));if(S(h,m(w,p,u,this.view))>this.squaredProximityThreshold(d)||this.isVertical(w,s,a)||this.isVertical(s,i,a))return;const x=fe(C(),s,o,Math.sign(g));t.push(new oe({targetPoint:w,constraint:new ne(s,z(x)),previousVertex:i,otherVertex:s,otherVertexType:ae.CENTER,selfSnappingType:e,isDraped:a.elevationInfo?.mode==="on-the-ground"}))}}function Te(r,e,t,i,s){Pe(r,e,t,i,s)||Le(r,e,t)}function Pe(r,e,t,i,{spatialReference:s}){const o=R(e,t,s,s);if(o==null)return!1;const n=R(t,i,s,s);if(n==null)return!1;const h=Math.sign(D.shortestSignedDiff(o,n))*Math.PI*.5,a=b(o+h,"radians","geographic"),p=C(),d=Y(t,i,s);return d!=null&&(Z(p,t,s,G(d,"meters"),a,"geodesic"),me(r,p,t),!0)}function Le(r,e,t){const i=B(O,c(t),c(e));ue(r,i[1],-i[0],0)}const O=I(),N=C();let _e=class extends k{snapNewVertex(r,e){const t=e.editGeometryOperations.data.components[0],i=[],s=t.vertices.length;if(e.editGeometryOperations.data.type!=="polygon"||s<2)return i;const{view:o}=this,n=t.vertices[0],h=t.vertices[s-1],a=f(n.pos,o,e),p=f(h.pos,o,e);return this._processCandidateProposal(a,p,r,e,i),i}snapExistingVertex(r,e){const t=[],i=e.vertexHandle,s=i.component;if(s.edges.length<2||e.editGeometryOperations.data.type==="polyline"&&(i.index===0||i.index===s.vertices.length-1))return t;const{view:o}=this,n=f(i.leftEdge.leftVertex.pos,o,e),h=f(i.rightEdge.rightVertex.pos,o,e);return this._processCandidateProposal(n,h,r,e,t),t}_processCandidateProposal(r,e,t,i,s){if(!this.exceedsShortLineThreshold(r,e,i))return;const o=ge(A,c(r),c(e),.5),n=.5*Q(c(r),c(e)),h=he(A,c(t),o,n),a=F(H(h[0],h[1],t[2])),{spatialReference:p,pointer:d}=i,l=m(t,p,u,this.view);if(S(l,m(a,p,u,this.view))<this.squaredProximityThreshold(d)){if(this.isVertical(r,a,i)||this.isVertical(a,e,i))return;s.push(new pe({targetPoint:a,point1:r,point2:e,isDraped:i.elevationInfo?.mode==="on-the-ground"}))}}};const A=I();let V=class extends J{constructor(r){super(r),this.updating=!1,this._snappers=new K,this._domain=$.SELF}initialize(){this._snappers.push(new Ve(this.view,this.options),new xe(this.view,this.options),new Se(this.view,this.options),new _e(this.view,this.options))}set options(r){this._set("options",r);for(const e of this._snappers)e.options=r}async fetchCandidates(r,e,t){if(!(e&this._domain&&this.options.effectiveSelfEnabled))return[];const i=[];for(const s of this._snappers.items)for(const o of s.snap(r,t))i.push(o);return ee(r,i),i}};P([q({readOnly:!0})],V.prototype,"updating",void 0),P([q({constructOnly:!0})],V.prototype,"view",void 0),P([q()],V.prototype,"options",null),V=P([W("esri.views.interactive.snapping.SelfSnappingEngine")],V);export{V as SelfSnappingEngine};
