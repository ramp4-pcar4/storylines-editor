import{E as X}from"./MapView-BcnxJC0k-Bw7n4yfl.js";import{v as g,a8 as Vt,j2 as Xt,i as Zt,c as Yt}from"./main-D7vwjMDX.js";import{H as te,O as ee}from"./Texture-DXSFJsEu-02_Cw8VC.js";import"./enums-DBi1-Mm2-CUS1pvQe.js";import"./FramebufferObject-DQw0QX3p-CB4beI4H.js";import{I as ne}from"./ProgramTemplate-CBS0ERm4-ESojE4o_.js";import{w as re}from"./ShaderBuilder-BkQM64Qp-Bst--WWS.js";let Oe=class{constructor(){this.drawPhase=X.MAP|X.HITTEST|X.HIGHLIGHT|X.DEBUG}startup(){}shutdown(e){}};function ie(e){return e.split(" ").map((t,n)=>n>0?t.charAt(0).toUpperCase()+t.slice(1):t).join("")}function se(e,t){const n=[];for(n.push(t);n.length;){const r=n.pop();if(typeof r=="object"&&!e.has(r.uid)){e.add(r.uid);for(const i of r.children)n.push(i)}}}let M=class dt{constructor(){this.uid=dt.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(t){return t=ie(t),this._debugName=t,this.isImplicit&&this.children[0]instanceof dt&&this.children[0].setDebugName(t),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(t){t._debugName=this._debugName,t._isMutable=this._isMutable,t.isImplicit=this.isImplicit,t.uid=this.uid}};function o(e){return typeof e=="object"?e.clone():e}M.NodeCount=0;let y=class extends M{constructor(){super(...arguments),this.shaderType="primitive-node"}},oe=class zt extends M{constructor(t){super(),this.child=t,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const t=new zt(o(this.child));return this.cloneInto(t),t}},ce=class Dt extends M{constructor(t,n,r){super(),this.property=t,this.target=n,this.returnType=r,this.shaderType="property-access-node"}get children(){const t=[this.target];return typeof this.property!="string"&&t.push(this.property),t}clone(){const t=new Dt(this.property,o(this.target),this.returnType);return this.cloneInto(t),t}};class Mt extends M{constructor(t,n,r,i){super(),this.x=t,this.y=n,this.target=r,this.returnType=i,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const t=new Mt(this.x,this.y,o(this.target),this.returnType);return this.cloneInto(t),t}}class St extends M{constructor(t,n,r){super(),this.condition=t,this.ifTrue=n,this.ifFalse=r,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const t=o(this.ifTrue),n=this.ifFalse?o(this.ifFalse):null,r=new St(this.condition,t,n);return this.cloneInto(r),r}}let ae=class Lt extends M{constructor(t,n,r,i){super(),this.captureList=t,this.returnType=n,this.generator=i,this.shaderType="block-node",r&&(this.subgraph=new oe(r))}get children(){return Object.keys(this.captureList).map(t=>this.captureList[t]).concat(this.subgraph??[])}clone(){const t={};for(const r in this.captureList)t[r]=o(this.captureList[r]);const n=new Lt(t,this.returnType,this.subgraph?o(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(n),n}},k=class Gt extends M{constructor(t,n,r,i,s,c=!1){super(),this.token=t,this._children=n,this.isInfix=r,this.isPropertyAccess=i,this.returnType=s,this.isTernary=c,this.shaderType="function-node"}get children(){return this._children}clone(){const t=new Gt(this.token,this._children.map(o),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(t),t}};var L,pt,lt,ft,yt,mt,gt,bt,wt,vt,xt,_t,It,$t;function ue(e){switch(e.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return _;case"float":case"vec2":case"vec3":case"vec4":return p;case"int":case"ivec2":case"ivec3":case"ivec4":return f;case"uint":case"uvec2":case"uvec3":case"uvec4":return H;default:throw new Error("Unable to handle type")}}function he(e){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const n of t)if(n.includes(e))return n.map(r=>le[r]);throw new Error("Unable to find type family")}function Ht(e){return new Proxy(e,{get(t,n){if(n==="constructor")return new Proxy(t.constructor,{construct:(r,i,s)=>Ht(new r(...i))});if(n in t)return t[n];if(typeof n=="string"){const r=he(e.type);return x(e,n,r[n.length-1])}}})}function $(e){return new Proxy(e,{construct:(t,n,r)=>Ht(new t(...n))})}function de(e){return new Proxy(e,{get(t,n){if(n in t)return t[n];if(typeof n=="string"){const r=parseInt(n,10);if(!isNaN(r))return x(e,`[${r}]`,e.elementType.constructor)}}})}function pe(e){return new Proxy(e,{construct:(t,n,r)=>de(new t(...n))})}let Tt=class extends Error{},Z=L=class extends y{constructor(e,t){super(),this.elementType=e,this.size=t,this.children=[],this.type="array"}clone(){const e=new L(this.elementType,this.size);return super.cloneInto(e),e}get(e,t){const n=new f(e),r=t!=null?new f(t):null;return r!=null?ht(this,n,r,ue(this.elementType.constructor)):x(this,n,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(e,t,n){return me(this,e,t,n)}glslFindIndex(e,t,n){return ge(this,e,t,n)}static ofType(e,t){const n={construct:(r,i)=>new L(new e,t)};return new Proxy(L,n)}};Z.type="array",Z=L=g([pe],Z);class ut extends y{constructor(t,n,r,i=!1){super(),this.elementType=t,this.xSize=n,this.ySize=r,this.isRowMajor=i,this.children=[],this.type="array-2d"}clone(){const t=new ut(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(t),t}get size(){return this.xSize*this.ySize}get(t,n){return this.isRowMajor?this._getRowMajor(t,n):this._getColumnMajor(t,n)}_getColumnMajor(t,n){const r=new f(t);return x(this,new f(n).add(r.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(t,n){const r=new f(t),i=new f(n);return x(this,r.add(i.multiply(this.ySize)),this.elementType.constructor)}static ofType(t,n,r,i=!1){return new Proxy(Z,{construct:(s,c)=>new ut(new t,n,r,i)})}}ut.type="array-2d";class kt extends y{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}clone(){const t=new kt;return t.children=this.children.map(o),super.cloneInto(t),t}}kt.type="sampler2D";let p=class K extends y{constructor(t){super(),this.type="float",this.children=[t]}clone(){const t=new K(o(this.children[0]));return super.cloneInto(t),t}multiply(t){return N(this,typeof t=="number"?m(t,K):t)}divide(t){return R(this,typeof t=="number"?m(t,K):t)}add(t){return B(this,typeof t=="number"?m(t,K):t)}subtract(t){return J(this,typeof t=="number"?m(t,K):t)}};p.type="float";let U=pt=class extends y{constructor(e,t){super(),this.type="vec2",this.children=[e,t].filter(n=>n!=null)}clone(){const e=new pt(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}get 0(){return x(this,"[0]",p)}get 1(){return x(this,"[1]",p)}get 2(){throw new Tt}get 3(){throw new Tt}multiply(e){return N(this,typeof e=="number"?m(e,p):e)}divide(e){return R(this,typeof e=="number"?m(e,p):e)}add(e){return B(this,typeof e=="number"?m(e,p):e)}subtract(e){return J(this,typeof e=="number"?m(e,p):e)}};U.type="vec2",U=pt=g([$],U);let G=lt=class extends y{constructor(e,t,n){super(),this.type="vec3",this.children=[e,t,n].filter(r=>r!=null)}get 0(){return x(this,"[0]",p)}get 1(){return x(this,"[1]",p)}get 2(){return x(this,"[2]",p)}get 3(){throw new Tt}clone(){const e=new lt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}multiply(e){return N(this,typeof e=="number"?m(e,p):e)}divide(e){return R(this,typeof e=="number"?m(e,p):e)}add(e){return B(this,typeof e=="number"?m(e,p):e)}subtract(e){return J(this,typeof e=="number"?m(e,p):e)}};G.type="vec3",G=lt=g([$],G);let C=ft=class extends y{constructor(e,t,n,r){super(),this.type="vec4",this.children=[e,t,n,r].filter(i=>i!=null)}clone(){const e=new ft(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}get 0(){return x(this,"[0]",p)}get 1(){return x(this,"[1]",p)}get 2(){return x(this,"[2]",p)}get 3(){return x(this,"[3]",p)}multiply(e){return N(this,typeof e=="number"?m(e,p):e)}divide(e){return R(this,typeof e=="number"?m(e,p):e)}add(e){return B(this,typeof e=="number"?m(e,p):e)}subtract(e){return J(this,typeof e=="number"?m(e,p):e)}};C.type="vec4",C=ft=g([$],C);let H=yt=class extends y{constructor(e){super(),this.type="uint",this.children=[e]}clone(){const e=new yt(o(this.children[0]));return super.cloneInto(e),e}};H.type="uint",H=yt=g([$],H);let Y=mt=class extends y{constructor(e,t){super(),this.type="uvec2",this.children=[e,t].filter(n=>n!=null)}clone(){const e=new mt(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}};Y.type="uvec2",Y=mt=g([$],Y);let tt=gt=class extends y{constructor(e,t,n){super(),this.type="uvec3",this.children=[e,t,n].filter(r=>r!=null)}clone(){const e=new gt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}};tt.type="uvec3",tt=gt=g([$],tt);let et=bt=class extends y{constructor(e,t,n,r){super(),this.type="uvec4",this.children=[e,t,n,r].filter(i=>i!=null)}clone(){const e=new bt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}};et.type="uvec4",et=bt=g([$],et);class _ extends y{constructor(t){super(),this.type="bool",this.children=[t]}and(t){return xe(this,t)}or(t){return we(this,t)}clone(){const t=new _(o(this.children[0]));return super.cloneInto(t),t}}_.type="bool";let nt=wt=class extends y{constructor(e,t){super(),this.type="bvec2",this.children=[e,t].filter(n=>n!=null)}all(){return Et(this)}any(){return Ft(this)}clone(){const e=new wt(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}};nt.type="bvec2",nt=wt=g([$],nt);let rt=vt=class extends y{constructor(e,t,n){super(),this.type="bvec3",this.children=[e,t,n].filter(r=>r!=null)}all(){return Et(this)}any(){return Ft(this)}clone(){const e=new vt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}};function m(e,t){return typeof e=="number"?new t(e):e}rt.type="bvec3",rt=vt=g([$],rt);let it=xt=class extends y{constructor(e,t,n,r){super(),this.type="bvec4",this.children=[e,t,n,r].filter(i=>i!=null)}all(){return Et(this)}any(){return Ft(this)}clone(){const e=new xt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}};it.type="bvec4",it=xt=g([$],it);class f extends y{constructor(t){super(),this.type="int",this.children=[t]}multiply(t){return N(this,m(t,f))}add(t){return B(this,m(t,f))}subtract(t){return J(this,m(t,f))}divide(t){return R(this,m(t,f))}clone(){const t=new f(o(this.children[0]));return super.cloneInto(t),t}}f.type="int";let st=_t=class extends y{constructor(e,t){super(),this.type="ivec2",this.children=[e,t].filter(n=>n!=null)}clone(){const e=new _t(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}};st.type="ivec2",st=_t=g([$],st);let ot=It=class extends y{constructor(e,t,n){super(),this.type="ivec3",this.children=[e,t,n].filter(r=>r!=null)}clone(){const e=new It(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}};ot.type="ivec3",ot=It=g([$],ot);let ct=$t=class extends y{constructor(e,t,n,r){super(),this.type="ivec4",this.children=[e,t,n,r].filter(i=>i!=null)}clone(){const e=new $t(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}};ct.type="ivec4",ct=$t=g([$],ct);class Ct extends y{constructor(t,n,r,i){super(),this.type="mat2",this.children=[t,n,r,i]}clone(){const t=new Ct(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get(t,n){return ht(this,new f(t),new f(n),p)}multiply(t){return N(this,t)}}Ct.type="mat2";class O extends y{static identity(){return new O(1,0,0,0,1,0,0,0,1)}static fromRotation(t){const n=$e(t),r=Ie(t);return new O(r,n,0,ye(n),r,0,0,0,1)}constructor(t,n,r,i,s,c,u,a,h){super(),this.type="mat3",this.children=[t,n,r,i,s,c,u,a,h]}add(t){return B(this,t)}multiply(t){return N(this,t)}get(t,n){return ht(this,new f(t),new f(n),p)}clone(){const t=new O(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]));return super.cloneInto(t),t}}O.type="mat3";class q extends y{static identity(){return new q(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(t,n,r,i,s,c,u,a,h,d,l,v,P,S,Q,W){super(),this.type="mat4",this.children=[t,n,r,i,s,c,u,a,h,d,l,v,P,S,Q,W]}static fromColumns(t,n,r,i){return new q(t.x,t.y,t.z,t.w,n.x,n.y,n.z,n.w,r.x,r.y,r.z,r.w,i.x,i.y,i.z,i.w)}multiply(t){return N(this,t)}get(t,n){return ht(this,new f(t),new f(n),p)}clone(){const t=new q(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]),o(this.children[9]),o(this.children[10]),o(this.children[11]),o(this.children[12]),o(this.children[13]),o(this.children[14]),o(this.children[15]));return super.cloneInto(t),t}}q.type="mat4";const le={float:p,vec2:U,vec3:G,vec4:C,int:f,ivec2:st,ivec3:ot,ivec4:ct,uint:H,uvec2:Y,uvec3:tt,uvec4:et,bool:_,bvec2:nt,bvec3:rt,bvec4:it},Ae=(...e)=>new f(...e),fe=(...e)=>new p(...e),Be=(...e)=>new U(...e),je=(...e)=>new G(...e),Ve=(...e)=>new C(...e),ze=(...e)=>new O(...e);function x(e,t,n){const r=new n(new ce(t,e,n));return r.isImplicit=!0,r}function ht(e,t,n,r){const i=new r(new Mt(t,n,e,r));return i.isImplicit=!0,i}function I(e,t,n,r=null){if(r){const s=new r,c=new r(new k(e,[t,n],!0,!1,s));return c.isImplicit=!0,c}if(t.type==="float"||t.type==="int"){const s=new n.constructor(new k(e,[t,n],!0,!1,n.constructor));return s.isImplicit=!0,s}if((t.type==="mat2"||t.type==="mat3"||t.type==="mat4")&&n.type!=="float"){const s=new n.constructor(new k(e,[t,n],!0,!1,n.constructor));return s.isImplicit=!0,s}const i=new t.constructor(new k(e,[t,n],!0,!1,t.constructor));return i.isImplicit=!0,i}function w(e,t,n=t.constructor){const r=new n(new k(e,[t],!1,!1,n));return r.isImplicit=!0,r}function T(e,t,n,r=t.constructor){const i=new r(new k(e,[t,n],!1,!1,r));return i.isImplicit=!0,i}function Pt(e,t,n,r,i=t.constructor){const s=new i(new k(e,[t,n,r],!1,!1,i));return s.isImplicit=!0,s}function ye(e){return N(e,fe(-1))}function qt(e,t,n,r){return new t(new ae(e,t,n,r))}function me(e,t,n=0,r=e.size){const i=new f(n).setMutable().setDebugName("FindIndexIterator"),s=t(e.get(i)).setDebugName("FindIndexPredicate");return qt({iter:i},f,s,({out:c,iter:u,subgraph:a})=>`
${c} = -1;

for (; ${u} < ${r}; ${u}++) {

${a.body}

  if (${a.varName}) {
    ${c} = ${u};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function ge(e,t,n=0,r=e.size){return qt({array:e},f,null,({out:i,array:s})=>`
${i} = -1;
for (int i = ${n}; i < ${r}; i++) {
  bool condition;
  ${t({array:s,i:"i",out:"condition"})}
  if (condition) {
    ${i} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function be(e,t,n){const r=typeof t=="function"?t():t,i=typeof n=="function"?n():n,s=new r.constructor(new St(e,r,i));return s.isImplicit=!0,s}function De(...e){const t=e.map(([u,a])=>typeof a=="function"?[u,a()]:[u,a]),n=t[0][1].constructor,r=t.findIndex(u=>u[0]===!0);if(r===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const i=t.slice(0,r),s=t[r][1],c=new n(i.reduceRight((u,a)=>be(a[0],a[1],u),s));return c.isImplicit=!0,c}function N(e,t){return I("*",e,t)}function R(e,t){return I("/",e,t)}function B(e,t){return I("+",e,t)}function J(e,t){return I("-",e,t)}function Le(e,t){return I("%",e,t)}function Ge(e,t){return I(">>",e,t)}function He(e,t){return I("&",e,t)}function qe(e,t){return I("==",e,t,_)}function Re(e,t){return I("<",e,t,_)}function Je(e,t){return I("<=",e,t,_)}function Qe(e,t){return I(">",e,t,_)}function We(e,t){return I(">=",e,t,_)}function we(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,n)=>ve(t,n),e[0])}function ve(e,t){return I("||",e,t,_)}function xe(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,n)=>_e(t,n),e[0])}function _e(e,t){return I("&&",e,t,_)}function Xe(e){return w("abs",e)}function Et(e){return w("all",e,_)}function Ft(e){return w("any",e,_)}function Ze(e,t){return t==null?w("atan",e):T("atan",e,t,e.constructor)}function Ye(e){return w("ceil",e)}function tn(e,t,n){return Pt("clamp",e,t,n,e.constructor)}function Ie(e){return w("cos",e)}function en(e,t){return T("distance",e,t,p)}function nn(e,t){return T("dot",e,t,p)}function rn(e){return w("floor",e)}function sn(e){return w("fract",e)}function on(e){return w("length",e,p)}function cn(e,t){return T("max",e,t)}function an(e,t){return T("min",e,t)}function un(e,t,n){return Pt("mix",e,t,n)}function hn(e,t){return T("mod",e,t)}function dn(e){return w("normalize",e)}function pn(e){return e.type==="bool"?w("!",e):w("not",e)}function ln(e,t){return T("pow",e,t)}function fn(e){return w("round",e)}function $e(e){return w("sin",e)}function yn(e,t,n){return Pt("smoothstep",e,t,n)}function mn(e){return w("sqrt",e)}function gn(e,t){return T("step",e,t,t.constructor)}function bn(e,t){return T("texture",e,t,C)}const V=5;function b(e,t,n){const r=t.split(`
`);for(const i of r)if(i.trim().length){{let s="";n!=null&&(s+=`/*id:${n??"000"}*/   `),e.body+=s.padEnd(14)}e.body+=" ".repeat(e.indent)+i+`
`}}class At{write(t){for(const n of t.rootOutputNodes())t.shouldPruneOutputNode(n)||(n.variableName=this._write(t,n.node));return t}_createVarName(t,n){let r="";return typeof n!="boolean"&&typeof n!="number"&&n.debugInfo.name&&(r=`${n.debugInfo.name}_`),`${r}v${t.varCount++}`}_write(t,n,r=!1){if(typeof n=="number"||typeof n=="boolean")return n.toString();let i=t.getEmit(n);if(i)return i;switch(n.shaderType){case"scope-node":i=this._writeScopeNode(t,n);break;case"primitive-node":i=this._writePrimitiveNode(t,n,r);break;case"function-node":i=this._writeFunctionNode(t,n);break;case"property-access-node":i=this._writePropertyAccessNode(t,n);break;case"property-access-2d-node":i=this._writePropertyAccess2DNode(t,n);break;case"text-node":i=n.text;break;case"block-node":i=this._writeBlockNode(t,n);break;case"condition-node":i=this._writeConditionNode(t,n)}return t.setEmit(n,i),i}_writeScopeNode(t,n){const r=new n.child.constructor;r.setDebugName(n.debugInfo.name);const i=this._write(t,r,!0);return b(t,`{ /*ScopeStart: ${n.uid} ${n.debugInfo.name}*/`),t.indent+=2,b(t,`${i} = ${this._write(t,n.child)};`),t.indent-=2,b(t,`} /*ScopeEnd: ${n.uid} ${n.debugInfo.name}*/`),i}_writeConditionNode(t,n){const r=new n.ifTrue.constructor,i=this._write(t,r,!0);b(t,`if (${this._write(t,n.condition)}) {`),t.indent+=2;const s=t.createSubgraphContext(),c=this._write(s,n.ifTrue);if(t.body+=s.body,c&&b(t,`${i} = ${c};`),t.indent-=2,b(t,"}"),n.ifFalse){b(t,"else {"),t.indent+=2;const u=t.createSubgraphContext(),a=this._write(u,n.ifFalse);t.body+=u.body,a&&b(t,`${i} = ${a};`),t.indent-=2,b(t,"}")}return i}_writeBlockNode(t,n){const{captureList:r,generator:i,returnType:s}=n,c={};for(const d in r){if(!r[d])continue;const l=this._write(t,r[d]);c[d]=l}const u=new s,a=this._write(t,u,!0);if(c.out=a,n.subgraph){const d=t.createSubgraphContext(),l=this._write(d,n.subgraph.child),v=d.body;c.subgraph={varName:l,body:v}}const h=i(c);return b(t,`{
`),t.indent+=2,b(t,h),t.indent-=2,b(t,`}
`),a}_writePropertyAccessNode(t,n){const r=this._write(t,n.target);return typeof n.property=="string"&&n.property.includes("[")?`${r}${n.property}`:typeof n.property!="string"?`${r}[${this._write(t,n.property)}]`:`${r}.${n.property}`}_writePropertyAccess2DNode(t,n){return`${this._write(t,n.target)}[${this._write(t,n.x)}][${this._write(t,n.y)}]`}_writeFunctionNode(t,n){const r=n.returnType.type;if(n.isInfix){const[c,u]=n.children.map(h=>this._write(t,h)),a=this._createVarName(t,n);return b(t,`${r.padEnd(V)} ${a} = ${c} ${n.token} ${u};`,n.uid),a}const i=n.children.map(c=>this._write(t,c)).join(", "),s=this._createVarName(t,n);return b(t,`${r.padEnd(V)} ${s} = ${n.token}(${i});`,n.uid),s}_writePrimitiveNode(t,n,r=!1){const i=t.getInput(n);if(i)return i.isUsed=!0,i.variableName;const s=n.children.length===1&&n.children[0]?.type===n.type;if(!n.isMutable&&(n.isImplicit||s))return this._write(t,n.children[0]);const c=this._createVarName(t,n);if(r)return b(t,`${n.type.padEnd(V)} ${c};`,n.uid),c;const u=!n.debugInfo.name&&!n.isMutable;if(u&&n.type==="float"&&typeof n.children[0]=="number")return Number.isInteger(n.children[0])?n.children[0].toFixed(1):n.children[0].toString();if(u&&n.type==="int"&&typeof n.children[0]=="number"&&Number.isInteger(n.children[0]))return n.children[0].toString();const a=n.children.map(h=>this._write(t,h)).join(", ");return n.type==="array"?(b(t,`${n.type.padEnd(V)} ${c} = [${a}];`,n.uid),c):u?`${n.type}(${a})`:(b(t,`${n.type.padEnd(V)} ${c} = ${n.type}(${a});`,n.uid),c)}}let E=class Rt{constructor(t,n,r){this.variableName=t,this.variableInputType=n,this.node=r,this.type="shader-input",this.isUsed=!1}clone(){return new Rt(this.variableName,this.variableInputType,o(this.node))}},F=class Jt{constructor(t,n,r){this.outVariableName=t,this.outVariableType=n,this.node=r,this.type="shader-output"}clone(){const t=new Jt(this.outVariableName,this.outVariableType,o(this.node));return t.variableName=this.variableName,t}};class A{static createVertex(t,n,r,i,s,c){const u=[];for(const h in t){const d=t[h],l=r.get(h);l?u.push(new E(l,"builtin",d)):u.push(new E("a_"+h,"in",d))}for(const h of i){const d=h.uniformHydrated;u.push(new E(h.uniformName,"uniform",d))}const a=[];for(const h in n){const d=n[h];h==="glPosition"?a.push(new F("gl_Position","builtin",d)):h==="glPointSize"?a.push(new F("gl_PointSize","builtin",d)):a.push(new F("v_"+h,"out",d))}return new A(u,a,s,c)}static createFragment(t,n,r,i,s,c){const u=[],a=Array.from(s.rootOutputNodes());for(const d in t){const l=t[d],v=r.get(d);if(v){u.push(new E(v,"builtin",l));continue}const P=a.find(S=>S.node===l);P&&u.push(new E(P.outVariableName,"in",l))}for(const d of i){const l=d.uniformHydrated;u.push(new E(d.uniformName,"uniform",l))}const h=[];for(const d in n){const l=n[d],v=r.get(d);d==="discard"?h.push(new F(null,"discard",l)):v?h.push(new F(v,"builtin",l)):h.push(new F(d,"out",l))}return new A(u,h,c)}constructor(t,n,r,i){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const s of t)this._inputShaderTypesByNodeUid.set(s.node.uid,s);this._outputShaderTypes=n,this._transformFeedbackBindings=r,this._transformFeedbackNames=new Set(r.map(s=>"v_"+s.propertyKey)),this._usedInFragmentShader=i}shouldPruneOutputNode(t){return!!this._usedInFragmentShader&&t.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(t.outVariableName)&&!this._usedInFragmentShader.has(t.node.uid)}setEmit(t,n){this._nodeEmitMap.set(t.uid,n)}getEmit(t){return this._nodeEmitMap.get(t.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(t){return this._inputShaderTypesByNodeUid.get(t.uid)}*rootOutputNodes(){for(const t of this._outputShaderTypes)yield t}*nodes(){const t=[];for(const n of this._outputShaderTypes.values())t.push(n.node);for(;t.length;){const n=t.pop();typeof n!="number"&&typeof n!="boolean"&&t.push(...n.children.filter(Boolean)),yield n}}*nodesOfTypeOrFunction(){for(const t of this.nodes())typeof t!="number"&&typeof t!="boolean"&&(yield t)}createSubgraphContext(){const t=this.clone();return t.body="",t.indent=this.indent+2,t._nodeEmitMap=new Map(this._nodeEmitMap),t}clone(){const t=new A([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return t._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,t.indent=this.indent,t.body=this.body,t.varCount=this.varCount,t._nodeEmitMap=this._nodeEmitMap,t}insertVertexShader(t){t.vertex.code.add(""),this._insertInputs(t,"vertex"),t.vertex.code.add(""),t.vertex.code.add("// OUTPUTS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const n of this.rootOutputNodes()){const r=n.outVariableType==="builtin";this.shouldPruneOutputNode(n)||(r?t.vertex.code.add(`// ${n.outVariableType.padEnd(7)} ${n.node.type.padEnd(9)} ${n.outVariableName};`):t.vertex.code.add(`${n.outVariableType.padEnd(10)} ${n.node.type.padEnd(9)} ${n.outVariableName};`))}t.vertex.code.add(""),t.vertex.code.add("void main() {"),t.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const n of this.rootOutputNodes())this.shouldPruneOutputNode(n)||t.vertex.code.add(`  ${n.outVariableName} = ${n.variableName};`);t.vertex.code.add("}")}insertFragmentShader(t){this._insertInputs(t,"fragment"),t.fragment.code.add(""),t.fragment.code.add("// OUTPUTS: "),t.fragment.code.add("// --------------------------------------------------------- ");let n=0;for(const r of this.rootOutputNodes())r.outVariableType==="builtin"?t.fragment.code.add(`// ${r.outVariableType.padEnd(7)} ${r.node.type.padEnd(9)} ${r.outVariableName};`):t.outputs.add(r.outVariableName,r.node.type,n++);t.fragment.code.add(""),t.fragment.code.add("void main() {"),t.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const r of this.rootOutputNodes())r.outVariableType==="discard"?(t.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),t.fragment.code.add(`  if (${r.variableName}) {`),t.fragment.code.add("    discard;"),t.fragment.code.add("  }"),t.fragment.code.add("  ")):t.fragment.code.add(`  ${r.outVariableName} = ${r.variableName};`);t.fragment.code.add("}")}_insertInputs(t,n){t[n].code.add("// INPUTS: "),t[n].code.add("// --------------------------------------------------------- ");for(const r of this.inputs())r.isUsed&&r.variableInputType!=="builtin"&&(r.node.type==="array"?t[n].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}];`):r.node.type==="array-2d"?t[n].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}]; // Emulated 2D Array. Not supported by ES3.0`):t[n].code.add(`${r.variableInputType.padEnd(10)} ${r.node.type.padEnd(9)} ${r.variableName};`))}}function Te(e,t,n){const r=new te(t.width,t.height);return r.dataType=t.dataType,t.depth&&(r.depth=t.depth),t.flipped&&(r.flipped=t.flipped),t.hasMipmap&&(r.hasMipmap=t.hasMipmap),r.internalFormat=t.internalFormat,t.isImmutable&&(r.isImmutable=t.isImmutable),t.isOpaque&&(r.isOpaque=t.isOpaque),t.maxAnisotropy&&(r.maxAnisotropy=t.maxAnisotropy),r.pixelFormat=t.pixelFormat,t.preMultiplyAlpha&&(r.preMultiplyAlpha=t.preMultiplyAlpha),t.samplingMode&&(r.samplingMode=t.samplingMode),t.target&&(r.target=t.target),r.uniform=t.uniform,t.unpackAlignment&&(r.unpackAlignment=t.unpackAlignment),t.wrapMode&&(r.wrapMode=t.wrapMode),new ee(e,r,n)}const Ne=()=>Vt.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function z(e,t,n){const r=t.length;if(r!==n){const i=new Yt("Invalid Uniform",`Invalid length, expected ${n} but got ${r}`,{uniformName:e,values:t});Ne().errorOnce(i)}}class Bt{constructor(t,n,r,i,s,c){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=t,this.fragmentShader=n,this._locations=r,this._locationInfo=i,this._uniformBindings=s,this._transformFeedbackBindings=c}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(t){this._uniforms=t}cleanupTemporaryTextures(){for(const t of this._temporaryTextures)t.dispose();this._temporaryTextures=[]}bind(t){const n=this._uniforms;if(!this._program){const i=new Map;for(const[c,u]of this._locations)i.set(c,u);const s=[];for(const c of this._transformFeedbackBindings??[]){const{index:u,propertyKey:a}=c;s[u]=`v_${a}`}this._program=new ne(t,this.vertexShader,this.fragmentShader,i,new Map,s)}const r=this._program;t.useProgram(r);for(const i of this._uniformBindings){const{shaderModulePath:s,uniformName:c,uniformType:u,uniformArrayLength:a}=i,h=Zt(s,n);if(h==null){if(u==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${s}`)}switch(u==="array"||u==="array-2d"?i.uniformArrayElementType:u){case"sampler2D":{const{unit:d,texture:l}=h;if(r.setUniform1i(c,d),"type"in l)t.bindTexture(l,d);else{const v=Te(t,l.descriptor,l.data);t.bindTexture(v,d)}break}case"int":if(!a){r.setUniform1i(c,h);break}z(i.uniformName,h,a),r.setUniform1iv(c,h);break;case"float":if(!a){r.setUniform1f(c,h);break}z(i.uniformName,h,a),r.setUniform1fv(c,h);break;case"vec2":if(!a){r.setUniform2f(c,h[0],h[1]);break}z(i.uniformName,h,a),r.setUniform2fv(c,h.flat());break;case"vec3":if(!a){r.setUniform3f(c,h[0],h[1],h[2]);break}z(i.uniformName,h,a),r.setUniform3fv(c,h.flat());break;case"vec4":if(!a){r.setUniform4f(c,h[0],h[1],h[2],h[3]);break}z(i.uniformName,h,a),r.setUniform4fv(c,h.flat());break;case"mat3":r.setUniformMatrix3fv(c,h);break;case"mat4":r.setUniformMatrix4fv(c,h);break;default:throw new Error(`Unable to set uniform for type ${u}`)}}}}function D(e){return new e}function j(e,t,n){const r=e.constructor[t]??[];e.constructor.hasOwnProperty(t)||Object.defineProperty(e.constructor,t,{value:r.slice()}),e.constructor[t].push(n)}function wn(e,t){return(n,r)=>{j(n,"locations",{typeCtor:t,propertyKey:r,parameterIndex:null,index:e})}}const Me=e=>(t,n)=>{j(t,"builtins",{builtin:e,propertyKey:n})},vn=e=>(t,n,r)=>{j(t,"inputs",{inputCtor:e,propertyKey:n,parameterIndex:r})},xn=e=>(t,n)=>{j(t,"uniforms",{typeCtor:e,propertyKey:n})},_n=e=>(t,n)=>{j(t,"options",{typeCtor:e,propertyKey:n})},In=(e,t)=>{j(e,"defines",{propertyKey:t})},Nt=(e,t)=>(n,r)=>{n.constructor.builtins.push({builtin:e,propertyKey:r,typeCtor:t})};class jt{}jt.builtins=[],g([Nt("gl_VertexID",f)],jt.prototype,"glVertexID",void 0);class $n{}class at{}at.builtins=[],g([Nt("gl_FragCoord",C)],at.prototype,"glFragCoord",void 0),g([Nt("gl_PointCoord",U)],at.prototype,"glPointCoord",void 0);class Se{}g([Me("gl_FragDepth")],Se.prototype,"glFragDepth",void 0);class Tn{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}}let Nn=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const e=this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===0);if(!e)throw new Error("Unable to find vertex input parameter");return e}get computeInput(){return this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="vertex"&&e.parameterIndex===1)}get fragmentInput(){const e=this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="fragment");if(!e)throw new Error("Unable to find fragment input parameter");return e}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const e=new Map,t=new Set;for(const n of this.locations)t.has(n.index)?Vt.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${n.propertyKey} to ${n.index}. Index already in use`,{locationsMap:e}):(e.set(n.propertyKey,n.index),t.add(n.index));return e}get locationInfo(){if(!this._locationInfo){const e=this.locationsMap,t=Array.from(e.entries()).map(([i,s])=>`${i}.${s}`).join("."),n=Xt(t),r=this.computeAttributes;this._locationInfo={hash:n,stringHash:t,locations:e,computeAttributeMap:r}}return this._locationInfo}get renamedLocationsMap(){const e=new Map;for(const t of this.locations)e.set("a_"+t.propertyKey,t.index);return e}get optionPropertyKeys(){if(!this._optionPropertyKeys){const e=new Set;for(const t of this._options)e.add(t.propertyKey);this._optionPropertyKeys=e}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(e,t,n,r){try{const{vertex:i,fragment:s,uniformBindings:c}=this._generateShaders(e,t,n,r);return new Bt(i,s,this.renamedLocationsMap,this.locationInfo,c,this.transformFeedbackBindings)}catch{return new Bt("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(e){const t=this._options.find(r=>r.propertyKey===e);if(t)return{type:"option",className:t.typeCtor};const n=this._uniforms.find(r=>r.propertyKey===e);if(!n)throw new Error(`Unable to find uniform class type for property: ${e}`);return{type:"required",className:n.typeCtor}}getShaderKey(e,t,n,r){const i=Object.keys(e).map(a=>`${a}.${e[a]}`).join("."),s=Object.keys(n).map(a=>`${a}.${n[a]}`).join("."),c=Object.keys(r).map(a=>`${a}.${r[a]}`).join("."),u=Object.keys(t).filter(a=>this.optionPropertyKeys.has(a)&&t[a]).join(".");return`${this.type}.${i}.${s}.${c}.${u}`}_generateShaders(e,t,n,r){const i=[];this._setDefines(n),this._setOptionalUniforms(i,t),this._setRequiredUniforms(i);const s=this._hydrateVertexInput(r),c=this._injectPackPrecisionFactor(s,e),u=this._hydrateComputeInput(),a=u&&this._injectComputePackPrecisionFactor(u,e),h=this.vertex(c,a),d=this._hydrateFragmentInput(h),l=this.fragment(d),v=new Set;for(const Qt in l){const Wt=l[Qt];se(v,Wt)}const P=this._getVertexInputBuiltins(),S=A.createVertex({...s,...u},h,P,i,this.transformFeedbackBindings,v);new At().write(S);const Q=this._getFragmentInputBuiltins(l);Q.set("glPointCoord","gl_PointCoord");const W=A.createFragment(d,l,Q,i,S,this.transformFeedbackBindings);new At().write(W);const Kt=this._createShaderBuilder(S,W),Ut=Kt.generate("vertex"),Ot=Kt.generate("fragment");return this.logShader&&(console.log(Ut),console.log(Ot)),{vertex:Ut,fragment:Ot,uniformBindings:i}}_setDefines(e){for(const t in e)this[t]=e[t]}_setOptionalUniforms(e,t){for(const n of this._options)t[n.propertyKey]?this[n.propertyKey]=this._hydrateUniformGroup(e,n):this[n.propertyKey]=null}_setRequiredUniforms(e){for(const t of this._uniforms)this[t.propertyKey]=this._hydrateUniformGroup(e,t)}_hydrateUniformGroup(e,t){const n=new t.typeCtor;for(const r of n._uniforms??[]){const i=D(r.typeCtor),s=`u_${t.propertyKey}_${r.propertyKey}`,c=i.type,u=[t.propertyKey,r.propertyKey].join(".");if("type"in r.typeCtor&&r.typeCtor.type==="array"){const a=i;e.push({shaderModulePath:u,uniformName:s,uniformType:c,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else if("type"in r.typeCtor&&r.typeCtor.type==="array-2d"){const a=i;e.push({shaderModulePath:u,uniformName:s,uniformType:c,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else e.push({shaderModulePath:u,uniformName:s,uniformType:c,uniformHydrated:i});n[r.propertyKey]=i}return n}_hydrateVertexInput(e){const t=this.vertexInput.inputCtor,n=t.locations.reduce((r,i)=>e[i.propertyKey]===!1?r:{...r,[i.propertyKey]:D(i.typeCtor)},{});for(const{propertyKey:r,typeCtor:i}of t.builtins){const s=D(i);n[r]=s}return n}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((e,t)=>({...e,[t.propertyKey]:D(t.typeCtor)}),{})}_injectPackPrecisionFactor(e,t){const n={};for(const r in e){const i=e[r],s=t[r];if(s){if(i.type!=="float"&&i.type!=="vec2"&&i.type!=="vec3"&&i.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);n[r]=i.divide(new p(s))}else n[r]=i}return n}_injectComputePackPrecisionFactor(e,t){const n={},r=new Map;for(const i in this.computeAttributes)for(const s of this.computeAttributes[i]??[])r.set(s,i);for(const i in e){const s=e[i],c=r.get(i);if(!c)continue;const u=t[c];if(u){if(s.type!=="float"&&s.type!=="vec2"&&s.type!=="vec3"&&s.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);n[i]=s.divide(new p(u))}else n[i]=s}return n}_hydrateFragmentInput(e){const t={};for(const n in e)t[n]=e[n];for(const{propertyKey:n,typeCtor:r}of at.builtins){const i=D(r);t[n]=i}return t}_getVertexInputBuiltins(){const e=this.vertexInput.inputCtor,t=new Map;for(const{builtin:n,propertyKey:r}of e.builtins)t.set(r,n);return t}_getFragmentInputBuiltins(e){const t=e.constructor,n=new Map;for(const r of t.builtins??[])n.set(r.propertyKey,r.builtin);return n}_createShaderBuilder(e,t){const n=new re;return this._insertDebugInfo(n),e.insertVertexShader(n),t.insertFragmentShader(n),n}_insertDebugInfo(e){e.vertex.code.add("// DEFINES: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._defines)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`);e.vertex.code.add(""),e.vertex.code.add("// OPTIONS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._options)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`)}};export{je as $,Je as A,We as B,De as C,Xe as D,jt as E,O as F,be as G,we as H,Ae as I,on as J,G as K,Z as L,f as M,Ge as N,Qe as O,U as P,cn as Q,nn as R,C as S,He as T,Re as U,q as V,an as W,un as X,hn as Y,$e as Z,ln as _,p as a,Ve as a0,Se as a1,qt as a2,xe as a3,pn as a4,Bt as a5,at as a6,dn as a7,ze as a8,Be as a9,fn as aa,Le as ab,N as ac,Ze as ad,Ye as b,bn as c,wn as d,Nn as e,_n as f,Tn as g,kt as h,qe as i,ye as j,tn as k,xn as l,$n as m,Ct as n,gn as o,Oe as p,Ie as q,en as r,vn as s,yn as t,sn as u,_ as v,mn as w,rn as x,In as y,fe as z};
