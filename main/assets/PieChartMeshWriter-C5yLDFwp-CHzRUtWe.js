const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngineJSON-CGn_tfx8-D3N6SheD.js","./geometryEngineBase-DueYg7ux-CCeespPx.js","./_commonjsHelpers-BITg13Vk-KnjfkSck.js","./json-BI97KiBB-Ce5cWfI2.js"])))=>i.map(i=>d[i]);
import{K as te,f4 as m,ar as ee,o as se,a1 as ie,hJ as re,ae as gt,_ as oe}from"./main-BNyfiy7F.js";import{I as h}from"./enums-DBi1-Mm2-CUS1pvQe.js";import{b as $,e as kt,c as ne,i as ae,P as ce,x as zt,d as Dt,Y as ue,W as le,X as he,U as pe,u as C,f as St,R as Pt,g as vt,E as T,h as de,j as fe}from"./UpdateTracking2D-Du_WIf4G-D2umhCAm.js";import{O as xe,D as At,d as Yt}from"./GeometryUtils-NHgB9gGQ-BOISEWyS.js";import{t as tt,K as rt,n as R,d as me,$ as ye,_ as _e,r as ge,c as ke}from"./definitions-DJSdSb77-DkoRHaVx.js";import{D as Se,M as Pe,k as ve}from"./TurboLine-CIlsAy5m-zn0VY_Hb.js";import{t as Nt,e as be,Z as we,V as Te}from"./LabelMetric-BeluzH3o-Bgyy7ZLs.js";import{I as Bt}from"./utils-SPbpQbmm-Bi_GIGH0.js";import{S as G,r as Lt,i as nt,R as at,t as ct}from"./enums-CpSG_SL3-BMD3Tb1v.js";import"./earcut-XDcq3zAf-BcwyrT7l.js";import{c as Ee}from"./OptimizedFeature-EIithYlr-Cq64mIT3.js";import{l as Me,G as Ie,i as ze,e as De}from"./Tile-D75RMC64-C5dNrHl8.js";import{L as Q}from"./vec2-tHZ6OaOy-xCj1obDt.js";import{e as J}from"./constants-Bqe1QJ4u-F8oTIn7N.js";const Ae=()=>ie.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),Ye=0,Ne=100;function Z(t,e){return[!!t?.minScale&&e.scaleToZoom(t.minScale)||Ye,!!t?.maxScale&&e.scaleToZoom(t.maxScale)||Ne]}function W(t){return 1<<t}function q(t){let e=0;for(const[s,i]of t)i&&(e|=1<<s);return e}function g(t){let e;if(!t)return[0,0,0,0];if(typeof t=="string"){const n=ee.fromString(t);if(!n)return Ae().errorOnce(new se("mapview:mesh-processing","Unable to parse string into color",{color:t})),[0,0,0,0];e=n.toArray()}else e=t;const[s,i,r,o]=e;return[s*(o/255),i*(o/255),r*(o/255),o]}function Be(t){switch(t){case"butt":case G.Butt:return nt.BUTT;case"round":case G.Round:return nt.ROUND;case"square":case G.Square:return nt.SQUARE}}function Le(t){switch(t){case"bevel":case at.Bevel:return ct.BEVEL;case"miter":case at.Miter:return ct.MITER;case"round":case at.Round:return ct.ROUND}}function ut(t,e){return Math.round(Math.min(Math.sqrt(t*e),255))}function j(t,e){return Math.round(t*e)/e}const Ge=96/72;let Re=class{static executeEffects(t,e,s,i){const r=Ge,o=St(t);let n=new vt(e);for(const a of t){const c=Pt(a);c&&(n=c.execute(n,a,r,s,i,o))}return n}static applyEffects(t,e,s){if(!t)return e;const i=St(t);let r,o=new vt(T.fromJSONCIM(e));for(const c of t){const l=Pt(c);l&&(o=l.execute(o,c,1,null,s,i))}const n=[];let a=null;for(;r=o.next();)n.push(...re(r)),a=r.geometryType;return n.length===0||a===null?null:a==="esriGeometryPolygon"?{rings:n}:{paths:n}}},Gt=null;function mt(){return Gt}async function Fe(){Gt=await oe(()=>import("./geometryEngineJSON-CGn_tfx8-D3N6SheD.js"),__vite__mapDeps([0,1,2,3]),import.meta.url).then(t=>t.g)}function Rt(t){switch(t){case h.BYTE:case h.UNSIGNED_BYTE:return 1;case h.SHORT:case h.UNSIGNED_SHORT:case h.HALF_FLOAT:return 2;case h.FLOAT:case h.INT:case h.UNSIGNED_INT:return 4}}function Oe(t){const e=[],s=[],i=[];for(const r of t){const o=Rt(r.type)*r.count;switch(o%2||o%4||4){case 4:e.push(r);continue;case 2:s.push(r);continue;case 1:i.push(r);continue;default:throw new Error("Found unexpected dataType byte count")}}return e.push(...s),e.push(...i),e}let Ce=class Ft{static fromVertexSpec(e,s){const{attributes:i,optionalAttributes:r}=e;let o,n,a;const c=[];for(const y in i){const _=i[y];_.pack==="position"?o={..._,name:y,offset:0}:_.pack==="id"?n={..._,name:y,offset:4}:y==="bitset"?a={..._,name:y,offset:7}:c.push({..._,name:y})}for(const y in r)if(s[y]===!0){const _=r[y];c.push({..._,name:y})}const l=Oe(c),u=[];let f=8,x=1;for(const y of l)u.push({...y,offset:f}),f+=Rt(y.type)*y.count,y.packAlternating&&(x=Math.max(y.packAlternating.count,x));const p=Uint32Array.BYTES_PER_ELEMENT,d=f%p;return new Ft(o,n,a,u,f+(d?p-d:0),x)}constructor(e,s,i,r,o,n){this.position=e,this.id=s,this.bitset=i,this.standardAttributes=r,this.stride=o,this.packVertexCount=n,r.push(i),this._attributes=[e,s,i,...r]}get attributeLayout(){if(!this._attributeLayout){const e=we(this._attributes),s=this._attributes.map(i=>({name:i.name,count:i.count,offset:i.offset,type:i.type,packPrecisionFactor:i.packPrecisionFactor,normalized:i.normalized??!1}));this._attributeLayout={attributes:s,hash:e,stride:this.stride}}return this._attributeLayout}},We=class Ot{static fromVertexSpec(e,s){const i=Ce.fromVertexSpec(e,s);return new Ot(i)}constructor(e){this._spec=e,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(e,s,i,r,o,n){for(let a=0;a<this._spec.packVertexCount;a++){const c=a*this._spec.stride;this._packPosition(i,r,c),this._packId(s,c);const l=this._spec.bitset;if(n){if(l.packTessellation){const u=l.packTessellation(n,o);this._pack(u,l,c)}for(const u of this._spec.standardAttributes)if(u.packTessellation!=null){const f=u.packTessellation(n,o);this._pack(f,u,c)}else if(u.packAlternating?.packTessellation){const f=u.packAlternating.packTessellation(n,o);for(let x=0;x<this._spec.packVertexCount;x++){const p=f[x];this._pack(p,u,x*this._spec.stride)}}}}e.vertexWriteRegion(this._packedU32View)}pack(e,s){for(const i of this._spec.standardAttributes)if(i.pack&&typeof i.pack!="string"){const r=i.pack(e,s);for(let o=0;o<this._spec.packVertexCount;o++)this._pack(r,i,o*this._spec.stride)}else if(i.packAlternating?.pack){const r=i.packAlternating.pack(e,s);for(let o=0;o<this._spec.packVertexCount;o++){const n=r[o];this._pack(n,i,o*this._spec.stride)}}}_packPosition(e,s,i){const{offset:r}=this._spec.position,o=this._spec.position.packPrecisionFactor??1,n=Te(e*o,s*o);this._dataView.setUint32(i+r,n,!0)}_packId(e,s){const i=e*(this._spec.id.packPrecisionFactor??1),r=4278190080&this._dataView.getUint32(s+this._spec.id.offset,!0);this._dataView.setUint32(s+this._spec.id.offset,i|r,!0)}_pack(e,s,i){be(this._dataView,e,s,i)}};function Ue(t){if(!t)return!1;for(const e of t)switch(e.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectOffset":case"CIMGeometricEffectDonut":return!0}return!1}let O=class{constructor(t,e,s,i){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=s,this._viewParams=i,this._evaluator.evaluator=r=>this.vertexSpec.createComputedParams(r)}get _vertexPack(){if(!this._cachedVertexPack){const t=We.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){Ue(this._evaluator.inputMeshParams.effects?.effectInfos)&&await Fe()}enqueueRequest(t,e,s){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,s)}write(t,e,s,i,r){this.ensurePacked(e,s,i);const o=this.evaluatedMeshParams.effects;if(!o||o.length===0)return void this._write(t,s,void 0,r);const n=s.readGeometryForDisplay()?.clone();if(!n)return;const a=T.fromOptimizedCIM(n,s.geometryType),c=mt();a.invertY();const l=t.id||"",u=Re.executeEffects(o,a,l,c);let f;for(;f=u.next();)f.invertY(),this._write(t,s,f,r)}ensurePacked(t,e,s){if(!this._evaluator.hasDynamicProperties)return;const i=this._evaluator.evaluateMeshParams(t,e,s);this._vertexPack.pack(i,this._viewParams)}_writeVertex(t,e,s,i,r){const o=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,s,i,o,r)}};function He(t,e,s,i,r,o,n){pt=0;const a=(i-s)*o,c=r&&r.length,l=c?(r[0]-s)*o:a;let u,f,x,p,d,y=Ct(e,s,i,0,l,o,!0);if(y&&y.next!==y.prev){if(c&&(y=qe(e,s,i,r,y,o)),a>80*o){u=x=e[0+s*o],f=p=e[1+s*o];for(let _=o;_<l;_+=o){const P=e[_+s*o],S=e[_+1+s*o];u=Math.min(u,P),f=Math.min(f,S),x=Math.max(x,P),p=Math.max(p,S)}d=Math.max(x-u,p-f),d=d!==0?1/d:0}H(y,t,o,u,f,d,n,0)}}function Ct(t,e,s,i,r,o,n){let a;if(n===$e(t,e,s,i,r,o)>0)for(let c=i;c<r;c+=o)a=bt(c+e*o,t[c+e*o],t[c+1+e*o],a);else for(let c=r-o;c>=i;c-=o)a=bt(c+e*o,t[c+e*o],t[c+1+e*o],a);return a&&D(a,a.next)&&(X(a),a=a.next),a}function U(t,e=t){if(!t)return t;let s,i=t;do if(s=!1,i.steiner||!D(i,i.next)&&k(i.prev,i,i.next)!==0)i=i.next;else{if(X(i),i=e=i.prev,i===i.next)break;s=!0}while(s||i!==e);return e}function H(t,e,s,i,r,o,n,a){if(!t)return;!a&&o&&(t=Wt(t,i,r,o));let c=t;for(;t.prev!==t.next;){const l=t.prev,u=t.next;if(o?Ve(t,i,r,o):Xe(t))e.push(l.index/s+n),e.push(t.index/s+n),e.push(u.index/s+n),X(t),t=u.next,c=u.next;else if((t=u)===c){a?a===1?H(t=es(t,e,s,n),e,s,i,r,o,n,2):a===2&&ss(t,e,s,i,r,o,n):H(U(t),e,s,i,r,o,n,1);break}}}function Xe(t){const e=t.prev,s=t,i=t.next;if(k(e,s,i)>=0)return!1;let r=t.next.next;const o=r;let n=0;for(;r!==t.prev&&(n===0||r!==o);){if(n++,L(e.x,e.y,s.x,s.y,i.x,i.y,r.x,r.y)&&k(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function Ve(t,e,s,i){const r=t.prev,o=t,n=t.next;if(k(r,o,n)>=0)return!1;const a=r.x<o.x?r.x<n.x?r.x:n.x:o.x<n.x?o.x:n.x,c=r.y<o.y?r.y<n.y?r.y:n.y:o.y<n.y?o.y:n.y,l=r.x>o.x?r.x>n.x?r.x:n.x:o.x>n.x?o.x:n.x,u=r.y>o.y?r.y>n.y?r.y:n.y:o.y>n.y?o.y:n.y,f=lt(a,c,e,s,i),x=lt(l,u,e,s,i);let p=t.prevZ,d=t.nextZ;for(;p&&p.z>=f&&d&&d.z<=x;){if(p!==t.prev&&p!==t.next&&L(r.x,r.y,o.x,o.y,n.x,n.y,p.x,p.y)&&k(p.prev,p,p.next)>=0||(p=p.prevZ,d!==t.prev&&d!==t.next&&L(r.x,r.y,o.x,o.y,n.x,n.y,d.x,d.y)&&k(d.prev,d,d.next)>=0))return!1;d=d.nextZ}for(;p&&p.z>=f;){if(p!==t.prev&&p!==t.next&&L(r.x,r.y,o.x,o.y,n.x,n.y,p.x,p.y)&&k(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;d&&d.z<=x;){if(d!==t.prev&&d!==t.next&&L(r.x,r.y,o.x,o.y,n.x,n.y,d.x,d.y)&&k(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function bt(t,e,s,i){const r=F.create(t,e,s);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function X(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Ze(t){let e=t,s=t;do(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next;while(e!==t);return s}function qe(t,e,s,i,r,o){const n=new Array;for(let a=0,c=i.length;a<c;a++){const l=Ct(t,e,s,i[a]*o,a<c-1?i[a+1]*o:s*o,o,!1);l===l.next&&(l.steiner=!0),n.push(Ze(l))}n.sort(ts);for(const a of n)r=Qe(a,r);return r}function Qe(t,e){const s=Je(t,e);if(!s)return e;const i=Ht(s,t);return U(i,i.next),U(s,s.next)}function Je(t,e){let s=e;const i=t.x,r=t.y;let o,n=-1/0;do{if(r<=s.y&&r>=s.next.y&&s.next.y!==s.y){const x=s.x+(r-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(x<=i&&x>n){if(n=x,x===i){if(r===s.y)return s;if(r===s.next.y)return s.next}o=s.x<s.next.x?s:s.next}}s=s.next}while(s!==e);if(!o)return null;if(i===n)return o.prev;const a=o,c=o.x,l=o.y;let u,f=1/0;for(s=o.next;s!==a;)i>=s.x&&s.x>=c&&i!==s.x&&L(r<l?i:n,r,c,l,r<l?n:i,r,s.x,s.y)&&(u=Math.abs(r-s.y)/(i-s.x),(u<f||u===f&&s.x>o.x)&&V(s,t)&&(o=s,f=u)),s=s.next;return o}function Wt(t,e,s,i){let r;for(;r!==t;r=r.next){if(r=r||t,r.z===null&&(r.z=lt(r.x,r.y,e,s,i)),r.prev.next!==r||r.next.prev!==r)return r.prev.next=r,r.next.prev=r,Wt(t,e,s,i);r.prevZ=r.prev,r.nextZ=r.next}return t.prevZ.nextZ=null,t.prevZ=null,je(t)}function je(t){let e,s=1;for(;;){let i,r=t;t=null,e=null;let o=0;for(;r;){o++,i=r;let n=0;for(;n<s&&i;n++)i=i.nextZ;let a=s;for(;n>0||a>0&&i;){let c;n===0?(c=i,i=i.nextZ,a--):a!==0&&i?r.z<=i.z?(c=r,r=r.nextZ,n--):(c=i,i=i.nextZ,a--):(c=r,r=r.nextZ,n--),e?e.nextZ=c:t=c,c.prevZ=e,e=c}r=i}if(e.nextZ=null,s*=2,o<2)return t}}function k(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function Ut(t,e,s,i){return!!(D(t,e)&&D(s,i)||D(t,i)&&D(s,e))||k(t,e,s)>0!=k(t,e,i)>0&&k(s,i,t)>0!=k(s,i,e)>0}function Ke(t,e){let s=t;do{if(s.index!==t.index&&s.next.index!==t.index&&s.index!==e.index&&s.next.index!==e.index&&Ut(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}function $e(t,e,s,i,r,o){let n=0;for(let a=i,c=r-o;a<r;a+=o)n+=(t[c+e*o]-t[a+e*o])*(t[a+1+e*o]+t[c+1+e*o]),c=a;return n}function L(t,e,s,i,r,o,n,a){return(r-n)*(e-a)-(t-n)*(o-a)>=0&&(t-n)*(i-a)-(s-n)*(e-a)>=0&&(s-n)*(o-a)-(r-n)*(i-a)>=0}function V(t,e){return k(t.prev,t,t.next)<0?k(t,e,t.next)>=0&&k(t,t.prev,e)>=0:k(t,e,t.prev)<0||k(t,t.next,e)<0}function lt(t,e,s,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*r)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*r)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function D(t,e){return t.x===e.x&&t.y===e.y}function ts(t,e){return t.x-e.x}function es(t,e,s,i){let r=t;do{const o=r.prev,n=r.next.next;!D(o,n)&&Ut(o,r,r.next,n)&&V(o,n)&&V(n,o)&&(e.push(o.index/s+i),e.push(r.index/s+i),e.push(n.index/s+i),X(r),X(r.next),r=t=n),r=r.next}while(r!==t);return r}function ss(t,e,s,i,r,o,n){let a=t;do{let c=a.next.next;for(;c!==a.prev;){if(a.index!==c.index&&is(a,c)){let l=Ht(a,c);return a=U(a,a.next),l=U(l,l.next),H(a,e,s,i,r,o,n,0),void H(l,e,s,i,r,o,n,0)}c=c.next}a=a.next}while(a!==t)}function is(t,e){return t.next.index!==e.index&&t.prev.index!==e.index&&!Ke(t,e)&&V(t,e)&&V(e,t)&&rs(t,e)}function rs(t,e){let s=t,i=!1;const r=(t.x+e.x)/2,o=(t.y+e.y)/2;do s.y>o!=s.next.y>o&&s.next.y!==s.y&&r<(s.next.x-s.x)*(o-s.y)/(s.next.y-s.y)+s.x&&(i=!i),s=s.next;while(s!==t);return i}function Ht(t,e){const s=F.create(t.index,t.x,t.y),i=F.create(e.index,e.x,e.y),r=t.next,o=e.prev;return t.next=e,e.prev=t,s.next=r,r.prev=s,i.next=s,s.prev=i,o.next=i,i.prev=o,i}class F{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(e,s,i){const r=pt<ht.length?ht[pt++]:new F;return r.index=e,r.x=s,r.y=i,r.prev=null,r.next=null,r.z=null,r.prevZ=null,r.nextZ=null,r.steiner=!1,r}}const ht=[],os=8096;let pt=0;for(let t=0;t<os;t++)ht.push(new F);const ns=1e-5,z=new At(0,0,0,1,0),dt=new At(0,0,0,1,0);function wt(t,e,s){let i=0;for(let r=1;r<s;r++){const o=t[2*(e+r-1)],n=t[2*(e+r-1)+1];i+=(t[2*(e+r)]-o)*(t[2*(e+r)+1]+n)}return i}function as(t,e,s,i,r){let o=0;const n=2;for(let a=s;a<i;a+=3){const c=(t[a]-r)*n,l=(t[a+1]-r)*n,u=(t[a+2]-r)*n;o+=Math.abs((e[c]-e[u])*(e[l+1]-e[c+1])-(e[c]-e[l])*(e[u+1]-e[c+1]))}return o}function cs(t,e){const{coords:s,lengths:i}=e,r=0,o=t;let n=0;for(let a=0;a<i.length;){let c=a,l=i[a],u=wt(s,n,l);const f=[];for(;++c<i.length;){const y=i[c],_=wt(s,n+l,y);if(!(_>0))break;u+=_,f.push(n+l),l+=y}const x=o.length;He(o,s,n,n+l,f,2,r);const p=as(o,s,x,o.length,r),d=Math.abs(u);if(Math.abs((p-d)/Math.max(1e-7,d))>ns)return o.length=0,!1;a=c,n+=l}return!0}function us(t){const{coords:e,lengths:s}=t,{buffer:i}=ve(e,s);return i}function ls(t,e,s){let i=0;for(let r=0;r<t.lengths.length;r++){const o=t.lengths[r];for(let n=0;n<o;n++){const a=t.coords[2*(n+i)],c=t.coords[2*(n+i)+1];if(a<e||a>s||c<e||c>s)return!0}i+=o}return!1}function Xt(t,e){if(t==null)return null;if(!ls(t,-128,tt+128))return t;z.setPixelMargin(e),z.reset(Yt.Polygon);let s=0;for(let n=0;n<t.lengths.length;n++){const a=t.lengths[n];let c=t.coords[2*(0+s)],l=t.coords[2*(0+s)+1];z.moveTo(c,l);for(let u=1;u<a;u++)c=t.coords[2*(u+s)],l=t.coords[2*(u+s)+1],z.lineTo(c,l);z.close(),s+=a}const i=z.result(!1);if(!i)return null;const r=[],o=[];for(const n of i){let a=0;for(const c of n)o.push(c.x),o.push(c.y),a++;r.push(a)}return new Ee(r,o)}function hs(t,e){dt.setPixelMargin(e);const s=dt,i=-e,r=tt+e;let o=[],n=!1;if(!t.nextPath())return null;let a=!0;for(;a;){t.seekPathStart();const c=[];if(!t.pathSize)return null;s.reset(Yt.LineString),t.nextPoint();let l=t.x,u=t.y;if(n)s.moveTo(l,u);else{if(l<i||l>r||u<i||u>r){n=!0;continue}c.push({x:l,y:u})}let f=!1;for(;t.nextPoint();)if(l=t.x,u=t.y,n)s.lineTo(l,u);else{if(l<i||l>r||u<i||u>r){f=!0;break}c.push({x:l,y:u})}if(f)n=!0;else{if(n){const x=s.resultWithStarts();if(x)for(const p of x)o.push(p)}else o.push({line:c,start:0});a=t.nextPath(),n=!1}}return o=o.filter(c=>c.line.length>1),o.length===0?null:o}z.setExtent(tt),dt.setExtent(tt);const ps=100,ds=te("featurelayer-fast-triangulation-enabled");class Vt extends O{async loadDependencies(){await Promise.all([super.loadDependencies(),Pe()])}_write(e,s,i){const r=i?.asOptimized()??s.readGeometryForDisplay(),o=this._clip(r);o&&(e.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(e,s,o),e.recordEnd())}_clip(e){if(!e)return null;const s=this.hasEffects;return Xt(e,s?256:8)}_writeGeometry(e,s,i){const r=i.maxLength>ps,o=[],n=this.createTesselationParams(s);if(!r&&ds&&cs(o,i))return void(o.length&&this._writeVertices(e,s,i.coords,n,o));const a=us(i);this._writeVertices(e,s,a,n)}_writeVertices(e,s,i,r,o){const n=s.getDisplayId(),a=e.vertexCount(),c=this.hasEffects;let l=0;if(o)for(const u of o){const f=i[2*u],x=i[2*u+1];c&&e.recordBounds(f,x,0,0),this._writeVertex(e,n,f,x,r),l++}else for(let u=0;u<i.length;u+=2){const f=Math.round(i[u]),x=Math.round(i[u+1]);c&&e.recordBounds(f,x,0,0),this._writeVertex(e,n,f,x,r),l++}e.indexEnsureSize(l);for(let u=0;u<l;u++)e.indexWrite(u+a)}}const fs={createComputedParams:t=>t,optionalAttributes:{},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:h.FLOAT,count:1,packTessellation:({inverseArea:t})=>t}}};let ri=class extends Vt{constructor(){super(...arguments),this.vertexSpec=fs}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}};const ft={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:rt,pack:({scaleInfo:t},{tileInfo:e})=>Z(t,e)}},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)}}};let Zt=class extends Vt{constructor(){super(...arguments),this.vertexSpec=ft}createTesselationParams(t){return null}};const A={createComputedParams:t=>t,optionalAttributes:ft.optionalAttributes,attributes:{...ft.attributes,tlbr:{count:4,type:h.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:s,height:i}=t,r=e.x+R,o=e.y+R;return[r,o,r+s,o+i]}},inverseRasterizationScale:{count:1,type:h.BYTE,packPrecisionFactor:16,pack:({sprite:t})=>1/t.rasterizationScale}}};let xs=class extends Zt{constructor(){super(...arguments),this.vertexSpec=A}_write(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay(),r=this._clip(i);if(!r)return;const o=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,e,r),t.recordEnd()}};function et(t){const{sprite:e,aspectRatio:s,scaleProportionally:i}=t,r=m(t.height),o=r>0?r:e.height;let n=r*s;return n<=0?n=e.width:i&&(n*=e.width/e.height),{width:n,height:o}}function qt(t){const{applyRandomOffset:e,sampleAlphaOnly:s}=t;return q([[ce,e],[zt,s]])}const Qt={createComputedParams:t=>t,optionalAttributes:A.optionalAttributes,attributes:{...A.attributes,bitset:{count:1,type:h.UNSIGNED_BYTE,pack:qt},width:{count:1,type:h.HALF_FLOAT,pack:t=>et(t).width},height:{count:1,type:h.HALF_FLOAT,pack:t=>et(t).height},offset:{count:2,type:h.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[m(t),-m(e)]},scale:{count:2,type:h.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:t,scaleY:e})=>[t,e]},angle:{count:1,type:h.UNSIGNED_BYTE,pack:({angle:t})=>xe(t)}}};let oi=class extends xs{constructor(){super(...arguments),this.vertexSpec=Qt}},ms=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0}};const Y={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:rt,pack:({scaleInfo:t},{tileInfo:e})=>Z(t,e)}},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:h.UNSIGNED_BYTE,count:1},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)},offset:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[j(t,16),j(e,16)]},normal:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[j(t,16),j(e,16)]},halfWidth:{type:h.HALF_FLOAT,count:1,pack:({width:t})=>m(.5*t)},referenceHalfWidth:{type:h.HALF_FLOAT,count:1,pack:({referenceWidth:t})=>m(.5*t)}}};let ys=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0}};const Tt=65535;let Jt=class extends O{constructor(t,e,s,i){super(t,e,s,i),this.vertexSpec=Y,this._currentWrite=new ys,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Tt,textured:!1},this._tessParams=new ms,this._initializeTessellator()}writeLineVertices(t,e,s){const i=this._getLines(e);i!=null&&this._writeVertices(t,s,i)}_initializeTessellator(){this._lineTessellator=new Se(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,s){const i=s??T.fromFeatureSetReaderCIM(e);i&&this._writeGeometry(t,e,i)}_writeGeometry(t,e,s,i){t.recordStart(this.instanceId,this.attributeLayout,i),this.writeLineVertices(t,s,e),t.recordEnd()}_getLines(t){return hs(t,Nt(this.evaluatedMeshParams))}_writeVertices(t,e,s){const{_currentWrite:i,_tessellationOptions:r,evaluatedMeshParams:o}=this,{width:n,capType:a,joinType:c,miterLimit:l,hasSizeVV:u}=o,f=m(.5*n);r.halfWidth=f,r.capType=Be(a),r.joinType=Le(c),r.miterLimit=l;const x=!u;i.out=t,i.id=e.getDisplayId(),i.vertexCount=0,i.indexCount=0,i.vertexFrom=t.vertexCount(),i.vertexBounds=x&&f<me?0:1;for(const{line:p,start:d}of s)r.initialDistance=d%Tt,this._lineTessellator.tessellate(p,r,x)}_writeTesselatedVertex(t,e,s,i,r,o,n,a,c,l,u){const{out:f,id:x,vertexBounds:p}=this._currentWrite;return this.hasEffects&&f.recordBounds(t,e,p,p),this._tessParams.extrusionOffsetX=n,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=l,this._tessParams.directionX=r,this._tessParams.directionY=o,this._tessParams.distance=u,this._writeVertex(f,x,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,s){const{out:i}=this._currentWrite;i.indexEnsureSize(3),i.indexWrite(t),i.indexWrite(e),i.indexWrite(s),this._currentWrite.indexCount+=3}};const jt={createComputedParams:t=>t,optionalAttributes:Y.optionalAttributes,attributes:{...Y.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>0},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)}}},yt={createComputedParams:t=>t,optionalAttributes:Y.optionalAttributes,attributes:{...Y.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>q([[Dt,!0]])},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>g(t)}}};let _t=class extends Jt{constructor(){super(...arguments),this.vertexSpec=yt}},Kt=class extends Zt{constructor(t,e,s,i){super(t,e,s,i),this.vertexSpec=jt,this._lineMeshWriter=this._createOutlineWriter(t,e,s,i)}_createOutlineWriter(t,e,s,i){return new _t(t,e,s,i)}_write(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay(),r=this._clip(i);r&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,r),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(r,"esriGeometryPolyline"),e),t.recordEnd())}_clip(t){return t?Xt(t,Nt(this.evaluatedMeshParams)):null}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const st=Qt,_s=yt,gs={createComputedParams:t=>t,optionalAttributes:st.optionalAttributes,attributes:{...st.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>qt(t)},aux1:{count:1,type:h.HALF_FLOAT,pack:t=>et(t).width},aux2:{count:1,type:h.HALF_FLOAT,pack:t=>et(t).height},aux3:{count:2,type:h.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[m(t),m(e)]},aux4:{count:2,type:h.UNSIGNED_BYTE,pack:({scaleX:t,scaleY:e})=>[t*$,e*$]}}},ks={createComputedParams:t=>t,optionalAttributes:st.optionalAttributes,attributes:{...st.attributes,color:_s.attributes.color,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>q([[Dt,!0]])},aux1:{count:1,type:h.HALF_FLOAT,pack:t=>m(.5*t.width)},aux2:{count:1,type:h.HALF_FLOAT,pack:t=>m(.5*t.referenceWidth)},aux3:{count:2,type:h.HALF_FLOAT,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[t,e]},aux4:{count:2,type:h.UNSIGNED_BYTE,packTessellation:({normalX:t,normalY:e})=>[t*$+kt,e*$+kt]}}};class Ss extends _t{constructor(){super(...arguments),this.vertexSpec=ks}}let ni=class extends Kt{constructor(){super(...arguments),this.vertexSpec=gs}_createOutlineWriter(t,e,s,i){return new Ss(t,e,s,i)}_write(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay(),r=this._clip(i);if(!r)return;const o=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,e,r),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(r,"esriGeometryPolyline"),e),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const Ps={optionalAttributes:A.optionalAttributes,createComputedParams:t=>t,attributes:{...A.attributes,...jt.attributes}},vs={optionalAttributes:A.optionalAttributes,createComputedParams:t=>t,attributes:{...A.attributes,...yt.attributes}};class bs extends _t{constructor(){super(...arguments),this.vertexSpec=vs}}class ai extends Kt{constructor(){super(...arguments),this.vertexSpec=Ps}_createOutlineWriter(e,s,i,r){return new bs(e,s,i,r)}_write(e,s,i){const r=i?.asOptimized()??s.readGeometryForDisplay(),o=this._clip(r);if(!o)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(e,s,o),this._lineMeshWriter.writeLineVertices(e,T.fromOptimizedCIM(o,"esriGeometryPolyline"),s),e.recordEnd()}ensurePacked(e,s,i){super.ensurePacked(e,s,i),this._lineMeshWriter.ensurePacked(e,s,i)}enqueueRequest(e,s,i){super.enqueueRequest(e,s,i),this._lineMeshWriter.enqueueRequest(e,s,i)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const ws={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},offset:{type:h.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let ci=class extends O{constructor(){super(...arguments),this.vertexSpec=ws}_write(t,e){t.recordStart(this.instanceId,this.attributeLayout);const s=e.getDisplayId();if(e.geometryType==="esriGeometryPoint"){const i=e.readXForDisplay(),r=e.readYForDisplay();this._writeQuad(t,s,i,r)}else e.geometryType==="esriGeometryMultipoint"&&e.readGeometryForDisplay()?.forEachVertex((i,r)=>{i>=0&&i<=512&&r>=0&&r<=512&&this._writeQuad(t,s,i,r)});t.recordEnd()}_writeQuad(t,e,s,i){const r=t.vertexCount();this._writeVertex(t,e,s,i),t.indexWrite(r+0),t.indexWrite(r+1),t.indexWrite(r+2),t.indexWrite(r+1),t.indexWrite(r+3),t.indexWrite(r+2)}};class $t{static getPlacement(e,s,i,r,o,n){const a=fe(i);return a?(s===-1&&e.invertY(),a.execute(e,i,r,o,n)):null}}const Et=96;class Ts{constructor(e){const{offsetX:s,offsetY:i,postAngle:r,fontSize:o,haloSize:n,outlineSize:a,scaleFactor:c,transforms:l}=e;if(this.offsetX=s,this.offsetY=i,this.postAngle=r,this.fontSize=Math.min(o,Et),this.haloSize=n??0,this.outlineSize=a??0,this.transforms=l,l&&l.infos.length>1){const u=Bt(o,r,!1,s,i,l,!1);this.fontSize=Math.min(u.size,Et);const f=u.size/o;this.haloSize*=f,this.outlineSize*=f,this.postAngle=u.rotation,this.offsetX=u.offsetX,this.offsetY=u.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const Es=28,M=[4,4],K=[16,4],Ms={topLeft:K,topRight:K,bottomLeft:K,bottomRight:K},it=[4,2],v=[4,6],Mt={topLeft:it,topRight:it,bottomLeft:v,bottomRight:v},It={topLeft:it,topRight:v,bottomLeft:it,bottomRight:v},Is={topLeft:v,topRight:v,bottomLeft:M,bottomRight:M},zs={topLeft:M,topRight:M,bottomLeft:v,bottomRight:v},Ds={topLeft:v,topRight:M,bottomLeft:v,bottomRight:M},As={topLeft:M,topRight:v,bottomLeft:M,bottomRight:v},Ys={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:h.UNSIGNED_SHORT,count:2,packPrecisionFactor:rt,packTessellation:({minZoom:t,maxZoom:e})=>[t||0,e||Es]},clipAngle:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:t})=>Ns(t||0)},referenceSymbol:{type:h.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,e)=>{const s=t.isLineLabel||!t.referenceBounds,i=ne(s?"center":e.horizontalAlignment),r=ae(s?"middle":e.verticalAlignment),{offsetX:o,offsetY:n,size:a}=s?{offsetX:0,offsetY:0,size:0}:t.referenceBounds;return[m(o),-m(n),Math.round(m(a)),i+1<<2|r+1]}}},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:t,mapAligned:e})=>q([[ue,t],[le,!!e]])},offset:{type:h.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:i,topRight:r}=t;return[i,r,e,s]}}},textureUV:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:i,topRight:r}=t;return[i,r,e,s]}}},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:t})=>t},fontSize:{type:h.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t})=>Math.round(m(t))},referenceSize:{type:h.UNSIGNED_BYTE,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:e})=>Math.round(m(e??t))},outlineColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>g(t)},haloColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:t})=>g(t)},outlineAndHaloSize:{type:h.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:t,haloSize:e})=>[Math.round(m(t)),Math.round(m(e))]}}};class ui extends O{constructor(){super(...arguments),this.vertexSpec=Ys,this._textMeshParamsPropsInitialized=!1}ensurePacked(e,s,i){super.ensurePacked(e,s,i),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new Ts(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(e,s,i){const r=this._getShaping();if(!r)return;const o=s.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(e,s,r,i);if(i?.nextPath())return i.nextPoint(),this._writeGlyphs(e,o,i.x,i.y,r,0);if(s.geometryType==="esriGeometryPolygon"){const c=s.readCentroidForDisplay();if(!c)return;const[l,u]=c.coords;return this._writeGlyphs(e,o,l,u,r,0)}if(s.geometryType==="esriGeometryMultipoint")return void s.readGeometryForDisplay()?.forEachVertex((c,l)=>this._writeGlyphs(e,o,c,l,r,0));const n=s.readXForDisplay(),a=s.readYForDisplay();return this._writeGlyphs(e,o,n,a,r,0)}_writePlacedTextMarkers(e,s,i,r){const o=r??T.fromFeatureSetReaderCIM(s);if(!o)return;const n=-1,a=$t.getPlacement(o,n,this.evaluatedMeshParams.placement,m(1),e.id,mt());if(!a)return;const c=s.getDisplayId();let l=a.next();for(;l!=null;){const u=l.tx,f=-l.ty,x=-l.getAngle();this._writeGlyphs(e,c,u,f,i,x),l=a.next()}}_getShaping(e){const s=this._textMeshTransformProps,i=this.evaluatedMeshParams;if(!i.glyphs?.glyphs.length)return null;const r=m(s.fontSize),o=m(s.offsetX),n=m(s.offsetY),a=gt(m(i.lineWidth),_e,ye),c=ge*gt(i.lineHeightRatio,.25,4);return de(i.glyphs,{scale:r/ke,angle:s.postAngle,xOffset:o,yOffset:n,horizontalAlignment:i.horizontalAlignment,verticalAlignment:e||i.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:i.decoration,borderLineSizePx:m(i.boxBorderLineSize),hasBackground:!!i.boxBackgroundColor,useCIMAngleBehavior:i.useCIMAngleBehavior})}_writeGlyphs(e,s,i,r,o,n,a,c){const l=this.evaluatedMeshParams,u=this._textMeshTransformProps,f=m(u.fontSize),x=u.haloSize,p=u.outlineSize,d=m(u.offsetX),y=m(u.offsetY),[_,P]=Z(l.scaleInfo,this.getTileInfo());n!==0&&o.setRotation(n);const S=o.bounds,I=i+S.x+d,w=r+S.y-y,N=2*(l.minPixelBuffer?l.minPixelBuffer/f:1),b=Math.max(S.width,S.height)*N;o.textBox&&(e.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding),e.recordBounds(I,w,b,b),this._writeTextBox(e,s,i,r,o.textBox,a,c),e.recordEnd());for(const E of o.glyphs){e.recordStart(this.instanceId,this.attributeLayout,E.textureBinding),e.recordBounds(I,w,b,b);const{texcoords:ot,offsets:B}=E;this._writeQuad(e,s,i,r,{texcoords:ot,offsets:B,fontSize:f,haloSize:x,outlineSize:p,color:g(l.color),isBackground:!1,referenceBounds:a,minZoom:_,maxZoom:P,...c}),e.recordEnd()}n!==0&&o.setRotation(-n)}_writeTextBox(e,s,i,r,o,n,a){const c=this.evaluatedMeshParams,{fontSize:l,haloSize:u,outlineSize:f}=this._textMeshTransformProps,{boxBackgroundColor:x,boxBorderLineColor:p}=c,d={isBackground:!0,fontSize:l,haloSize:u,outlineSize:f,referenceBounds:n,...a};x&&(this._writeQuad(e,s,i,r,{texcoords:Ms,offsets:o.main,color:g(x),...d}),p||(this._writeQuad(e,s,i,r,{texcoords:Is,offsets:o.top,color:g(x),...d}),this._writeQuad(e,s,i,r,{texcoords:zs,offsets:o.bot,color:g(x),...d}),this._writeQuad(e,s,i,r,{texcoords:Ds,offsets:o.left,color:g(x),...d}),this._writeQuad(e,s,i,r,{texcoords:As,offsets:o.right,color:g(x),...d}))),p&&(this._writeQuad(e,s,i,r,{texcoords:Mt,offsets:o.top,color:g(p),...d}),this._writeQuad(e,s,i,r,{texcoords:Mt,offsets:o.bot,color:g(p),...d}),this._writeQuad(e,s,i,r,{texcoords:It,offsets:o.left,color:g(p),...d}),this._writeQuad(e,s,i,r,{texcoords:It,offsets:o.right,color:g(p),...d}))}_writeQuad(e,s,i,r,o){const n=e.vertexCount();this._writeVertex(e,s,i,r,o),e.indexWrite(n+0),e.indexWrite(n+1),e.indexWrite(n+2),e.indexWrite(n+1),e.indexWrite(n+3),e.indexWrite(n+2)}}const Ns=t=>Math.round(t*(254/360)),Bs={createComputedParams:t=>t,optionalAttributes:Y.optionalAttributes,attributes:{...Y.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:t,shouldScaleDash:e,isSDF:s})=>q([[zt,t],[he,e],[pe,s]])},tlbr:{type:h.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:s,height:i}=t,r=e.x+R,o=e.y+R;return[r,o,r+s,o+i]}},accumulatedDistance:{type:h.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},segmentDirection:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},offsetAlongLine:{type:h.HALF_FLOAT,count:1,pack:({offsetAlongLine:t})=>m(t)},capType:{type:h.UNSIGNED_BYTE,count:1,pack:({capType:t})=>{switch(t){case G.Butt:case"butt":return 0;case G.Square:case"square":return 1;case G.Round:case"round":return 2;default:return 0}}}}};class li extends Jt{constructor(e,s,i,r){super(e,s,i,r),this.vertexSpec=Bs,this._tessellationOptions.textured=!0}_write(e,s,i){const r=i??T.fromFeatureSetReaderCIM(s);if(!r)return;const{sprite:o}=this.evaluatedMeshParams;this._writeGeometry(e,s,r,o?.textureBinding)}}let Ls=class xt{static from(e){return"width"in e?this.fromSimpleMeshParams(e):this.fromComplexMeshParams(e)}static fromSimpleMeshParams(e){const s=new xt(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects),{type:i,width:r,height:o,angle:n,alignment:a,outlineSize:c,referenceSize:l,sprite:u,overrideOutlineColor:f}=e;return s.rawWidth=m(r),s.rawHeight=m(o),s.angle=n,s.alignment=a,s.outlineSize=m(c),s.referenceSize=m(l),s.overrideOutlineColor=f,s.offsetX=m(e.offsetX),s.offsetY=m(e.offsetY),i!=="simple"||u.sdf||(s.rawWidth=u.width,s.rawHeight=u.height),s._computeSize(e,!1),s}static fromComplexMeshParams(e){const s=new xt(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects);let{alignment:i,transforms:r,size:o,scaleX:n,anchorX:a,anchorY:c,angle:l,colorLocked:u,frameHeight:f,widthRatio:x,offsetX:p,offsetY:d,outlineSize:y,referenceSize:_,scaleFactor:P,sizeRatio:S,isAbsoluteAnchorPoint:I,rotateClockwise:w,scaleSymbolsProportionally:N,sprite:b}=e;if(r&&r.infos.length>0){const B=Bt(o,l,w,p,d,r);o=B.size,l=B.rotation,p=B.offsetX,d=B.offsetY,w=!1}P&&(o*=P,p*=P,d*=P);const E=n*(b.width/b.height);s.alignment=i,s.rawHeight=m(o),s.rawWidth=s.rawHeight*E,s.referenceSize=m(_),s.sizeRatio=S,s.sdfDecodeCoeff=(b.sdfDecodeCoeff??1)*S,s.angle=l,s.rotateClockwise=w,s.anchorX=a,s.anchorY=c,s.offsetX=m(p),s.offsetY=m(d),I&&o&&(b.sdf?s.anchorX=a/(o*x):s.anchorX=a/(o*E),s.anchorY=c/o);const ot=N&&f?o/f:1;return s.outlineSize=y===0||isNaN(y)?0:m(y)*ot,s.scaleSymbolsProportionally=N,s.colorLocked=u,s._computeSize(e,!0),s}constructor(e,s,i,r,o,n,a){this.sprite=e,this.color=s,this.outlineColor=i,this.minPixelBuffer=r,this.placement=o,this.scaleInfo=n,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=Lt.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(e,s){const{sprite:i,hasSizeVV:r}=e,o=!!i.sdf,n=i.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:l,outlineSize:u}=this,f=l*(o?1/(1-n):1),x=a*f,p=c*f;if(o&&!r){const N=s&&a>c?x:a,b=c,E=u+2*1;this.computedWidth=Math.min(N+E,x),this.computedHeight=Math.min(b+E,p)}else this.computedWidth=x,this.computedHeight=p;const d=o?Math.max(i.width,i.height)/Math.max(x,p):1,y=.5*(x-this.computedWidth)*d,_=.5*(p-this.computedHeight)*d,P=i.rect.x+R+y,S=i.rect.y+R+_,I=P+i.width-2*y,w=S+i.height-2*_;this.texXmin=Math.floor(P),this.texYmin=Math.floor(S),this.texXmax=Math.ceil(I),this.texYmax=Math.ceil(w),this.computedWidth*=(this.texXmax-this.texXmin)/(I-P),this.computedHeight*=(this.texYmax-this.texYmin)/(w-S),this.anchorX*=x/this.computedWidth,this.anchorY*=p/this.computedHeight}};const Gs=3.14159265359/180,Rs=128/Math.PI;function Fs(t,e){return t%=e,Math.abs(t>=0?t:t+e)}function Os(t){return Fs(t*Rs,256)}function Cs(t,e,s,i,r=!1){const o=Me(),n=r?1:-1;return Ie(o),(e||s)&&ze(o,o,[e,-s]),i&&De(o,o,n*Gs*-i),o}const Ws={createComputedParams:t=>Ls.from(t),optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:rt,pack:({scaleInfo:t},{tileInfo:e})=>Z(t,e)}},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({sprite:t,alignment:e,scaleSymbolsProportionally:s,overrideOutlineColor:i,colorLocked:r})=>{let o=0;return t.sdf&&(o|=W(C.bitset.isSDF)),e===Lt.MAP&&(o|=W(C.bitset.isMapAligned)),s&&(o|=W(C.bitset.scaleSymbolsProportionally)),i&&(o|=W(C.bitset.overrideOutlineColor)),r&&(o|=W(C.bitset.colorLocked)),o}},offset:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({angle:t,computedWidth:e,computedHeight:s,anchorX:i,anchorY:r,offsetX:o,offsetY:n,rotateClockwise:a})=>{const c=Cs(0,o,n,-t,a),l=-(.5+i)*e,u=-(.5-r)*s,f=[l,u],x=[l+e,u],p=[l,u+s],d=[l+e,u+s];return Q(f,f,c),Q(x,x,c),Q(p,p,c),Q(d,d,c),[f,x,p,d]}}},textureUV:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:t,texXmin:e,texYmax:s,texYmin:i})=>[[e,i],[t,i],[e,s],[t,s]]}},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)},outlineColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>g(t)},sizing:{type:h.UNSIGNED_BYTE,count:4,pack:({rawWidth:t,rawHeight:e,outlineSize:s,referenceSize:i})=>{const r=Math.max(t,e);return[ut(r,128),ut(s,128),ut(i,128),0]}},placementAngle:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:t})=>Os(t)},sdfDecodeCoeff:{type:h.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:t})=>t}}};class hi extends O{constructor(){super(...arguments),this.vertexSpec=Ws}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(e,s,i){const r=this.evaluatedMeshParams.sprite?.textureBinding,o=s.getDisplayId();e.recordStart(this.instanceId,this.attributeLayout,r);const n=this.evaluatedMeshParams.minPixelBuffer,a=Math.max(this.evaluatedMeshParams.computedWidth,n),c=Math.max(this.evaluatedMeshParams.computedHeight,n),l=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,u=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,f=this.evaluatedMeshParams.offsetX+l,x=-this.evaluatedMeshParams.offsetY+u;if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(e,s,i,a,c);else if(i?.nextPath()){i.nextPoint();const p=i.x,d=i.y;e.recordBounds(p+f,d+x,a,c),this._writeQuad(e,o,p,d)}else if(s.geometryType==="esriGeometryPolygon"){const p=s.readCentroidForDisplay();if(!p)return;const[d,y]=p.coords;e.recordBounds(d+f,y+x,a,c),this._writeQuad(e,o,d,y)}else if(s.geometryType==="esriGeometryPoint"){const p=s.readXForDisplay(),d=s.readYForDisplay();e.recordBounds(p+f,d+x,a,c),this._writeQuad(e,o,p,d)}else s.readGeometryForDisplay()?.forEachVertex((p,d)=>{e.recordBounds(p+f,d+x,a,c),Math.abs(p)>J||Math.abs(d)>J||this._writeQuad(e,o,p,d)});e.recordEnd()}_writePlacedMarkers(e,s,i,r,o){const n=i??T.fromFeatureSetReaderCIM(s)?.clone();if(!n)return;const a=-1,c=$t.getPlacement(n,a,this.evaluatedMeshParams.placement,m(1),e.id,mt());if(!c)return;const l=s.getDisplayId();let u=c.next();const f=this.evaluatedMeshParams.offsetX,x=-this.evaluatedMeshParams.offsetY;for(;u!=null;){const p=u.tx,d=-u.ty;if(Math.abs(p)>J||Math.abs(d)>J){u=c.next();continue}const y=-u.getAngle();e.recordBounds(p+f,d+x,r,o),this._writeQuad(e,l,p,d,y),u=c.next()}}_writeQuad(e,s,i,r,o){const n=e.vertexCount(),a=o==null?null:{placementAngle:o};this._writeVertex(e,s,i,r,a),e.indexWrite(n+0),e.indexWrite(n+1),e.indexWrite(n+2),e.indexWrite(n+1),e.indexWrite(n+3),e.indexWrite(n+2)}}const Us={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:h.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>0},offset:{type:h.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:t})=>{const e=m(t),s=-e/2,i=-e/2;return[[s,i],[s+e,i],[s,i+e],[s+e,i+e]]}}},texCoords:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:h.UNSIGNED_BYTE,count:2,pack:({size:t})=>[t,t]},referenceSize:{type:h.UNSIGNED_BYTE,count:1,pack:({size:t})=>m(t)},zoomRange:{type:h.UNSIGNED_BYTE,count:2,pack:({scaleInfo:t},{tileInfo:e})=>Z(t,e)}}};class pi extends O{constructor(){super(...arguments),this.vertexSpec=Us}_write(e,s){const i=s.getDisplayId(),r=this.evaluatedMeshParams.minPixelBuffer,o=Math.max(m(this.evaluatedMeshParams.size),r);let n,a;if(s.geometryType==="esriGeometryPoint")n=s.readXForDisplay(),a=s.readYForDisplay();else{const l=s.readCentroidForDisplay();if(!l)return;n=l?.coords[0],a=l?.coords[1]}e.recordStart(this.instanceId,this.attributeLayout),e.recordBounds(n,a,o,o);const c=e.vertexCount();this._writeVertex(e,i,n,a),e.indexWrite(c+0),e.indexWrite(c+1),e.indexWrite(c+2),e.indexWrite(c+1),e.indexWrite(c+3),e.indexWrite(c+2),e.recordEnd()}}export{pi as $,W as C,ui as F,ci as I,Es as J,ai as M,li as O,hi as Q,Z as R,xs as X,Re as Y,oi as a,ni as b,Zt as c,O as d,g,Kt as k,ri as m,Jt as y};
