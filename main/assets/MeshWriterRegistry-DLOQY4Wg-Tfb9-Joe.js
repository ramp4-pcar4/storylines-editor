import{i as P}from"./TechniqueType-GommNIdJ-ByYTgVOB.js";import{eQ as L,d6 as C,ja as ke,z as Se,c as Ae,jf as Le,a8 as De,cX as ze}from"./main-D7vwjMDX.js";import{K as ee,n as O}from"./definitions-CBIQmVpq-o3EUznKY.js";import{Z as Ee,i as Te,o as Re,a as Be,e as _e,m as Fe,f as Ce,N as Oe,X as Ge,w as We,O as je,K as Ve,T as Ne,S as Ze,b as qe,U as ge,n as Q,_ as Ye,Y as Xe,A as T}from"./PieChartMeshWriter-tjXifLuk-C2z9weQe.js";import{f as re,r as R,a as E,I as Qe}from"./UpdateTracking2D-CaPtqow6-FgCuYeDz.js";import{I as S}from"./enums-DBi1-Mm2-CUS1pvQe.js";import{j as H,q as oe}from"./mat2d-BQA-1WB--Pnyy0dhf.js";import{l as B}from"./mat2df32-BCnkwMW8-BLRY8i4P.js";import{L as ae,m as A,k as ce,j as U,b as He,v as le}from"./vec2-BnynUbeJ-CKtGJQAy.js";import{e as G}from"./vec2f32-CVhmN3Me-DxoqVD7C.js";import{o as D}from"./vec2f64-CEUyUoff-BBc0aQ6D.js";import{C as Ue,s as he}from"./featureConversionUtils-DRaHTjrY-WqHR8MaP.js";import{c as K}from"./OptimizedGeometry-1qDYm3YK-PK8vf3pk.js";import{U as Ke,W as $e}from"./CIMSymbolHelper-Bcp4nGf3-BeRRWej_.js";import{r as ue}from"./BoundingBox-D9JxeQeA-SaxmeIkg.js";import{p as de}from"./dataViewUtils-xig9T3UA-00WNyMBm.js";import{L as W}from"./rasterizingUtils-B8CPqgVl-UbSfRfRi.js";import{r as xe,f as Je}from"./grouping-Bq1BCR7L-BjJpaILo.js";import{m as et}from"./utils-BddLNd1v-DogSM8nE.js";import{a as tt}from"./FeatureMetadata-X_4q5T4e-DK61-qo-.js";let st=class extends Xe{};function it(n){const{sprite:e,isMapAligned:t,colorLocked:i,scaleSymbolsProportionally:s,isStroke:o}=n;let r=0;return t&&(r|=T(R.bitset.isMapAligned)),i&&(r|=T(R.bitset.colorLocked)),e.sdf&&(r|=T(R.bitset.isSDF)),s&&(r|=T(R.bitset.scaleSymbolsProportionally)),o&&(r|=T(R.bitset.isStroke)),r}let nt=class extends st{get vertexSpec(){return{createComputedParams:n=>{let{pixelDimensions:e,texelDimensions:t,baseSize:i,referenceSize:s,strokeWidth:o,sizeRatio:r}=n;e||(e=n.sprite.sdf?[0,0]:[n.sprite.width,n.sprite.height]),t||(t=n.sprite.sdf?[0,0]:e),i=L(i),s=L(s),o=L(o);const a=(n.sprite.sdfDecodeCoeff??1)*r;return{...n,pixelDimensions:e,texelDimensions:t,baseSize:i,referenceSize:s,strokeWidth:o,sdfDecodeCoeff:a}},optionalAttributes:{zoomRange:{type:S.SHORT,count:2,packPrecisionFactor:ee,pack:({scaleInfo:n},{tileInfo:e})=>ge(n,e)}},attributes:{id:{type:S.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:S.UNSIGNED_BYTE,count:1,pack:it},pos:{type:S.SHORT,count:2,pack:"position",packPrecisionFactor:1},offset:{type:S.FLOAT,count:2,packAlternating:{count:4,pack:n=>{const e=n.texelDimensions;return[[-.5*e[0],-.5*e[1]],[.5*e[0],-.5*e[1]],[-.5*e[0],.5*e[1]],[.5*e[0],.5*e[1]]]}}},uv:{type:S.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:n,texXmin:e,texYmax:t,texYmin:i})=>[[e,i],[n,i],[e,t],[n,t]]}},animationPointerAndBaseSizeAndReferenceSize:{type:S.UNSIGNED_SHORT,count:4,packPrecisionFactor:1,pack:({animations:n,baseSize:e,referenceSize:t})=>[n.dataColumn,n.dataRow,e,t]},sizing:{type:S.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:n,pixelDimensions:e,baseSize:t,sprite:i,sizeRatio:s})=>{const o=Math.max(t*i.width/i.height,t),r=i.sdfDecodeCoeff*o*s;return[e[0],e[1],n,r]}},angle:{type:S.BYTE,count:1,packTessellation:({angle:n})=>n}}}}_write(n,e){const t=this.evaluatedMeshParams.sprite,{textureBinding:i}=t;n.recordStart(this.instanceId,this.attributeLayout,i);const s=e.getDisplayId();if(e.geometryType==="esriGeometryPolygon"){const o=e.readCentroidForDisplay();if(!o)return;const[r,a]=o.coords;this._writeQuad(n,s,r,a)}else if(e.geometryType==="esriGeometryPoint"){const o=e.readXForDisplay(),r=e.readYForDisplay();this._writeQuad(n,s,o,r)}else{const o=e.readGeometryForDisplay();if(o){const{angleToLine:r}=this.evaluatedMeshParams;if(r){let a=!0,c=null,u=null;o.forEachVertex((l,d)=>{if(c!=null&&u!=null){const h=Math.atan2(d-u,l-c)/Qe;a&&(this._writeQuad(n,s,c,u,h),a=!1),this._writeQuad(n,s,l,d,h)}c=l,u=d})}else o.forEachVertex((a,c)=>{this._writeQuad(n,s,a,c)})}}n.recordEnd()}_writeQuad(n,e,t,i,s=0){const o=this.evaluatedMeshParams.sprite,{rect:r}=o,a=r.x+O,c=r.y+O,u=r.x+r.width-O,l=r.y+r.height-O,d=n.vertexCount();n.recordBounds(t,i,64,64);const h={texXmin:a,texYmin:c,texXmax:u,texYmax:l,angle:s};for(let y=0;y<4;y++)this._writeVertex(n,e,t,i,h);n.indexEnsureSize(6),n.indexWrite(d),n.indexWrite(d+1),n.indexWrite(d+2),n.indexWrite(d+1),n.indexWrite(d+3),n.indexWrite(d+2)}};function fe(n,e,t){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n}function ve(n,e){return Math.sqrt(n*n+e*e)}function me(n){const e=ve(n[0],n[1]);n[0]/=e,n[1]/=e}function rt(n,e){return ve(n[0]-e[0],n[1]-e[1])}function ot(n,e){return n[e+1]}function Me(n){return n.length-1}function at(n){let e=0;for(let t=0;t<Me(n);t++)e+=ct(n,t);return e}function ct(n,e,t=1){let[i,s]=ot(n,e);return[i,s]=[Math.round(i),Math.round(s)],Math.sqrt(i*i+s*s)*t}class Z{constructor(e,t,i,s,o){this._segments=e,this._index=t,this._distance=i,this._xStart=s,this._yStart=o,this._done=!1}static create(e){return new Z(e,0,0,e[0][0],e[0][1])}clone(){return new Z(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(this._distance===0||e._distance===1)||e._index===this._index+1&&(this._distance===1||e._distance===0)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){const e=this.dy,t=(0*e+-1*-this.dx)/(1*this.length);let i=Math.acos(t);return e>0&&(i=2*Math.PI-i),i}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:e,dy:t}=this;return Math.sqrt(e*e+t*t)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<Me(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,t){const i=this.backwardLength;if(e<=i)return this._distance=(i-e)/this.length,this;let s=this.backwardLength;for(;this.prev();){if(s+this.length>e)return this._seekBackwards(e-s);s+=this.length}return this._distance=0,t?this:null}seek(e,t=!1){if(e<0)return this._seekBackwards(Math.abs(e),t);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let i=this.remainingLength;for(;this.next();){if(i+this.length>e)return this.seek(e-i,t);i+=this.length}return this._distance=1,t?this:null}}function $(n,e,t,i=!0){const s=at(n),o=Z.create(n),r=s/2;if(!i)return o.seek(r),void(Math.abs(o.x)<W&&Math.abs(o.y)<W&&t(o.clone(),0,r+0*e,s));const a=Math.max((s-e)/2,0),c=Math.floor(a/e),u=r-c*e;o.seek(u);for(let l=-c;l<=c;l++)Math.abs(o.x)<W&&Math.abs(o.y)<W&&t(o.clone(),l,r+l*e,s),o.seek(e)}function J(n,e){const t=e;for(let i=0;i<n.length;i++){let s=n[i];lt(s,t);const o=[];o.push(s[0]);for(let r=1;r<s.length;r++){const[a,c]=s[r-1],[u,l]=s[r],d=u-a,h=l-c;o.push([d,h])}n[i]=o,s=o}return n}function lt(n,e){if(e<=0)return;const t=n.length;if(t<3)return;const i=[];let s=0;i.push(0);for(let l=1;l<t;l++)s+=rt(n[l],n[l-1]),i.push(s);e=Math.min(e,.2*s);const o=[];o.push(n[0][0]),o.push(n[0][1]);const r=n[t-1][0],a=n[t-1][1],c=fe([0,0],n[0],n[1]);me(c),n[0][0]+=e*c[0],n[0][1]+=e*c[1],fe(c,n[t-1],n[t-2]),me(c),n[t-1][0]+=e*c[0],n[t-1][1]+=e*c[1];for(let l=1;l<t;l++)i[l]+=e;i[t-1]+=e;const u=.5*e;for(let l=1;l<t-1;l++){let d=0,h=0,y=0;for(let m=l-1;m>=0&&!(i[m+1]<i[l]-u);m--){const f=u+i[m+1]-i[l],p=i[m+1]-i[m],_=i[l]-i[m]<u?1:f/p;if(Math.abs(_)<1e-6)break;const g=_*_,M=_*f-.5*g*p,v=_*p/e,x=n[m+1],w=n[m][0]-x[0],I=n[m][1]-x[1];d+=v/M*(x[0]*_*f+.5*g*(f*w-p*x[0])-g*_*p*w/3),h+=v/M*(x[1]*_*f+.5*g*(f*I-p*x[1])-g*_*p*I/3),y+=v}for(let m=l+1;m<t&&!(i[m-1]>i[l]+u);m++){const f=u-i[m-1]+i[l],p=i[m]-i[m-1],_=i[m]-i[l]<u?1:f/p;if(Math.abs(_)<1e-6)break;const g=_*_,M=_*f-.5*g*p,v=_*p/e,x=n[m-1],w=n[m][0]-x[0],I=n[m][1]-x[1];d+=v/M*(x[0]*_*f+.5*g*(f*w-p*x[0])-g*_*p*w/3),h+=v/M*(x[1]*_*f+.5*g*(f*I-p*x[1])-g*_*p*I/3),y+=v}o.push(d/y),o.push(h/y)}o.push(r),o.push(a);for(let l=0,d=0;l<t;l++)n[l][0]=o[d++],n[l][1]=o[d++]}const j=1,z=0,ht=128,ut=Le(n=>{let e=0;if(n===0)return 1/0;for(;!(n%2);)e++,n/=2;return e});class dt extends _e{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,i,s){if(this._zoomLevel=s||0,i!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const o=t.readXForDisplay(),r=t.readYForDisplay();this._writePoint(e,o,r,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const o=t.readCentroidForDisplay();if(!o)return;const[r,a]=o.coords;this._writePoint(e,r,a,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:t}=this.evaluatedMeshParams;return[e==="center"?0:e==="right"?-1:1,t==="middle"?0:t==="bottom"?-1:1]}_createLineLabelMetric(e,t,i,s){const o=re(e),[r,a]=this._getMetricDir(),c=this.evaluatedMeshParams.scaleInfo?.maxScale??0,u=this.evaluatedMeshParams.scaleInfo?.minScale??0;return new de(o,t,i,r,a,c,u,s??null)}_writePoint(e,t,i,s){const o=this._getShaping();if(!o)return;const r=s.getDisplayId(),a=Ke(this.evaluatedMeshParams.horizontalAlignment),c=$e(this.evaluatedMeshParams.verticalAlignment),u=this.evaluatedMeshParams.scaleInfo?.maxScale??0,l=this.evaluatedMeshParams.scaleInfo?.minScale??0,d=re(s.getDisplayId()),h=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new de(d,t,i,a,c,u,l,h)),this._writeGlyphs(e,r,t,i,o,0,h),e.metricBoxWrite(o.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:i,verticalAlignment:s}=this.evaluatedMeshParams,o=this.evaluatedMeshParams.repeatLabelDistance||128,r=this._getShaping("middle");if(!r)return;const a=(u,l,d,h)=>this._placeSubdivGlyphs(u,l,d,h),c=(r.bounds.width+o)/(1<<j);this._current={out:e,id:t.getDisplayId(),shaping:r,zoomRange:ge(i,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null},this._verticalPlacement=s==="bottom"?"above":s==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,a,c):this._writeCenterAlong(t,a,c)}_writeAboveAndBelowAlong(e,t,i){const{repeatLabel:s}=this.evaluatedMeshParams,{shaping:o}=this._current,r=o.bounds.halfHeight,a=e.readGeometryForDisplay();if(!a)return;const c=new K;Ue(c,a,!1,!1,"esriGeometryPolyline",1);const u=pe(new K,c,r),l=pe(new K,c,-r),d=he(l,"esriGeometryPolyline",!1,!1),h=he(u,"esriGeometryPolyline",!1,!1),y=J(h.paths,o.bounds.width),m=J(d.paths,o.bounds.width);this._current.offsetDirection="above";for(const f of y)$(f,i,t,!!s);this._current.offsetDirection="below";for(const f of m)$(f,i,t,!!s)}_writeCenterAlong(e,t,i){const{repeatLabel:s}=this.evaluatedMeshParams,{shaping:o}=this._current,r=J(e.readLegacyGeometryForDisplay().paths,o.bounds.width);for(const a of r)$(a,i,t,!!s)}_placeSubdivGlyphs(e,t,i,s){const{allowOverrun:o,labelPosition:r,repeatLabelDistance:a}=this.evaluatedMeshParams,c=this._current.zoomRange[0],u=ut(t),l=this._current.shaping.bounds.width/(1<<j),d=Math.sqrt(a||ht)/(1<<j),h=Math.min(i,s-i),y=this._current.shaping.isMultiline?Q:Math.log2(h/(d+l/2)),m=t===0?y:Math.min(u,y),f=Math.max(c,this._zoomLevel+j-m),p=this._zoomLevel-f,_=this._current.shaping.bounds.width/2*2**p;this._current.shaping.isMultiline?t===0&&this._placeStraight(e,f):o&&p<0?this._placeStraightAlong(e,c):r==="parallel"?this._placeStraightAlong(e,f):r==="curved"&&this._placeCurved(e,f,_)}_placeStraight(e,t){const{out:i,id:s,shaping:o,referenceBounds:r}=this._current,{x:a,y:c}=e;i.metricStart(this._createLineLabelMetric(s,a,c)),i.metricBoxWrite(o.boundsT);const u=e.angle*(180/Math.PI)%360,l=(e.angle*(180/Math.PI)+180)%360;this._writeGlyphs(i,s,a,c,o,0,r,{clipAngle:u,mapAligned:!0,isLineLabel:!0,minZoom:t}),this._writeGlyphs(i,s,a,c,o,0,r,{clipAngle:l,mapAligned:!0,isLineLabel:!0,minZoom:t}),i.metricEnd()}_placeCurved(e,t,i){const{out:s,id:o}=this._current;s.metricStart(this._createLineLabelMetric(o,e.x,e.y));const r=e.clone(),a=e.angle*(180/Math.PI)%360,c=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(r,t,1,a),this._placeBack(e,r,t,i,1,a),this._placeForward(e,r,t,i,1,a)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(r,t,0,c),this._placeBack(e,r,t,i,0,c),this._placeForward(e,r,t,i,0,c)),s.metricEnd()}_placeStraightAlong(e,t){const{out:i,id:s,shaping:o,zoomRange:r,referenceBounds:a}=this._current,{boxBorderLineColor:c,boxBackgroundColor:u}=this.evaluatedMeshParams,l=e.clone(),d=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360,y=o.glyphs.length>0&&!(!c&&!u);if(i.metricStart(this._createLineLabelMetric(s,e.x,e.y)),y){const m=Math.max(t,r[0],0),f=Math.min(Q,r[1]),p=H(B(),-e.angle),_={minZoom:m,maxZoom:f,clipAngle:d,mapAligned:!0,isLineLabel:!0},g=L(this.evaluatedMeshParams.offsetX),M=L(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const v=G(g,-1*M),[x,w]=o.shapeBackground(oe(B(),p,v));i.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding);const I=2*Math.max(x.width,x.height);i.recordBounds(e.x+x.x,e.y+x.y,I,I),this._writeTextBox(i,s,e.x,e.y,w,a,_),i.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const v=G(g,M),[x,w]=o.shapeBackground(oe(B(),p,v));_.clipAngle=h,i.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding);const I=2*Math.max(x.width,x.height);i.recordBounds(e.x+x.x,e.y+x.y,I,I),this._writeTextBox(i,s,e.x,e.y,w,a,_),i.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(l,t,1,d,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(l,t,0,h,!0),i.metricEnd()}_placeBack(e,t,i,s,o,r){const a=e.clone();let c=e.backwardLength+z;for(;a.prev()&&!(c>=s);)this._placeOnSegment(a,t,c,i,-1,o,r),c+=a.length+z}_placeForward(e,t,i,s,o,r){const a=e.clone();let c=e.remainingLength+z;for(;a.next()&&!(c>=s);)this._placeOnSegment(a,t,c,i,1,o,r),c+=a.length+z}_placeFirst(e,t,i,s,o=!1){const{out:r,id:a,shaping:c,zoomRange:u,referenceBounds:l}=this._current,d=c.glyphs,h=L(this.evaluatedMeshParams.offsetX),y=L(this.evaluatedMeshParams.offsetY),m=G(h,y),f=H(B(),-e.angle);ae(m,m,f);for(const p of d){const _=p.x>c.bounds.x?i:1-i,g=_*e.remainingLength+(1-_)*e.backwardLength,M=Math.abs(p.x+p.width/2-c.bounds.x),v=Math.max(0,this._zoomLevel+Math.log2(M/(g+z))),x=Math.max(t,o?0:v);if(p.maxZoom=Math.min(u[1],Q),p.angle=e.angle+(1-i)*Math.PI,p.minZoom=Math.max(u[0],x),this._writeLineGlyph(r,a,e.x,e.y,c.bounds,p,s,l,!0),(i||this._current.offsetDirection)&&this._isVisible(p.minZoom,p.maxZoom)){const w=new ue(p.bounds.x+m[0],p.bounds.y+m[1],p.bounds.width,p.bounds.height);r.metricBoxWrite(w)}}}_placeOnSegment(e,t,i,s,o,r,a){const{out:c,id:u,shaping:l,referenceBounds:d}=this._current,h=l.glyphs,y=e.dx/e.length,m=e.dy/e.length,f={x:e.x+i*-o*y,y:e.y+i*-o*m},p=L(this.evaluatedMeshParams.offsetX),_=L(this.evaluatedMeshParams.offsetY),g=G(p,_),M=H(B(),-e.angle);ae(g,g,M);for(const v of h){const x=v.x>l.bounds.x?r:1-r;if(!(x&&o===1||!x&&o===-1))continue;const w=Math.abs(v.x+v.width/2-l.bounds.x),I=Math.max(0,this._zoomLevel+Math.log2(w/i)-.1),we=Math.max(s,this._zoomLevel+Math.log2(w/(i+e.length+z)));if(I!==0&&(v.angle=e.angle+(1-r)*Math.PI,v.minZoom=we,v.maxZoom=I,this._writeLineGlyph(c,u,f.x,f.y,l.bounds,v,a,d,!0),(r||this._current.offsetDirection)&&this._isVisible(v.minZoom,v.maxZoom))){const Ie=new ue(v.bounds.x+g[0],v.bounds.y+g[1],v.bounds.width,v.bounds.height);c.metricBoxWrite(Ie)}}}_writeLineGlyph(e,t,i,s,o,r,a,c,u){const l=i+o.x,d=s+o.y,h=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),y=Math.max(o.width,o.height)*h;e.recordStart(this.instanceId,this.attributeLayout,r.textureBinding),e.recordBounds(l,d,y,y);const{texcoords:m,offsets:f}=r,{fontSize:p,haloSize:_,outlineSize:g}=this._textMeshTransformProps;this._writeQuad(e,t,i,s,{texcoords:m,offsets:f,fontSize:p,haloSize:_,outlineSize:g,color:Ye(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:c,minZoom:Math.max(this._current.zoomRange[0],r.minZoom),maxZoom:Math.min(this._current.zoomRange[1],r.maxZoom),clipAngle:a,mapAligned:u,isLineLabel:!0}),e.recordEnd()}_isVisible(e,t){const i=Math.floor(this._zoomLevel*ee)/ee;return e<=i&&i<=t}}function pe(n,e,t){const{coords:i,lengths:s}=e,o=D(),r=D(),a=D(),c=D(),u=D(),l=D(),d=2;let h=0;for(let y=0;y<s.length;y++){const m=s[y];for(let f=0;f<m;f++){const p=d*(f+h-1),_=d*(f+h),g=d*(f+h+1);f>0?A(o,i[p],i[p+1]):A(o,0,0),A(r,i[_],i[_+1]),f<m-1?A(a,i[g],i[g+1]):A(a,0,0),f===0?A(c,0,0):(ce(c,r,o),U(c,c),A(c,c[1],-c[0])),f===m-1?A(u,0,0):(ce(u,a,r),U(u,u),A(u,u[1],-u[0])),He(l,c,u),U(l,l);const M=l[0]*u[0]+l[1]*u[1];M!==0&&le(l,l,M),le(l,l,t),n.coords.push(r[0]+l[0],r[1]+l[1])}n.lengths.push(m),h+=m}return n}function Y(n){return n instanceof X?n:typeof n=="object"&&"type"in n?pt[n.type].hydrate(n):new F(n)}class X{constructor(e){this.inputs=e}encode(){const e=[];for(const t of this.inputs)e.push(...t.encode());return e.push(...this.instructions),e}}class F extends X{constructor(e){super([]),this.value=e}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[e,t,i,s]=this.value;return s!=null?E.vector4.encode([e,t||0,i||0,s]):E.vector3.encode([e,t||0,i||0])}return E.scalar.encode(this.value)}}let ft=class te extends X{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new te(e,Y(e.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const e=this._parent.simplify();if(!(e instanceof F))return this;const[t,i,s,o]=e.value,r=this._config.translation.from[0],a=this._config.translation.from[1],c=this._config.rotation.from,u=this._config.scale.from;if(r===this._config.translation.to[0]&&a===this._config.translation.to[1]&&c===this._config.rotation.to&&u===this._config.scale.to){const l=s+c,d=o*u,h=Math.sin(s),y=Math.cos(s);return new F([y*o*r-h*o*a+t,h*o*r+y*o*a+i,l,d])}return new te(this._config,e)}get instructions(){return E.animatedTransform.encode(this._config)}},mt=class se extends X{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new se(e,Y(e.parent))}simplify(){const e=this._parent.simplify();if(!(e instanceof F))return this;const[t,i,s,o]=e.value,r=this._config.color.from[0],a=this._config.color.from[1],c=this._config.color.from[2];let u=this._config.color.from[3];const l=this._config.opacity.from;return r===this._config.color.to[0]&&a===this._config.color.to[1]&&c===this._config.color.to[2]&&u===this._config.color.to[3]&&l===this._config.opacity.to?(u*=l,new F([t*r,i*a,s*c,o*u])):new se(this._config,e)}get instructions(){return E.animatedColor.encode(this._config)}};const pt={AnimatedTransform:ft,AnimatedColor:mt};function yt(n){return Pe(n.map(e=>b(e)).map(e=>Y(e).simplify()))}function _t(n){const e=[];return e.push(n.transform),e.push(n.fromColor),e.push(n.toColor),e.push(n.colorMix),e.push(n.toOpacity),e.push(n.opacityMix),e}function Pe(n){const e=[],t=[];let i=0;for(const s of n){const o=[...s.encode(),...E.ret.encode()];e.push([i+n.length,0,0,0]),t.push(...o),i+=o.length}return[...e,...t]}async function ie(n,e){const t=n;let i;if(typeof t=="number"||typeof t=="string"||typeof t=="boolean")i=t;else if(Array.isArray(t))i=await Promise.all(t.map(s=>ie(s,e)));else if(typeof t=="object")if("valueExpressionInfo"in t){const{valueExpressionInfo:s}=t,{expression:o}=s;i={...t,computed:await e.createComputedField({expression:o})}}else{i={};for(const s in t)i[s]=await ie(t[s],e)}return i}function b(n,e,t){function i(r){if(!("computed"in r))return r;let a=r.computed.readWithDefault(e,t,[255*r.defaultValue[0],255*r.defaultValue[1],255*r.defaultValue[2],r.defaultValue[3]]);if(typeof a=="string"){const c=ze.fromString(a);c&&(a=[c.r,c.g,c.b,c.a])}return a}const s=n;let o;if(typeof s=="number"||typeof s=="string"||typeof s=="boolean")o=s;else if(Array.isArray(s))o=s.map(r=>b(r,e,t));else if(typeof s=="object")if("type"in s&&s.type!=null&&s.type==="Process")switch(s.op){case"ArcadeColor":{const r=b(s.value,e,t);V(Array.isArray(r)&&r.length===4),o=[r[0]/255,r[1]/255,r[2]/255,r[3]]}break;case"Transparency":{const r=b(s.value,e,t);V(typeof r=="number"),o=1-r/100}break;case"Divide":case"Add":{const r=b(s.left,e,t);V(typeof r=="number");const a=b(s.right,e,t);switch(V(typeof a=="number"),s.op){case"Divide":o=r/a;break;case"Add":o=r+a}}break;case"Random":{const r=b(s.seed,e,t),a=b(s.min,e,t),c=b(s.max,e,t),u=e.getObjectId(),l=xe(u||0);o=a+Je(l,r)*(c-a)}break;case"Cond":{const r=b(s.condition,e,t),a=b(s.ifTrue,e,t),c=b(s.ifFalse,e,t);o=r?a:c}break;case"MatchWinding":{const r=b(s.sign,e,t);let a=b(s.angle,e,t);if(r>0)for(;a<0;)a+=2*Math.PI;else for(;a>0;)a-=2*Math.PI;o=a}}else if("computed"in s)o=i(s);else{o={};for(const r in s)o[r]=b(s[r],e,t)}return o}function*k(n){const e=n;if(Array.isArray(e))for(const t of e)yield*k(t);else if(typeof e=="object")if("type"in e&&e.type!=null&&e.type==="Process")switch(e.op){case"ArcadeColor":case"Transparency":yield*k(e.value);break;case"Divide":case"Add":yield*k(e.left),yield*k(e.right);break;case"Random":yield*k(e.seed),yield*k(e.min),yield*k(e.max);break;case"Cond":yield*k(e.condition),yield*k(e.ifTrue),yield*k(e.ifFalse);break;case"MatchWinding":yield*k(e.sign),yield*k(e.angle)}else if("computed"in e)yield e.computed;else for(const t in e)yield*k(e[t])}function V(n){if(!n)throw new Error("Assertion failed.")}class gt extends tt{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,i){return this._value}hasArcadeDependency(e){return!1}}const xt=()=>De.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function N(n,e,t=!1){const{defaultValue:i,valueExpressionInfo:s,value:o}=e;if(s){const{expression:r}=s,a=await n.createComputedField({expression:r},t);return a?{...e,computed:a,defaultValue:i}:null}return{...e,computed:new gt(o),defaultValue:i}}async function ye(n,e){const{valueExpressionInfo:t}=e,{expression:i}=t,s=await n.createComputedField({expression:i});return s?{...e,computed:s}:null}function be(n){return typeof n=="object"&&n!=null&&(!(!("valueExpressionInfo"in n)||!n.valueExpressionInfo)||"type"in n&&n.type==="Process"&&"op"in n&&n.op==="Random")}function q(n){if(Array.isArray(n)){for(const e of n)if(q(e))return!0}if(typeof n=="object"){if(be(n))return!0;for(const e in n)if(q(n[e]))return!0}return!1}class ne{static async create(e,t,i){const s={},o=new Map,r=new Map,a=new Map,c=new Map,u=new Map,l=new Map;for(const d in i){const h=i[d];if(h!=null&&typeof h=="object")if(Array.isArray(h)){if(typeof h[0]=="object")throw new Error(`InternalError: Cannot handle ${d}. Nested array params are not supported`);s[d]=h}else if("valueExpressionInfo"in h){if(h.value){s[d]=h.value;continue}const y=await ye(e,h);if(!y){s[d]=h.defaultValue;continue}o.set(d,y),s[d]=null}else switch(h.type){case"cim-effect-infos":if(h.effectInfos.some(y=>y.overrides.length)){r.set(d,{effects:await Promise.all(h.effectInfos.map(async y=>{const m=y.overrides.map(f=>N(e,f));return{effect:y.effect,compiledOverrides:(await Promise.all(m)).filter(C)}}))});break}s[d]=h.effectInfos.map(y=>y.effect);break;case"cim-marker-placement-param":h.overrides.length&&a.set(d,{placementInfo:h,compiledOverrides:(await Promise.all(h.overrides.map(y=>N(e,y)))).filter(C)}),s[d]=h.placement;break;case"text-rasterization-param":{if(h.overrides.length){const m=h.overrides.map(f=>N(e,f,h.useLegacyLabelEvaluationRules));c.set(d,{compiledOverrides:(await Promise.all(m)).filter(C),rasterizationParam:h,objectIdToResourceId:new Map});continue}const y={type:"cim-rasterization-info",resource:h.resource};s[d]=await t.fetchResourceImmediate(y)??null;break}case"sprite-rasterization-param":{if(h.overrides.length){const m=h.overrides.map(f=>N(e,f));c.set(d,{compiledOverrides:(await Promise.all(m)).filter(C),rasterizationParam:h,objectIdToResourceId:new Map});continue}if(h.resource.type==="animated"){c.set(d,{compiledOverrides:[],rasterizationParam:h,objectIdToResourceId:new Map});continue}const y={type:"cim-rasterization-info",resource:h.resource};s[d]=await t.fetchResourceImmediate(y)??null;break}case"cim-marker-transform-param":{const{params:y}=h;if(q(y)){const m={compiledMarkerInfos:[]};await Promise.all(y.map(async f=>{const p={props:{}};for(const _ in f)if(be(f[_])){const g=await ye(e,f[_]);p.compiledExpressionMap||(p.compiledExpressionMap=new Map);const M=p.compiledExpressionMap;g&&M.set(_,g)}else p.props[_]=f[_];m.compiledMarkerInfos.push(p)})),u.set(d,m)}else s[d]={type:"cim-marker-transform-info",infos:y};break}case"animation-params":{const{params:y}=h,m=_t(y);if(q(m)){const f=await Promise.all(m.map(p=>ie(p,e)));l.set(d,{params:f,propertyIdToResourceId:new Map,key:d})}else{const f=yt(m),p=await t.fetchResourceImmediate({type:"animation-info",resource:f});p!=null&&p.type==="sprite"&&(s[d]={dataRow:p.rect.y,dataColumn:p.rect.x})}break}default:s[d]=h}else s[d]=h}return new ne(i,s,o,r,a,c,u,l)}constructor(e,t,i,s,o,r,a,c){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=i,this._dynamicEffectProperties=s,this._dynamicPlacementProperties=o,this._dynamicAsyncProperties=r,this._dynamicTransformProperties=a,this._dynamicAsyncAnimations=c,this.evaluator=u=>u,this._arcadeDependencies=new Set;for(const u of this._expressions())ke(this._arcadeDependencies,u)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,i){for(const s of this._dynamicAsyncProperties.values()){const o=Se(s.rasterizationParam.resource);s.rasterizationParam.resource.type==="animated"&&s.rasterizationParam.resource.randomizeStartTime&&(o.primitiveName="__RESERVED__PRIMITIVE__NAME__",o.startGroup=xe(t.getObjectId()||0));for(const{primitiveName:a,propertyName:c,computed:u,defaultValue:l,valueExpressionInfo:d}of s.compiledOverrides)try{const h=s.rasterizationParam.resource.type==="animated"?o.primitiveName:a;et(o,h,c,u,t,i,l)}catch(h){xt().errorOnce(new Ae("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${d?.expression}' (primitive: '${a}', property: '${c}')`,h))}const r=e.enqueueRequest({type:"cim-rasterization-info",resource:o});s.objectIdToResourceId.set(t.getObjectId(),r)}for(const s of this._dynamicAsyncAnimations.values()){const o=s.params.map(c=>b(c,t,i)).map(Y).map(c=>c.simplify()),r=Pe(o),a=e.enqueueRequest({type:"animation-info",resource:r});s.propertyIdToResourceId.set(t.getObjectId()+"."+s.key,a)}}evaluateMeshParams(e,t,i){for(const[s,o]of this._dynamicProperties.entries())this._resolvedMeshParams[s]=o.computed.readWithDefault(t,i,o.defaultValue);for(const[s,o]of this._dynamicPlacementProperties.entries())for(const{computed:r,defaultValue:a,propertyName:c}of o.compiledOverrides){const u=r.readWithDefault(t,i,a);o.placementInfo.placement[c]=u,this._resolvedMeshParams[s]=o.placementInfo.placement}for(const[s,o]of this._dynamicEffectProperties.entries())for(const r of o.effects){for(const{computed:a,defaultValue:c,propertyName:u}of r.compiledOverrides){const l=a.readWithDefault(t,i,c);r.effect[u]=l}this._resolvedMeshParams[s]=o.effects.map(a=>a.effect)}for(const[s,o]of this._dynamicTransformProperties.entries()){const r={type:"cim-marker-transform-info",infos:[]};for(const a of o.compiledMarkerInfos){const c={...a.props};if(a.compiledExpressionMap)for(const[u,l]of a.compiledExpressionMap){const d=l.computed.readWithDefault(t,i,l.defaultValue);c[u]=typeof d=="number"||typeof d=="boolean"?d:l.defaultValue}r.infos.push(c)}this._resolvedMeshParams[s]=r}for(const[s,o]of this._dynamicAsyncProperties.entries()){const r=o.objectIdToResourceId.get(t.getObjectId());if(r==null)continue;const a=e.getResource(r);this._resolvedMeshParams[s]=a}for(const[s,o]of this._dynamicAsyncAnimations.entries()){const r=o.propertyIdToResourceId.get(t.getObjectId()+"."+s);if(r==null)continue;const a=e.getResource(r);this._resolvedMeshParams[s]={dataRow:a.rect.y,dataColumn:a.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const t of e.effects)for(const i of t.compiledOverrides)yield i.computed;for(const e of this._dynamicPlacementProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicAsyncProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicTransformProperties.values())for(const t of e.compiledMarkerInfos)if(t.compiledExpressionMap!=null)for(const i of t.compiledExpressionMap.values())yield i.computed;for(const e of this._dynamicAsyncAnimations.values())for(const t of e.params)yield*k(t)}}class Wt{async createMeshWriter(e,t,i,s){const o=this._getMeshWriter(s.techniqueType),r=await ne.create(e,t,s.inputParams),a=new o(s.id,r,s.optionalAttributes,i);return await a.loadDependencies(),a}_getMeshWriter(e){switch(e){case P.Fill:return qe;case P.DotDensity:return Ze;case P.ComplexFill:return Ne;case P.PatternFill:return Ve;case P.GradientFill:return je;case P.OutlineFill:return We;case P.PatternOutlineFill:return Ge;case P.ComplexOutlineFill:return Oe;case P.Marker:return Ce;case P.PieChart:return Fe;case P.Text:return _e;case P.Line:return Be;case P.TexturedLine:return Re;case P.GradientStroke:return Te;case P.Heatmap:return Ee;case P.Label:return dt;case P.AnimatedMarker:return nt;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{gt as P,Wt as v};
