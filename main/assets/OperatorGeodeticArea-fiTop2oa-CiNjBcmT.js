import{j as xt,P as Rt,a as Ct,d as Tt,w as ct,D as pt,o as lt,ac as _t,ax as Mt,n as N,R as Et,Q as Dt,W as et,T as Gt,aX as ht,aY as zt,Z as G,A as Lt,L as wt,aZ as X,b as S,a_ as V,_ as U,x as bt,E as x,a$ as kt,b0 as Pt,i as q,b1 as gt,b2 as C,F as A,b3 as R,aW as k,b4 as St,b5 as ft,b6 as K,b7 as J,b8 as D,H as st,aV as Ft,a3 as Ot,y as qt,b9 as ut,U as Nt,G as it,ba as yt}from"./ProjectionTransformation-BocI5WO--BFPSq9Lb.js";import{g as Jt}from"./OperatorShapePreservingLength-BM4MoAaG-Ccltlm8A.js";import{id as F,ie as tt}from"./main-DK5A1thH.js";import"./SimpleGeometryCursor-DSF_YyIm-TAMgMsbK.js";let Ut=class{constructor(u,t,n,s,i=0,a=4){this.m_ptDistFrom=new S,this.m_segStartPt=new S,this.m_segEndPt=new S,this.m_geodeticLength=new G,this.m_az12=new G,this.m_minGeodeticDist=new G,this.m_segStartPt3d=new A,this.m_segEndPt3d=new A,this.m_sr=s,this.m_distCurveType=i,this.m_segCurveType=a,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=this.m_sr.getCoordinateSystemType()===2&&this.m_sr.isPannable();const e=it();this.m_inputGCS.querySpheroidData(e),this.m_a=e.majorSemiAxis,this.m_eSquared=e.e2,this.setPointDistFrom(u),this.setSegmentEndPoints(t,n)}setSegmentEndPoints(u,t){this.m_segStartPt.assign(u),this.m_segEndPt.assign(t),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),this.m_segCurveType===2&&(this.m_segStartPt3d.assign(x(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign(x(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(u){this.m_ptDistFrom.assign(u),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(u){this.m_segCurveType=u}setDistanceCurveType(u){this.m_distCurveType=u}makeFunctor(){return u=>{let t;switch(this.m_segCurveType){case 0:case 1:case 3:{const n={stack:[],error:void 0,hasError:!1};try{const s=F(n,new G,!1),i=F(n,new G,!1);U.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*u,this.m_az12.val,s,i,this.m_segCurveType),t=new S(s.val,i.val);break}catch(s){n.error=s,n.hasError=!0}finally{tt(n)}}case 2:{const n=A.lerp(this.m_segStartPt3d,this.m_segEndPt3d,u);t=k(this.m_a,this.m_eSquared,n);break}case 4:t=S.lerp(this.m_segStartPt,this.m_segEndPt,u),this.m_bIsPannablePcs&&(Ft(this.m_sr,0,[t],1),t.mulThis(this.m_rpu));break;default:st("Invalid curve type")}return U.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,t.x,t.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:U.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=S.distance(this.m_segStartPt,this.m_segEndPt);break;default:st("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}};class Xt{constructor(t,n,s,i,a=100){this.m_startPt=t.clone(),this.m_endPt=n.clone(),this.m_cE2=i,this.m_cE=Math.sqrt(this.m_cE2),this.m_c1By2e=1/(2*this.m_cE),this.m_cRpu=s.getGCS().getUnit().getUnitToBaseFactor(),this.isPcs=s.getCoordinateSystemType()===2,this.PEProjcs=s.getPECoordSys(),this.m_points=wt(2*a,Number.NaN)}setSegmentEndPoints(t,n){this.m_startPt.assign(t),this.m_endPt.assign(n)}makeFunctor(){return t=>{const n=[0,0];n[0]=this.m_startPt.x*(1-t)+this.m_endPt.x*t,n[1]=this.m_startPt.y*(1-t)+this.m_endPt.y*t,this.isPcs&&bt.projToGeogCenter(this.PEProjcs,1,n,0);const s=Math.sin(n[1]*this.m_cRpu);return this.m_cE2===0?s:-Math.log((1-this.m_cE*s)/(1+this.m_cE*s))*this.m_c1By2e+s/(1-this.m_cE2*s*s)}}}function Yt(u,t,n){const s=new N;u.queryEnvelope(s);const i=Ot(t,s,!0).total(),a=t.getPannableExtent();a.xmin=s.xmin-10*i,a.xmax=s.xmax+10*i;const e=new qt().execute(u,a,t,n).getImpl().querySegmentIterator();e.stripAttributes();const _=it();t.querySpheroidData(_);const h=_.e2,m=h===0?2:1,l=new S(0,0),r=new S(0,0),o=new X(0),c=new Xt(l,r,t,h,100);for(;e.nextPath();)for(;e.hasNextSegment();){const g=e.nextSegment();l.assign(g.getStartXY()),r.assign(g.getEndXY()),c.setSegmentEndPoints(l,r);const y=K(6,0,1,1e-12,1e-15,c.makeFunctor());o.pe((r.x-l.x)*y)}const p=_.majorSemiAxis;return m*p*p*(1-h)*Math.PI*o.getResult()/t.getPannableExtent().width()}function Bt(u,t,n,s,i){const a=jt(u,t,i);let e=At(u,a.first,n,s,i),_=1,h=0,m=0;do{if(_++,a.first*=.5,a.first<50*t.getTolerance(0))return e;a.second*=2,m=At(u,a.first,n,s,i),h=Math.abs(m-e),e=m}while(Math.abs(e)>1&&h>1e-8*Math.abs(e)&&(a.second<65e3&&_<8||_<4));return m}function At(u,t,n,s,i){const a=new ct().execute(u,t,0,0,i);let e;e=s?new et().execute(a,s,i):a;const _=n.getUnit().getUnitToBaseFactor()===1?Math.PI/180:1,h=new N;e.queryEnvelope(h);const m=new N,l=new N,r=new N;m.setCoords({xmin:h.xmin,ymin:75*_,xmax:h.xmax,ymax:90*_}),l.setCoords({xmin:h.xmin,ymin:-60*_,xmax:h.xmax,ymax:75*_}),r.setCoords({xmin:h.xmin,ymin:-90*_,xmax:h.xmax,ymax:-60*_}),m.inflateCoords(.01*m.width(),0),l.inflateCoords(.01*l.width(),0),r.inflateCoords(.01*r.width(),0);let o=0;return o+=rt(e,m,n,i),o+=rt(e,l,n,i),o+=rt(e,r,n,i),o}function rt(u,t,n,s){const i=new qt().execute(u,t,n,s);if(i!==null&&!i.isEmpty()){const a=new N;i.queryEnvelope(a);const{first:e,second:_}=Qt(n,a,!1),h=pt(n,e,null),m=new et().execute(i,h,s).calculateArea2D();return _&&e.destroy(),m}return 0}const Z=[null,null,null,null,null,null,null];function Ht(u,t,n){const s=u.getUnit().getUnitToBaseFactor(),i=t.getCenter();i.scale(180*s/Math.PI);const a=new S;a.x=0,a.y=0;let e=0;if(e===0){i.y>45?(a.y=q,e=0):i.y<-45?(a.y=-q,e=1):i.x>=45&&i.x<135?(a.x=q,e=2):i.x>=135||i.x<-135?(a.x=q,e=3):i.x<-45&&i.x>=-135?(a.x=-q,e=4):(a.x=0,e=5);const f=s*Math.sqrt(yt(t.xmin-t.xmax)+yt(t.ymin-t.ymax)),d=a.clone(),E=t.getCenter();if(E.scale(s),e<2&&(d.x=E.x),S.distance(d,E)+.5*f>q)return null}const _=Z[e];if(_!==null&&_.getGCS().equalHorizontal(u))return _;const h=u.getText(),m=a.x,l=a.y,r=0,o=0;let c=0,p=-1;e!==6?p=C.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:(Mt(n),c=0,p=C.PE_PRJ_CYLINDRICAL_EQAREA);const g=gt("EqualAreaPCS");let y;p===C.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?y=`PROJCS["${g}",${h},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${r}],PARAMETER["False_Northing",${o}],PARAMETER["Central_Meridian",${m}],PARAMETER["Latitude_of_Origin",${l}],UNIT["Meter",1.0]]`:p===C.PE_PRJ_CYLINDRICAL_EQAREA?y=`PROJCS["${g}",${h},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${r}],PARAMETER["False_Northing",${o}],PARAMETER["Central_Meridian",${m}],PARAMETER["Standard_Parallel_1",${c}],PARAMETER["Latitude_of_Origin",${l}],UNIT["Meter",1.0]]`:st("getEqualAreaPcsFixed");const P=Nt(y);return Z[e]&&Z[e].destroy(),Z[e]=P,P}function Qt(u,t,n){const s=Ht(u,t,n);if(s!==null)return ut(s,!1);const i=u.getText(),a=u.getUnit().getUnitToBaseFactor(),e=(t.xmin+t.width()/2)*a,_=(t.ymin+t.height()/2)*a,h=0,m=0;let l=0,r=0,o=-1;t.ymin*a>=75*Math.PI/180||t.ymax*a<=-60*Math.PI/180?o=C.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:t.ymin>0||t.ymax<0?(l=(t.ymin+1/3*t.height())*a,r=(t.ymin+2/3*t.height())*a,o=C.PE_PRJ_ALBERS):(l=(t.ymin+2/3*t.height())*a,o=C.PE_PRJ_CYLINDRICAL_EQAREA);const c=gt("EqualAreaPCS");let p;return o===C.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?p=`PROJCS["${c}",${i},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${h}],PARAMETER["False_Northing",${m}],PARAMETER["Central_Meridian",${e}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:o===C.PE_PRJ_ALBERS?p=`PROJCS["${c}",${i},PROJECTION["Albers"],PARAMETER["False_Easting",${h}],PARAMETER["False_Northing",${m}],PARAMETER["Central_Meridian",${e}],PARAMETER["Standard_Parallel_1",${l}],PARAMETER["Standard_Parallel_2",${r}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:o===C.PE_PRJ_CYLINDRICAL_EQAREA?p=`PROJCS["${c}",${i},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${h}],PARAMETER["False_Northing",${m}],PARAMETER["Central_Meridian",${e}],PARAMETER["Standard_Parallel_1",${l}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:st("getEqualAreaPCSInstance"),ut(Nt(p),!0)}function jt(u,t,n){const s=u.calculateLength2D(),i=new Jt().execute(u,t,n)/25e3,a=s/u.getSegmentCount()*2;let e=Math.min(a,s/i);return e===0&&(e=1),ut(e,s/e)}class Wt{getOperatorType(){return 10314}supportsCurves(){return!0}accelerateGeometry(t,n,s){return!1}canAccelerateGeometry(t){return!1}execute(t,n,s){if(n.getCoordinateSystemType()===0&&Rt(""),t.isEmpty()||t.getDimension()<2)return 0;if(xt(t),t.getGeometryType()===Ct.enumEnvelope){const m=new Tt;return m.addEnvelope(t,!1),this.execute(m,n,s)}let i=t;t.getDescription().getAttributeCount()>1&&(i=t.clone(),i.dropAllAttributes());const a=new ct().execute(i,0,n.getTolerance(0),0,s);let e=null;const _=n.getGCS();_!==n&&(e=pt(n,_));let h=new lt().execute(a,n,!1,s);return h.isEmpty()?0:(h===t&&(h=t.clone()),n.isPannable()?Yt(h,n,s):Bt(h,n,_,e,s))}}function mt(){return{m_p_PCS:new S,m_factor:Number.NaN,setValues:Vt,assign:Zt}}function Vt(u,t){this.m_factor=u,this.m_p_PCS.assign(t)}function Zt(u){this.m_factor=u.m_factor,this.m_p_PCS.assign(u.m_p_PCS)}class Kt{constructor(t,n,s,i){this.m_ptStart=new A,this.m_ptEnd=new A,this.m_ptStart.assign(n),this.m_ptEnd.assign(s),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y,this.m_e=Math.sqrt(t),this.m_e2=t,this.m_c1MinusE2=1-t;const a=Math.sin(i);let e;e=this.m_e2===0?2*a:a*(J(this.m_e*a)+1/(1-this.m_e2*a*a)),this.m_baseA=e}setSegmentEndPoints(t,n){this.m_ptStart.assign(t),this.m_ptEnd.assign(n),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y}makeFunctor(){return t=>{const n=1-t,s=n*this.m_ptStart.x+t*this.m_ptEnd.x,i=n*this.m_ptStart.y+t*this.m_ptEnd.y,a=n*this.m_ptStart.z+t*this.m_ptEnd.z,e=s*s+i*i,_=a/Math.sqrt(a*a+this.m_c1MinusE2*this.m_c1MinusE2*e);let h;return this.m_e2===0?h=2*_:h=_*(J(this.m_e*_)+1/(1-this.m_e2*_*_)),(this.m_deltaY*s-this.m_deltaX*i)/e*(h-this.m_baseA)}}}function te(){return{e:Number.NaN,one_p_e:Number.NaN,one_m_e:Number.NaN,one_m_e_2:Number.NaN,atanh_e_over_e:Number.NaN,half_qp:Number.NaN,f:Number.NaN,z:Number.NaN}}function ot(){return{sin_phi:Number.NaN,one_p_sin_phi:Number.NaN,one_m_sin_phi:Number.NaN,one_m_e_2_sin_2_phi:Number.NaN,sin_half_phi_pf:Number.NaN,sin_half_phi_pz:Number.NaN,sin_half_asin_e_sin_phi_pf:Number.NaN,sin_half_asin_e_sin_phi_pz:Number.NaN,atanh_sin_phi:Number.NaN,atanh_esin_phi:Number.NaN,make_negative:!1,initialize:ee,changeSign:se,assign:ie,clone:ne}}function ee(u,t,n,s){const i=.5*u;this.sin_phi=Math.sin(u);const a=t*this.sin_phi,e=.5*Math.asin(a);this.one_p_sin_phi=1+this.sin_phi,this.one_m_sin_phi=1-this.sin_phi,this.one_m_e_2_sin_2_phi=(1+a)*(1-a),this.sin_half_phi_pf=Math.sin(i+n),this.sin_half_phi_pz=Math.sin(i+s),this.sin_half_asin_e_sin_phi_pf=Math.sin(e+n),this.sin_half_asin_e_sin_phi_pz=Math.sin(e+s),this.atanh_sin_phi=Math.log(this.sin_half_phi_pf/this.sin_half_phi_pz),this.atanh_esin_phi=Math.log(this.sin_half_asin_e_sin_phi_pf/this.sin_half_asin_e_sin_phi_pz)}function se(){this.sin_phi=-this.sin_phi;let u=this.one_p_sin_phi;this.one_p_sin_phi=this.one_m_sin_phi,this.one_m_sin_phi=u,u=this.sin_half_phi_pf,this.sin_half_phi_pf=this.sin_half_phi_pz,this.sin_half_phi_pz=u,u=this.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pf=this.sin_half_asin_e_sin_phi_pz,this.sin_half_asin_e_sin_phi_pz=u,this.atanh_sin_phi=-this.atanh_sin_phi,this.atanh_esin_phi=-this.atanh_esin_phi}function ie(u){this.sin_phi=u.sin_phi,this.one_p_sin_phi=u.one_p_sin_phi,this.one_m_sin_phi=u.one_m_sin_phi,this.one_m_e_2_sin_2_phi=u.one_m_e_2_sin_2_phi,this.sin_half_phi_pf=u.sin_half_phi_pf,this.sin_half_phi_pz=u.sin_half_phi_pz,this.sin_half_asin_e_sin_phi_pf=u.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pz=u.sin_half_asin_e_sin_phi_pz,this.atanh_sin_phi=u.atanh_sin_phi,this.atanh_esin_phi=u.atanh_esin_phi,this.make_negative=u.make_negative}function ne(){return{...this}}class ae{constructor(t,n,s){this.m_transformPCS2GCS=null,this.m_scaleToRadians=new _t,this.m_scaleToDegrees=new _t,this.m_progressTracker=s,Mt(n!==4),this.m_curveType=n,this.m_inputSR=t,t&&t.getCoordinateSystemType()!==0||Rt(""),this.m_inputGCS=t.getGCS(),this.m_a=0,this.m_eSquared=0,this.m_b=0,this.m_rpu=0}executePolygonGeodeticArea(t){let n,s=t.clone();if(s.dropAllAttributes(),t.hasNonLinearSegments()&&(s=new ct().execute(s,0,this.m_inputSR.getTolerance(0),0,this.m_progressTracker)),this.m_inputSR.isPannable()){const e=new N;s.queryEnvelope(e);const _=this.m_inputSR.getPannableExtent();if(!_.containsEnvelope(e)){const h=_.getCenterX()-e.getCenterX(),m=new _t;m.setShiftCoords(h,0),s.applyTransformation(m),e.move(h,0);const l=new Et;_.queryIntervalX(l);const r=new Et;e.queryIntervalX(r),s=l.contains(r)?Dt(s,this.m_inputSR):new et().foldInto360RangeGeodetic(s,this.m_inputSR,this.m_curveType)}}if(this.m_transformPCS2GCS?(s=new lt().execute(s,this.m_inputSR,!1,this.m_progressTracker),n=s.createInstance(),Gt(this.m_transformPCS2GCS,s,n,this.m_progressTracker)||(n=new et().execute(s,this.m_transformPCS2GCS,this.m_progressTracker))):n=new lt().execute(s,this.m_inputGCS,!1,this.m_progressTracker),n.isEmpty())return 0;if(this.m_curveType===1){const e=it();return this.m_inputGCS.querySpheroidData(e),this.m_a=e.majorSemiAxis,this.m_eSquared=e.e2,this.loxodromeArea(n)}const i=n.getImpl();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_scaleToRadians.setScale(this.m_rpu),i.applyTransformation(this.m_scaleToRadians),this.m_scaleToDegrees=this.m_scaleToRadians,this.m_scaleToDegrees.invertThis();const a=it();if(this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_b=a.minorSemiAxis,this.m_eSquared=a.e2,this.m_curveType===2)return this.executeClippedPolygonGreatEllipticArea(n);{const e={stack:[],error:void 0,hasError:!1};try{const _=ht.unit(9101),h=this.m_inputGCS.getPECoordSys(),m=F(e,h.cloneAlterUnits(_),!1);let l,r,o=this.executeClippedPolygonGeodeticArea(n,m,0),c=0;do c++,l=this.executeClippedPolygonGeodeticArea(n,m,c),r=Math.abs(l-o),o=l;while(Math.abs(l)>1&&r>1e-8*Math.abs(l)&&c<7);return l}catch(_){e.error=_,e.hasError=!0}finally{tt(e)}}}executeClippedPolygonGeodeticArea(t,n,s){const i={stack:[],error:void 0,hasError:!1};try{const a=new N;t.queryEnvelope(a);const e=F(i,this.getEqualAreaPCSInstance(n,a),!1),_=t.clone();zt(e,_);const h=50,m=_.getImpl().getAttributeStreamRef(0),l=t.getImpl().getAttributeStreamRef(0),r=F(i,new G,!1),o=F(i,new G,!1),c=40,p=[0,0],g=Lt(mt,c),y=wt(c,-1),P=mt(),f=mt();let d,E;const v=e;let M=_.calculateArea2D();const w=new X(0),z=.5*Math.PI,Y=1e-10*Math.abs(M)+1e-6,nt=t.getPathCount();let L,O,I,b;const T=new S,$=new S,B=new S,H=new S,Q=new S,j=new S;let dt,at;for(O=t.getPathStart(0),L=0;L<nt;L++,O=I)for(I=t.getPathEnd(L),m.queryPoint2D(I-1<<1,B),l.queryPoint2D(I-1<<1,T),Math.abs(T.y)>z&&(T.y=V(z,T.y)),b=O;b<I;b++,B.assign(H),T.assign($)){if(m.queryPoint2D(b<<1,H),l.queryPoint2D(b<<1,$),Math.abs($.y)>z&&($.y=V(z,$.y)),dt=S.distance(B,H),dt<h||T.y===0&&$.y===0)continue;U.geodeticDistance(this.m_a,this.m_eSquared,T.x,T.y,$.x,$.y,r,o,null,this.m_curveType);const vt=r.val,It=o.val;for(P.setValues(0,B),f.setValues(1,H),E=s,g[0].assign(f),y[0]=s,d=0;d>=0;){at=.5*(P.m_factor+f.m_factor),U.geodeticCoordinate(this.m_a,this.m_eSquared,T.x,T.y,vt*at,It,r,o,this.m_curveType),Q.x=r.val,Q.y=o.val,p[0]=Q.x,p[1]=Q.y,bt.geogToProj(v,1,p),j.x=p[0],j.y=p[1];const $t=-j.offset(P.m_p_PCS,f.m_p_PCS),W=.5*$t*S.distance(P.m_p_PCS,f.m_p_PCS);if(w.pe(W),Math.abs(W)>Y||Math.abs(W)>0&&E>0)f.setValues(at,j),d++,g[d].assign(f),Math.abs(W)<=Y?(E--,y[d-1]=E,y[d]=E):(E=y[d-1],y[d]=E);else{if(d<=0)break;P.assign(f),d--,f.assign(g[d]),E=y[d]}}}return M+=w.getResult(),Math.abs(M)}catch(a){i.error=a,i.hasError=!0}finally{tt(i)}}executeClippedPolygonGreatEllipticArea(t){const n=[],s=[],i=new S,a=new S,e=x(1,this.m_eSquared,new S(0,.5*Math.PI)),_=new X(0),h=new X(0),m=new X(0),l=new A,r=new A,o=new N;t.queryLooseEnvelope(o);let c=0;o.containsCoords(o.xmin,0)||(c=Math.abs(o.ymin)<Math.abs(o.ymax)?o.ymin:o.ymax);const p=new Kt(this.m_eSquared,l,r,c),g=this.m_a*this.m_a,y=t.getImpl().querySegmentIterator();for(y.stripAttributes();y.nextPath();)for(;y.hasNextSegment();){const P=y.nextSegment();i.assign(P.getStartXY()),a.assign(P.getEndXY()),a.x-i.x>Math.PI?i.x+=2*Math.PI:a.x-i.x<-Math.PI&&(a.x+=2*Math.PI),this.splitSegmentCrossingItegralThreshold(P,n,s);for(let f of n)l.assign(x(this.m_a,this.m_eSquared,f.getStartXY())),r.assign(x(this.m_a,this.m_eSquared,f.getEndXY())),p.setSegmentEndPoints(l,r),this.adaptiveIntegrationWithRomberg(p,_);for(let f of s){let d=f.getStartXY(),E=f.getEndXY(),v=c;d.y<0&&(E=kt(d,d=E),d.y=-d.y,E.y=-E.y,v=-v);const M=x(1,this.m_eSquared,d),w=x(1,this.m_eSquared,E),z=Math.min(d.y,E.y),Y=Pt(this.m_eSquared,d.x,E.x,v,z);h.pe(Y);const nt=Math.abs(Pt(this.m_eSquared,d.x,E.x,z,q)),L=new A;L.setSub(M,e);const O=new A;O.setSub(w,e);const I=new A;I.setCrossProductVector(L,O);let b=g*(nt-.5*I.length());b=V(b,E.x-d.x),m.pe(b)}n.length=0,s.length=0}return m.getResult()+g*(.5*(1-this.m_eSquared)*_.getResult()+h.getResult())}getEqualAreaPCSInstance(t,n){const s=n.getCenterX(),i=0,a=0;let e,_;const h=n.height();let m,l;(m=n.ymin>45*Math.PI/180||n.ymax<45*-Math.PI/180)?e=V(.5*Math.PI,n.getCenterY()):(e=n.getCenterY(),_=n.ymin+h*(2/3));const r=gt("EqualAreaPCS"),o=t.toString();return l=m?ht.fromString(C.PE_TYPE_PROJCS,`PROJCS["${r}", ${o}, PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${i}],PARAMETER["False_Northing", ${a}],PARAMETER["Central_Meridian", ${s}], PARAMETER["Latitude_of_Origin", ${e}], UNIT["Meter",1.0]]`):ht.fromString(C.PE_TYPE_PROJCS,`PROJCS["${r}", ${o}, PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting", ${i}],PARAMETER["False_Northing", ${a}],PARAMETER["Central_Meridian", ${s}],PARAMETER["Standard_Parallel_1", ${_}],PARAMETER["Latitude_of_Origin", ${e}],UNIT["Meter",1.0]]`),l}splitSegmentCrossingItegralThreshold(t,n,s){const i=x(this.m_a,this.m_eSquared,new S(0,q)),a=x(this.m_a,this.m_eSquared,new S(0,-q)),e=this.splitSegmentPassingThroughPole(t);for(let _ of e){const h=_.getStartXY(),m=_.getEndXY(),l=x(this.m_a,this.m_eSquared,h),r=x(this.m_a,this.m_eSquared,m),o=new S,c=new A;let p=A.sqrDistance(i,l),g=A.sqrDistance(l,r);if(p<=100){if(!(g>400)){s.push(new R({start:h,end:m}));continue}c.assign(r.sub(l)),c.normalizeThis(),c.assign(l.add(c.mul(20))),o.assign(k(this.m_a,this.m_eSquared,c)),s.push(new R({start:h,end:o})),h.assign(o)}if(l.assign(x(this.m_a,this.m_eSquared,h)),p=A.sqrDistance(i,r),g=A.sqrDistance(l,r),p<=100){if(!(g>400)){s.push(new R({start:h,end:m}));continue}c.assign(r.sub(l)),c.normalizeThis(),c.assign(r.sub(c.mul(20))),o.assign(k(this.m_a,this.m_eSquared,c)),s.push(new R({start:o,end:m})),m.assign(o)}if(l.assign(x(this.m_a,this.m_eSquared,h)),r.assign(x(this.m_a,this.m_eSquared,m)),p=A.sqrDistance(a,l),g=A.sqrDistance(l,r),p<=100){if(!(g>400)){s.push(new R({start:h,end:m}));continue}c.assign(r.sub(l)),c.normalizeThis(),c.assign(l.add(c.mul(20))),o.assign(k(this.m_a,this.m_eSquared,c)),s.push(new R({start:h,end:o})),h.assign(o)}if(l.assign(x(this.m_a,this.m_eSquared,h)),r.assign(x(this.m_a,this.m_eSquared,m)),p=A.sqrDistance(a,r),g=A.sqrDistance(l,r),p<=100){if(!(g>400)){s.push(new R({start:h,end:m}));continue}c.assign(r.sub(l)),c.normalizeThis(),c.assign(r.sub(c.mul(20))),o.assign(k(this.m_a,this.m_eSquared,c)),s.push(new R({start:o,end:m})),m.assign(o)}n.push(new R({start:h,end:m}))}}splitSegmentPassingThroughPole(t){const n={stack:[],error:void 0,hasError:!1};try{const s=[],i=new A,a=new A,e=new A,_=new S,h=20,m=3.124139361,l=10,r=t.getStartXY(),o=t.getEndXY(),c=F(n,new G,!1);if(U.geodeticDistance(this.m_a,this.m_eSquared,r.x,r.y,o.x,o.y,c,null,null,2),Math.abs(o.x-r.x)>m&&c.val>h){const p=new Ut(new S(0,90),r.divide(this.m_rpu),o.divide(this.m_rpu),this.m_inputGCS,2,2);let g=St(p.makeFunctor(),0,1,1e-10);if(g.second<=l&&g.first>0&&g.first<1)return i.assign(x(this.m_a,this.m_eSquared,r)),a.assign(x(this.m_a,this.m_eSquared,o)),ft(i,a,g.first,e),_.assign(k(this.m_a,this.m_eSquared,e)),s.push(new R({start:r,end:_})),s.push(new R({start:_,end:o})),s;if(p.setPointDistFrom(new S(0,-90)),g=St(p.makeFunctor(),0,1,1e-10),g.second<=l&&g.first>0&&g.first<1)return i.assign(x(this.m_a,this.m_eSquared,r)),a.assign(x(this.m_a,this.m_eSquared,o)),ft(i,a,g.first,e),_.assign(k(this.m_a,this.m_eSquared,e)),s.push(new R({start:r,end:_})),s.push(new R({start:_,end:o})),s}return s.push(new R({start:r,end:o})),s}catch(s){n.error=s,n.hasError=!0}finally{tt(n)}}adaptiveIntegrationWithRomberg(t,n){const s=t.makeFunctor();let i=0,a=1,e=s(i),_=s(a);const h=1e-17,m=1e-14;let l=(i+a)/2,r=s(l),o=Math.abs(r-e),c=Math.abs(_-r),p=0;for(;p++<32&&(o/c<.1||c/o<.1);)o<c?(n.pe(K(5,i,l,m,h,s)),i=l,e=r):(n.pe(K(5,l,a,m,h,s)),a=l,_=r),l=(i+a)/2,r=Math.abs(s(l)),o=Math.abs(r-e),c=Math.abs(_-r);n.pe(K(5,i,a,m,h,s))}loxodromeAreaHemi(t,n,s,i,a){const e=s.clone(),_=a.clone();let h,m,l,r,o,c,p,g,y,P,f,d,E,v,M,w;return e.make_negative&&e.changeSign(),_.make_negative&&_.changeSign(),f=i-n,Math.abs(e.sin_phi)===1||Math.abs(_.sin_phi)===1?t.half_qp*f:e.sin_phi===_.sin_phi?(P=.5*t.one_m_e_2*e.sin_phi*(1/e.one_m_e_2_sin_2_phi+J(t.e*e.sin_phi))*f,P):(M=Math.log(_.sin_half_phi_pf*e.sin_half_phi_pz/(_.sin_half_phi_pz*e.sin_half_phi_pf)),w=Math.log(_.sin_half_asin_e_sin_phi_pf*e.sin_half_asin_e_sin_phi_pz/(_.sin_half_asin_e_sin_phi_pz*e.sin_half_asin_e_sin_phi_pf)),this.m_eSquared===1?(o=0,h=.5*(M+_.sin_phi/_.one_m_e_2_sin_2_phi-e.sin_phi/e.one_m_e_2_sin_2_phi),m=0):(o=-2*t.atanh_e_over_e*(Math.log(_.one_p_sin_phi/e.one_p_sin_phi)-t.e*w),h=(M-t.e*w)/t.one_m_e_2,m=(Math.log(_.one_m_e_2_sin_2_phi/e.one_m_e_2_sin_2_phi)+o/t.atanh_e_over_e)/t.one_m_e_2),l=-w*(e.atanh_esin_phi+_.atanh_esin_phi),r=1/e.one_m_e_2_sin_2_phi-1/_.one_m_e_2_sin_2_phi,c=D(_.one_m_sin_phi/t.one_p_e,t.e)-D(e.one_m_sin_phi/t.one_p_e,t.e),p=D(_.one_p_sin_phi/t.one_p_e,t.e)-D(e.one_p_sin_phi/t.one_p_e,t.e),g=D(e.one_m_sin_phi/-t.one_m_e,t.e)-D(_.one_m_sin_phi/-t.one_m_e,t.e),y=D(e.one_p_sin_phi/-t.one_m_e,t.e)-D(_.one_p_sin_phi/-t.one_m_e,t.e),P=.25/h*(m+l+r+o+.5*(c+p+g+y)),P+=t.half_qp,d=.5*t.one_m_e_2*e.sin_phi*(1/e.one_m_e_2_sin_2_phi+J(t.e*e.sin_phi)),E=.5*t.one_m_e_2*_.sin_phi*(1/_.one_m_e_2_sin_2_phi+J(t.e*_.sin_phi)),E<d&&(v=d,d=E,E=v),P<d&&(P=d),P>E&&(P=E),P*=f,P)}loxodromeArea(t){const n=Math.PI/180;let s=0;const i=te(),a=ot(),e=ot();i.e=Math.sqrt(this.m_eSquared),i.one_p_e=1+i.e,i.one_m_e=1-i.e,i.one_m_e_2=1-this.m_eSquared,i.atanh_e_over_e=J(i.e),this.m_eSquared>=1?i.half_qp=1:i.half_qp=.5*(1+i.atanh_e_over_e*i.one_m_e_2),i.f=.25*Math.PI,i.z=.75*Math.PI,e.initialize(0,i.e,i.f,i.z);const _=t.getPathCount(),h=new S,m=new S,l=t.getImpl().getAttributeStreamRef(0);for(let r=0;r<_;r++){const o=t.getPathStart(r),c=t.getPathEnd(r);if(!(c-o<=1)){l.queryPoint2D(2*(c-1),h);for(let p=o;p<c;p++){l.queryPoint2D(2*p,m);const g=h.y*n,y=m.y*n;if(p===o?(a.initialize(g,i.e,i.f,i.z),a.make_negative=!1):a.assign(e),e.initialize(y,i.e,i.f,i.z),e.make_negative=!1,h.y*m.y<0){if(h.y>=90&&m.y<=-90||m.y>=90&&h.y<=-90)return Number.NaN;const P=ot();P.initialize(0,i.e,i.f,i.z),P.make_negative=!1;const f=a.atanh_sin_phi-i.e*a.atanh_esin_phi,d=e.atanh_sin_phi-i.e*e.atanh_esin_phi,E=(d*h.x-f*m.x)/(d-f);g<0?(a.make_negative=!0,s-=this.loxodromeAreaHemi(i,h.x*n,a,E*n,P),a.make_negative=!1,s+=this.loxodromeAreaHemi(i,E*n,P,m.x*n,e)):(s+=this.loxodromeAreaHemi(i,h.x*n,a,E*n,P),e.make_negative=!0,s-=this.loxodromeAreaHemi(i,E*n,P,m.x*n,e),e.make_negative=!1)}else h.y>=0?s+=this.loxodromeAreaHemi(i,h.x*n,a,m.x*n,e):(a.make_negative=!0,e.make_negative=!0,s-=this.loxodromeAreaHemi(i,h.x*n,a,m.x*n,e),a.make_negative=!1,e.make_negative=!1);h.assign(m)}}}return this.m_a*s*this.m_a}calculate(t){if(t.isEmpty()||t.getDimension()<2)return 0;if(t.getGeometryType()===Ct.enumEnvelope){const n=new Tt;return n.addEnvelope(t,!1),this.calculate(n)}return this.m_inputSR!==this.m_inputGCS&&this.m_transformPCS2GCS===null&&(this.m_transformPCS2GCS=pt(this.m_inputSR,this.m_inputGCS,null)),this.executePolygonGeodeticArea(t)}}class oe{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(t,n,s){return!1}canAccelerateGeometry(t){return!1}execute(t,n,s,i){return xt(t),s===4?new Wt().execute(t,n,i):new ae(n,s,i).calculate(t)}}export{oe as OperatorGeodeticArea};
