import{ag as Y,n as ue,o as Q,ah as Te,av as Ee,a1 as R,an as ce,$ as Ne,bP as ye,w as oe,m as me,v as M,S as w,i as Ie}from"./main-BNyfiy7F.js";import{m as De}from"./MultiOriginJSONSupport-DKRh9P6w-BDNM2cEa.js";import{D as xe}from"./Layer-ChoECxvZ-D_sywEJS.js";import{z as B}from"./featureConversionUtils-D6hFQ4Af-CqR__5Xd.js";import{c as _e}from"./OptimizedFeature-EIithYlr-Cq64mIT3.js";import{t as $,A as Re,J as Oe,M as Ae,I as ve,D as Se,L as Ge,N as Pe,E as He,w as Fe,k as T,T as A,n as J,r as V,P as Ue,m as b,b as ge,f as Be,B as fe,o as $e}from"./KnowledgeGraphSublayer-DPj4igi1-BVaItGbo.js";import{u as ze}from"./BlendLayer-D1WkSmwP-DKefN4B5.js";import{E as We}from"./OperationalLayer-B5IXiMa2-Ciwqx-Ya.js";import{S as je}from"./ScaleRangeLayer-Bz0DcnvM-DCWD9cwD.js";import{F as Qe}from"./knowledgeGraphService-DOJz0fzA-BkIFm7kg.js";import"./TimeExtent-Cn0Jofqr-BUf77X_H.js";import"./OptimizedFeatureSet-DfZGBuxJ-C08BOAgi.js";import"./projection-BA9M1R7d-CFfzn5H_.js";import"./projectBuffer-CvCBvJ6W-D_rxfrjt.js";import"./GraphicsLayer-DfeGaYc1-BM86BvdL.js";import"./GraphicsCollection-CWTXNZOX-byIc4Plz.js";import"./ElevationInfo-yv2-9tj6-CnPfGa7M.js";import"./lengthUtils-DKpMe5qR-CSpyMgzR.js";import"./jsonUtils-wIllKWI4-CNPg1u5I.js";import"./parser-DyDJ-rlI-Ce49-Im9.js";import"./mat4f32-CiZjBg9k-CUm34GoR.js";import"./mat4-DX7gBViE-C5DXQzdb.js";import"./common-CYWrYyJl-E8-sukrT.js";import"./Relationship-Db9GUmYx-BZTq-T3l.js";import"./Query-BrwMGK8U-CCzP1I20.js";import"./Field-C6hA1tZj-cd1zkCNB.js";import"./fieldType-CD2CL2hr-C1DvAoGt.js";import"./UniqueValueRenderer-fS5V0Ej1-Ce5oCtM3.js";import"./RendererLegendOptions-K3md58-X-sJTEqeR4.js";import"./diffUtils-Cz3Fi8Xb-CinLCnvf.js";import"./colorRamps-q0bZVhs2-Bbcalyo_.js";import"./sizeVariableUtils-t52KcLLi-D0hbQF8b.js";import"./visualVariableUtils-D3kZJRyn-Dp_u04PG.js";import"./compilerUtils-CV1QYWI8-KRXpwzek.js";import"./styleUtils-BtpNqZyT-DDSoOnwr.js";import"./jsonUtils-C64Zfu7c-CXMU37yM.js";import"./LRUCache-C3erQTWv-DoQ9eZMw.js";import"./Version-CoKzbupV-BQe52sIu.js";import"./FieldsIndex-HmzMbJQG-bu1j8kZQ.js";import"./UnknownTimeZone-C--TOcPG-DgJw7EQC.js";import"./OverrideHelper-DWRbVlj1-Bgtcgj-E.js";import"./colorUtils-Cthpxcks-CzGrSln-.js";import"./vec42-D8CJyqHG-DnfLTeQH.js";import"./vec4f64-hf2nxvhQ-CaAr8PTM.js";import"./utils-SPbpQbmm-Bi_GIGH0.js";import"./enums-CpSG_SL3-BMD3Tb1v.js";import"./quantizationUtils-bJy1cRwp-DcVs_chM.js";import"./heatmapUtils-seiMkkkR-MSr4QDHB.js";import"./workers-PiCjreoO-CoeFUD7p.js";import"./FeatureStore-Co2V0sVE-CdqFiAep.js";import"./BoundsStore--N6o1xkF-ZJwVBC4S.js";import"./PooledRBush-DbfAmeLn-DimkEIVr.js";import"./quickselect-DHTstthl-Ds_Aj0x5.js";import"./timeSupport-jPViR5jn-xTQK1dJc.js";import"./queryUtils-Brxu6254-DG1Jkfpk.js";import"./normalizeUtils-Bxmy9MNI-DBdQVIGZ.js";import"./normalizeUtilsCommon-CRJlkfEA-Dnie3PBL.js";import"./utils-9sQxfkoa-CCu3H0rb.js";import"./utils-Bq23Xwmj-B8kwi51K.js";import"./json-BI97KiBB-Ce5cWfI2.js";import"./optimizedFeatureQueryEngineAdapter-DFdaawxC-C5dLGxxT.js";import"./QueryEngine-CH5uUhZK-CgwZRsls.js";import"./WhereClause-DxwoyBMS-Bur5U6H_.js";import"./TimeOnly-DSMefxKy-ONWVZn0z.js";import"./QueryEngineCapabilities-Gr588n9t-DjYb9CEb.js";import"./utils-HtkT8Fn3-DJwwSHCy.js";import"./utils-DyydRFHu-B801S19_.js";import"./Basemap-BEqqSTw9-CurKl591.js";import"./loadAll-e978YItg-DoFxIH1Y.js";import"./PortalItem-CctGdnxF-DED2in5u.js";import"./writeUtils-D5qlLkwk-CuyRnth2.js";import"./utils-tNxq3jkf-B1iPZLRm.js";import"./ClassBreaksDefinition-bYRgYgPp-93PRMlqz.js";import"./Scheduler-B7UX7Wr5-CQ_fDN4C.js";import"./signal-CETehA7D-CUOb3AUy.js";import"./clientSideDefaults-BqqayPct-Bkn6qQ55.js";import"./capabilities-Cjn77swe-Y9lFlGVh.js";import"./fieldProperties-Bq26w7gt-CzvbDOfd.js";import"./FeatureEffectLayer-Cro89IEC-q5pq3RFG.js";import"./FeatureEffect-CDEk9Es7-D9cAyftz.js";import"./FeatureFilter-BCFHgLVU-BihHYdJX.js";import"./FeatureReductionLayer-BTZjL0_Z-xz1-NmLF.js";import"./commonProperties-BtIqvFU_-BhLflXi8.js";import"./FeatureReductionSelection-BjX3h7Sz-C4mgHOzr.js";import"./featureLayerUtils-DgfQQyK4-B_pT1ydj.js";import"./uuid-Dj9mdEVg-BaKSCiyT.js";import"./RelationshipQuery-DJsz3K0U-DrfO_VlB.js";import"./labelingInfo-DGVNul26-BOxzJA-_.js";import"./labelUtils-BW14kBqX-CGKKhFzh.js";import"./MD5-CHHr-oed-SuyrCYQ0.js";import"./OrderedLayer-6Qsmrd_l-BQD1ZiMY.js";import"./OrderByInfo-GD2XnU8e-BsDk0fPX.js";import"./RefreshableLayer-a8BQ58Xh-hRvk5kKU.js";import"./TemporalLayer-CpOrN_w9-Chf0sDcp.js";import"./TimeInfo-w_HB2CsF-CdxaeJOF.js";import"./FeatureSet-BkVNthuN-Dc1uqxCd.js";import"./popupUtils-B0uZcXX0-Bz1EmkSy.js";var q;(function(e){e.MULTIPLIER="multiplier",e.ABSOLUTE="absoluteValue"})(q||(q={}));let f=class extends We(ze(je(De(xe)))){constructor(e){if(super(e),this.dataPreloadedInLocalCache=!1,this.defaultLinkChartConfig=null,this._currentLinkChartConfig={layoutMode:"RADIAL_TREE"},this._graphTypeLookup=new Map,this.dataManager=null,this.knowledgeGraph=null,this.layers=new(Y.ofType($)),this.entityLinkChartDiagramLookup=new Map,this.relationshipLinkChartDiagramLookup=new Map,this.linkChartExtent=new ue({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7}),this.memberEntityTypes=null,this.memberRelationshipTypes=null,this.operationalLayerType="LinkChartLayer",this.sublayerIdsCache=new Map,this.tables=new(Y.ofType($)),this.type="link-chart",this.chronologicalAuxiliaryGraphics=null,this._originalInclusionList=e?.inclusionModeDefinition,e?.dataPreloadedInLocalCache&&!e?.inclusionModeDefinition)throw new Q("knowledge-graph:linkchart-layer-constructor","If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it");this.addHandles(Te(()=>this.layers.concat(this.tables),(t,i)=>this._handleSublayersChange(t,i),Ee))}normalizeCtorArgs(e){if(!e)return{};const{url:t,title:i,dataPreloadedInLocalCache:a,defaultLinkChartConfig:o}=e;return{url:t,title:i,dataPreloadedInLocalCache:a,defaultLinkChartConfig:o}}_initializeLayerProperties(e){if(!this.title&&this.url){const r=this.url.split("/");this.title=r[r.length-2]}const t=new Set;let i=[],a=[];if(e.inclusionModeDefinition&&(!e.inclusionModeDefinition.namedTypeDefinitions||e.inclusionModeDefinition.namedTypeDefinitions.size<1))throw new Q("knowledge-graph:composite-layer-constructor","If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");e.knowledgeGraph.dataModel.entityTypes?.forEach(r=>{r.name&&this._graphTypeLookup.set(r.name,r)}),e.knowledgeGraph.dataModel.relationshipTypes?.forEach(r=>{r.name&&this._graphTypeLookup.set(r.name,r)}),e.inclusionModeDefinition?.generateAllSublayers?(i=e.knowledgeGraph.dataModel.entityTypes??[],a=e.knowledgeGraph.dataModel.relationshipTypes??[]):e.inclusionModeDefinition?.namedTypeDefinitions&&e.inclusionModeDefinition?.namedTypeDefinitions.size>0?e.inclusionModeDefinition?.namedTypeDefinitions.forEach((r,d)=>{const u=this._graphTypeLookup.get(d);if(!u)return R.getLogger(this).warn(`A named type, ${d}, was in the inclusion list that wasn't in the data model and will be removed`),void e.inclusionModeDefinition?.namedTypeDefinitions.delete(d);u.type==="relationship"?t.has(d)||(t.add(d),a.push(u)):u.type==="entity"?t.has(d)||(t.add(d),i.push(u)):(R.getLogger(this).warn(`A named type, ${d}, was in the inclusion list that wasn't properly modeled and will be removed`),e.inclusionModeDefinition?.namedTypeDefinitions.delete(d))}):(i=e.knowledgeGraph.dataModel.entityTypes??[],a=e.knowledgeGraph.dataModel.relationshipTypes??[]);const o=new Re({knowledgeGraph:e.knowledgeGraph,inclusionModeDefinition:e.inclusionModeDefinition});this.knowledgeGraph=e.knowledgeGraph,this.memberEntityTypes=i,this.memberRelationshipTypes=a,this.dataManager=o}load(e){const t=async()=>{const i=[],a=[];this.loadLayerAssumingLocalCache(),await fe(this),this.dataManager.inclusionModeDefinition&&(this.dataManager.inclusionModeDefinition.generateAllSublayers=!1),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach(o=>{o.useAllData=!1}),await this._initializeDiagram(),this.layers.forEach(o=>{a.push(o.refreshCachedQueryEngine()),i.push(new Promise(r=>{o.on("layerview-create",()=>{r(null)})}))}),this.tables.forEach(o=>{a.push(o.refreshCachedQueryEngine())}),await Promise.all(a)};return this.addResolvingPromise(new Promise(i=>{Qe(this.url).then(async a=>{if(this._initializeLayerProperties({knowledgeGraph:a,inclusionModeDefinition:this._originalInclusionList}),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.size||(this.dataManager.inclusionModeDefinition={generateAllSublayers:!1,namedTypeDefinitions:new Map},this.dataManager.knowledgeGraph.dataModel.entityTypes?.forEach(o=>{o.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(o.name,{useAllData:!0})}),this.dataManager.knowledgeGraph.dataModel.relationshipTypes?.forEach(o=>{o.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(o.name,{useAllData:!0})})),this.dataPreloadedInLocalCache){const o=$e.getInstance();for(const[r,d]of this.dataManager.inclusionModeDefinition?.namedTypeDefinitions??[])for(const u of d.members?.values()??[]){const L=o.readFromStoreById(`${r}__${u.id}`);L&&ce(this.dataManager.sublayerCaches,r,()=>new Map).set(u.id,L)}await t()}else{const o=this.defaultLinkChartConfig?.layoutMode==="GEOGRAPHIC";this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0,!1,o,!0).then(async()=>{Ne(e),await t()}))}i(null)})})),Promise.resolve(this)}set inclusionModeDefinition(e){this.loadStatus!=="loaded"&&this.loadStatus!=="failed"?this._set("inclusionModeDefinition",e):R.getLogger(this).error("#inclusionModeDefinition","inclusionModeDefinition cannot be changed after the layer is loaded.")}async addRecords(e,t){let i=[];t?.cascadeAddRelationshipEndNodes&&this.dataManager.knowledgeGraph.dataModel&&(i=await Oe(e,this.dataManager.knowledgeGraph));const a=e.concat(i).filter(o=>!this.sublayerIdsCache.get(o.typeName)?.has(o.id));await this._handleNewRecords(a)}async removeRecords(e,{cascadeRemoveRelationships:t=!0,recalculateLayout:i=!1}={cascadeRemoveRelationships:!0,recalculateLayout:!1}){let a=[];for(const r of e)this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(r.typeName)?.useAllData===!1&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(r.typeName)?.members?.has(r.id)&&a.push(r);if(t){const r=new Set,d=[];for(const u of a)if(this.dataManager.nodeConnectionsLookup.has(u.id))for(const L of this.dataManager.nodeConnectionsLookup.get(u.id))r.add(L);for(const u of r)if(this.dataManager.memberIdTypeLookup.has(u))for(const L of this.dataManager.memberIdTypeLookup.get(u))this.dataManager.relationshipTypeNames.has(L)&&d.push({id:u,typeName:L});a=a.concat(d)}this.dataManager.removeFromLayer(a);for(const r of a)this.sublayerIdsCache.get(r.typeName)?.delete(r.id),this.dataManager.relationshipTypeNames.has(r.typeName)?this.relationshipLinkChartDiagramLookup.delete(r.id):this.entityLinkChartDiagramLookup.delete(r.id);i&&await this._calculateLayoutWithSublayerTimeInfo(this._currentLinkChartConfig.layoutMode,this._currentLinkChartConfig.layoutOptions);const o=[];return this.layers.forEach(r=>{o.push(r.refreshCachedQueryEngine())}),await Promise.all(o),this._refreshNamedTypes(),a}async expand(e,t){const i=await this.dataManager.getConnectedRecordIds(e,t),a=i.filter(o=>!this.sublayerIdsCache.get(o.typeName)?.has(o.id));return await this._handleNewRecords(i),{records:a}}loadLayerAssumingLocalCache(){const e=[...this.memberRelationshipTypes,...this.memberEntityTypes];this.originIdOf("layers")===ye.DEFAULTS?this._createSublayers(e,this.layers,t=>!!t.geometryType):this._updateSublayers(e,this.layers),this.originIdOf("tables")===ye.DEFAULTS?this._createSublayers(e,this.tables,t=>!t.geometryType):this._updateSublayers(e,this.tables),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((t,i)=>{const a=ce(this.sublayerIdsCache,i,()=>new Set);t.members?.forEach(({id:o,linkChartLocation:r})=>{if(a.add(o),r){const d=r instanceof _e?r:B(r);this.dataManager.relationshipTypeNames.has(i)?this.relationshipLinkChartDiagramLookup.set(o,d):this.entityLinkChartDiagramLookup.set(o,d)}})})}async calculateLinkChartLayout(e="RADIAL_TREE",t){const i=[],a=[],o=[];this.dataManager.sublayerCaches.forEach((n,l)=>{this.dataManager.entityTypeNames.has(l)?n.forEach(s=>{i.push({typeName:l,feature:s})}):this.dataManager.relationshipTypeNames.has(l)&&n.forEach(s=>{a.push({typeName:l,feature:s})})}),this.entityLinkChartDiagramLookup=new Map,this.relationshipLinkChartDiagramLookup=new Map;const r=new Map,d=new Map,u=new Map,L=new Map,k=new Uint8Array(i.length),y=new Float64Array(i.length),m=new Float64Array(i.length),g=new Float64Array(i.length),ne=new Float64Array(i.length),K=new Uint32Array(a.length),X=new Uint32Array(a.length),re=new Float64Array(a.length),se=new Float64Array(a.length),c=[],Le="FORCE_DIRECTED",x=new ue({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7});let P,le="FORCE_DIRECTED",p=0,E=0;const Ce=Ae.apply;switch(le=e==="GEOGRAPHIC"?Le:e,le){case"FORCE_DIRECTED":P=Fe.apply;break;case"COMMUNITY":P=He.apply;break;case"HIERARCHICAL":P=Pe.apply;break;case"RADIAL_TREE":P=Ge.apply;break;case"SMART_TREE":P=Se.apply;break;default:P=ve.apply}let Z=!1;i.forEach(({typeName:n,feature:l})=>{if(e!=="CHRONOLOGICAL_SINGLE"&&e!=="CHRONOLOGICAL_MULTIPLE"&&t?.lockedNodeLocations?.has(l.attributes[T])){e==="GEOGRAPHIC"&&this.dataManager.geographicLookup.has(n)?k[p]=A.IsGeographic:k[p]=A.None;const s=t.lockedNodeLocations.get(l.attributes[T]);y[p]=s.x,m[p]=s.y}else if(e==="GEOGRAPHIC"&&this.dataManager.geographicLookup.has(n)){k[p]=A.IsGeographic;let s=null;const I=l.attributes[this.dataManager.geographicLookup.get(n).name];switch(this.dataManager.geographicLookup.get(n)?.geometryType){case"esriGeometryPoint":y[p]=I?.x,m[p]=I?.y;break;case"esriGeometryPolygon":s=I?.centroid,s?.x!=null&&s?.y!=null?(y[p]=s.x,m[p]=s.y):k[p]=A.IsMovable;break;case"esriGeometryPolyline":case"esriGeometryMultipoint":s=I?.extent?.center,s?.x!=null&&s?.y!=null?(y[p]=s.x,m[p]=s.y):k[p]=A.IsMovable;break;default:k[p]=A.IsMovable}(y[p]==null||m[p]==null||Number.isNaN(y[p])||Number.isNaN(m[p]))&&(k[p]=A.IsMovable,y[p]=0,m[p]=0)}else if(e==="CHRONOLOGICAL_SINGLE"||e==="CHRONOLOGICAL_MULTIPLE"){!Z&&t?.lockedNodeLocations?.has(l.attributes[T])&&(Z=!0);const s=t?.timeInfoByTypeName?.get(n),I=s?.startField,v=I&&s?.startField?l.attributes[I]:null;g[p]=v?new Date(v).getTime():NaN;const C=s?.endField,D=C&&s?.endField?l.attributes[C]:null;ne[p]=D?new Date(D).getTime():NaN,y[p]=0,m[p]=0,k[p]=A.IsMovable}else k[p]=A.IsMovable,y[p]=0,m[p]=0;L.set(l.attributes[T],p),c[p]={feature:l,typeName:n},p++}),Z&&R.getLogger(this).warn("Locked node locations are not supported for chronological layout at this time.  Requested node locations were ignored");let he=!1;const ee=new Map;a.forEach(n=>{const l=n.feature.attributes[J],s=n.feature.attributes[V],I=L.get(l),v=L.get(s),C=t?.timeInfoByTypeName?.get(n.typeName),D=t?.timeInfoByTypeName?C?.startField:null,O=D?n.feature.attributes[D]:null,j=C?.endField,H=j?n.feature.attributes[j]:null;if(I!==void 0&&v!==void 0){let S=l+"-"+s;e!=="CHRONOLOGICAL_SINGLE"&&e!=="CHRONOLOGICAL_MULTIPLE"||(S=S+"-"+O+"-"+H);const U=ee.get(S);U?.has(n.typeName)||(K[E]=I,X[E]=v,e!=="CHRONOLOGICAL_SINGLE"&&e!=="CHRONOLOGICAL_MULTIPLE"||(re[E]=O?new Date(O).getTime():NaN,se[E]=H?new Date(H).getTime():NaN),U===void 0?ee.set(S,new Map([[n.typeName,E]])):U.set(n.typeName,E),E++),o.push(n)}else he=!0,this.relationshipLinkChartDiagramLookup.set(l,null)}),he&&R.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null");const pe=this._validateLayoutSettings(e,t),te=this._convertLayoutSettingsToCalculationSettings(pe);await Ue();let z=!1,N=null;if(e==="CHRONOLOGICAL_SINGLE"||e==="CHRONOLOGICAL_MULTIPLE"){let n;({success:z,links:N,graphics:n}=Ce(k,y,m,g,ne,K.subarray(0,E),X.subarray(0,E),re.subarray(0,E),se.subarray(0,E),e==="CHRONOLOGICAL_MULTIPLE",t?.chronologicalLayoutSettings??{})),z&&(this.chronologicalAuxiliaryGraphics=n)}else({success:z,links:N}=P(k,y,m,K.subarray(0,E),X.subarray(0,E),te.computationBudgetTime,te.idealEdgeLengthMultiplier,te.repulsionRadiusMultiplier));if(!z)throw new Q("knowledge-graph:layout-failed","Attempting to arrange the records in the specified layout failed");for(let n=0;n<c.length;n++){if(m[n]>84.9999?m[n]=84.9999:m[n]<-84.9999&&(m[n]=-84.9999),y[n]>179.9999?y[n]=179.9999:y[n]<-179.9999&&(y[n]=-179.9999),c[n].feature.attributes[b]=new oe(y[n],m[n]),r.has(c[n].typeName))r.get(c[n].typeName)?.set(c[n].feature.attributes[T],c[n].feature);else{const s=new Map;s.set(c[n].feature.attributes[T],c[n].feature),r.set(c[n].typeName,s)}u.set(c[n].feature.attributes[T],c[n].feature);const l=B(c[n].feature.attributes[b]);this.entityLinkChartDiagramLookup.set(c[n].feature.attributes[T],c[n].feature.attributes[b]?l:null),c[n].feature.attributes[b].x<x.xmin&&(x.xmin=c[n].feature.attributes[b].x),c[n].feature.attributes[b].x>x.xmax&&(x.xmax=c[n].feature.attributes[b].x),c[n].feature.attributes[b].y<x.ymin&&(x.ymin=c[n].feature.attributes[b].y),c[n].feature.attributes[b].y>x.ymax&&(x.ymax=c[n].feature.attributes[b].y)}if(this.linkChartExtent.xmin=x.xmin,this.linkChartExtent.xmax=x.xmax,this.linkChartExtent.ymin=x.ymin,this.linkChartExtent.ymax=x.ymax,!N)throw new Q("knowledge-graph:layout-failed","Attempting to retrieve link geometry from diagram engine failed");const W=new Map,ae=new Map,ie=new Map,de=new Set;for(let n=0;n<o.length;n++){const l=[],s=o[n],I=s.feature.attributes[J],v=s.feature.attributes[V];let C=I+"-"+v;if(e==="CHRONOLOGICAL_SINGLE"||e==="CHRONOLOGICAL_MULTIPLE"){const h=t?.timeInfoByTypeName?.get(s.typeName),_=t?.timeInfoByTypeName?h?.startField:null,G=_?s.feature.attributes[_]:null,F=h?.endField;C+="-"+G+"-"+(F?s.feature.attributes[F]:null)}const D=ee.get(C).get(s.typeName),O=D===0?0:N?.vertexEndIndex[D-1];if(!de.has(D)){if(de.add(D),N.types[D]===ge.Recursive){const h=[N.vertices[2*O],N.vertices[2*O+1]],_=[N.vertices[2*(O+1)],N.vertices[2*(O+1)+1]],G=[.5*(h[0]+_[0]),.5*(h[1]+_[1])],F=[G[0]-h[0],G[1]-h[1]],be=[G[0]+F[1],G[1]-F[0]],ke=[G[0]-F[1],G[1]+F[0]];l.push(h),l.push(be),l.push(_),l.push(ke),l.push(h)}else{if(N.types[D]!==ge.Regular){R.getLogger(this).warn("A relationship generated an unsupported link geometry type.  It will not be rendered");continue}for(let h=O;h<N.vertexEndIndex[D];h++)l.push([N.vertices[2*h],N.vertices[2*h+1]])}if(e!=="CHRONOLOGICAL_SINGLE"&&e!=="CHRONOLOGICAL_MULTIPLE"){const h=c[L.get(I)]?.feature.attributes[b],_=c[L.get(v)]?.feature.attributes[b];l[0][0]===h.x&&l[0][1]===h.y||(l[0]=[h.x,h.y]),l[l.length-1][0]===_.x&&l[l.length-1][1]===_.y||(l[l.length-1]=[_.x,_.y])}for(let h=1;h<l.length-1;h++)l[h][1]>85.5?l[h][1]=85.5:l[h][1]<-85.5&&(l[h][1]=-85.5),l[h][0]>179.9999?l[h][0]=179.9999:l[h][0]<-179.9999&&(l[h][0]=-179.9999);W.has(C)?W.get(C).push(l):W.set(C,[l])}const j=W.get(C);ae.has(C)||(ae.set(C,new Map),ie.set(C,new Map));const H=ae.get(C),S=ie.get(C);H.has(s.typeName)||(H.set(s.typeName,j.shift()),S.set(s.typeName,0));const U=H.get(s.typeName);S.set(s.typeName,S.get(s.typeName)+1);const Me=new me({paths:[U]});if(s.feature.attributes[b]=Me,d.has(s.typeName))d.get(s.typeName)?.set(s.feature.attributes[T],s.feature);else{const h=new Map;h.set(s.feature.attributes[T],s.feature),d.set(s.typeName,h)}u.set(s.feature.attributes[T],s.feature);const we=B(s.feature.attributes[b]);this.relationshipLinkChartDiagramLookup.set(s.feature.attributes[T],s.feature.attributes[b]?we:null)}for(const n of o)n.feature.attributes[Be]=ie.get(n.feature.attributes[J]+"-"+n.feature.attributes[V])?.get(n.typeName)??null;return this._currentLinkChartConfig={layoutMode:e,layoutOptions:pe},{nodes:r,links:d,idMap:u}}async applyNewLinkChartLayout(e="RADIAL_TREE",t){const i=[];await this._calculateLayoutWithSublayerTimeInfo(e,t),this.layers.forEach(a=>{i.push(a.refreshCachedQueryEngine())}),await Promise.all(i),this._refreshNamedTypes()}getCurrentNodeLocations(){const e=new Map;return this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach(t=>{t?.members?.forEach(i=>{const a=i.linkChartLocation;let o;const r=i.id;a&&(o="x"in a?{x:a.x,y:a.y}:{x:a.coords[0],y:a.coords[1]},e.set(r,new oe({x:o.x,y:o.y})))})}),e}async synchronizeInclusionListWithCache(){return new Promise(e=>{this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((t,i)=>{if(t.useAllData=!1,t.members&&t.members.size>0){if(!this.dataManager.sublayerCaches.get(i))return;const a=new Set(Array.from(this.dataManager.sublayerCaches.get(i).keys()));Array.from(t.members.keys()).filter(o=>!a.has(o)).forEach(o=>{t.members?.delete(o)})}}),e()})}async refreshLinkChartCache(e){await this.dataManager.refreshCacheContent(e);const t=[];this.layers.forEach(i=>{t.push(i.refreshCachedQueryEngine())}),await Promise.all(t),this._refreshNamedTypes()}async connectBetweenEntities(e){let t=[];for(const a of this.dataManager.relationshipTypeNames){const o=this.sublayerIdsCache.get(a);o&&(t=t.concat(Array.from(o.keys())))}const i=await this.dataManager.getRelationshipsBetweenNodes(e,t);return await this._handleNewRecords(i),{records:i}}async connectFromEntities(e){let t=[];for(const o of this.dataManager.relationshipTypeNames){const r=this.sublayerIdsCache.get(o);r&&(t=t.concat(Array.from(r.keys())))}let i=[];for(const o of this.dataManager.entityTypeNames){const r=this.sublayerIdsCache.get(o);r&&(i=i.concat(Array.from(r)))}const a=await this.dataManager.getRelationshipsFromNodes(e,i,t);return await this._handleNewRecords(a),{records:a}}getCurrentLayout(){return this._currentLinkChartConfig.layoutMode}async _calculateLayoutWithSublayerTimeInfo(e="RADIAL_TREE",t){const i=new Map;this.layers.forEach(a=>{i.set(a.objectType.name,a.timeInfo)}),await this.calculateLinkChartLayout(e,{timeInfoByTypeName:i,...t})}async _handleNewRecords(e){const t=[];this.dataManager.addToLayer(e);for(const a of e)this.sublayerIdsCache.has(a.typeName)||(this.sublayerIdsCache.set(a.typeName,new Set),t.push(a.typeName)),this.sublayerIdsCache.get(a.typeName).add(a.id);for(const a of t){const o=this._graphTypeLookup.get(a);if(o){const r=this._createSublayer(o);o.type==="entity"?this.dataManager.entityTypeNames.add(a):this.dataManager.relationshipTypeNames.add(a),r.geometryType?this.layers.push(r):this.tables.push(r),this.dataManager.sublayerCaches.set(a,new Map)}}await fe(this,t),await this.dataManager.refreshCacheContent(e.map(a=>a.id));const i=Object.assign({},this._currentLinkChartConfig.layoutOptions);i.lockedNodeLocations=new Map;for(const[a,o]of this.entityLinkChartDiagramLookup.entries())o&&i.lockedNodeLocations.set(a,new oe(o.coords[0],o.coords[1]));await this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode,i)}_createSublayers(e,t,i){e.forEach(a=>{const o=this._createSublayer(a);i(o)&&t.push(o),this._updateSublayerCaches(a)})}_updateSublayers(e,t){t.forEach(i=>{i.parentCompositeLayer=this;const a=e.find(o=>o.type===i.graphType&&o.name===i.graphTypeName);a&&(i.objectType=a,i.read({title:a.name},{origin:"service"}),this._updateSublayerCaches(a))})}_updateSublayerCaches(e){const t=this.dataManager.sublayerCaches;t.has(e.name)||t.set(e.name,new Map)}async _initializeDiagram(){this.defaultLinkChartConfig?this.defaultLinkChartConfig.doNotRecalculateLayout?(this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e,t)=>{e?.members?.forEach(i=>{const a=i.linkChartLocation;let o;const r=i.id;if(!a)return;o="x"in a?{x:a.x,y:a.y}:{x:a.coords[0],y:a.coords[1]};const d=B(o);this.dataManager.relationshipTypeNames.has(t)?this.relationshipLinkChartDiagramLookup.set(r,d):this.entityLinkChartDiagramLookup.set(r,d),this.linkChartExtent.xmin>o.x&&(this.linkChartExtent.xmin=o.x),this.linkChartExtent.xmax<o.x&&(this.linkChartExtent.xmax=o.x),this.linkChartExtent.ymin>o.y&&(this.linkChartExtent.ymin=o.y),this.linkChartExtent.ymax<o.y&&(this.linkChartExtent.ymax=o.y)})}),this.memberRelationshipTypes.forEach(e=>{e.name&&this.dataManager.sublayerCaches.get(e.name)?.forEach(t=>{const i=this.relationshipLinkChartDiagramLookup.get(t.attributes[J]),a=this.relationshipLinkChartDiagramLookup.get(t.attributes[V]);if(i&&a){const o=B(new me({paths:[[[i.coords[0],i.coords[1]],[a.coords[0],a.coords[1]]]]}));this.relationshipLinkChartDiagramLookup.set(t.attributes[T],o)}else this.relationshipLinkChartDiagramLookup.set(t.attributes[T],null)})})):await this._calculateLayoutWithSublayerTimeInfo(this.defaultLinkChartConfig.layoutMode,{lockedNodeLocations:this.getCurrentNodeLocations(),...this.defaultLinkChartConfig.layoutOptions||{}}):await this._calculateLayoutWithSublayerTimeInfo("RADIAL_TREE",{lockedNodeLocations:this.getCurrentNodeLocations()})}_refreshNamedTypes(){for(const e of this.layers)e.emit("refresh",{dataChanged:!0});for(const e of this.tables)e.emit("refresh",{dataChanged:!0})}_validateLayoutSettings(e,t){const i=g=>typeof g=="number"&&!isNaN(g),a=g=>i(g)&&g>=1,o=g=>i(g)&&g>=1,r=g=>Object.values(q).includes(g),d=g=>i(g)&&g>=0,u={organicLayoutSettings:{},chronologicalLayoutSettings:{}};if(!new Set(["FORCE_DIRECTED","COMMUNITY","GEOGRAPHIC","CHRONOLOGICAL_MULTIPLE","CHRONOLOGICAL_SINGLE"]).has(e)||!t)return u;t.organicLayoutSettings??={};const{computationBudgetTime:L,repulsionRadiusMultiplier:k,idealEdgeLength:y,idealEdgeLengthType:m}=t.organicLayoutSettings;if(o(L)?u.organicLayoutSettings.computationBudgetTime=L:L!==void 0&&R.getLogger(this).warn("Invalid layout computationBudgetTime setting, will revert to default setting"),a(k)?u.organicLayoutSettings.repulsionRadiusMultiplier=k:k!==void 0&&R.getLogger(this).warn("Invalid layout repulsionRadiusMultiplier setting, will revert to default setting"),e==="GEOGRAPHIC"&&(y!==void 0||m!==void 0)&&(r(m)?u.organicLayoutSettings.idealEdgeLengthType=m:m!==void 0&&R.getLogger(this).warn('Invalid layout idealEdgeLengthType setting, will revert to "multiplier" setting'),d(y)?u.organicLayoutSettings.idealEdgeLength=y:y!==void 0&&R.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting")),(e==="CHRONOLOGICAL_MULTIPLE"||e==="CHRONOLOGICAL_SINGLE")&&t.chronologicalLayoutSettings){const g=t.chronologicalLayoutSettings;g.durationLineWidth&&g.durationLineWidth<0&&R.getLogger(this).warn("Invalid layout durationLineWidth setting, will revert to default setting")}return u}_convertLayoutSettingsToCalculationSettings(e){e.organicLayoutSettings??={};let t=e.organicLayoutSettings.idealEdgeLength;return e.organicLayoutSettings.idealEdgeLengthType===q.ABSOLUTE&&(t===void 0?t=-1:t*=-1),{computationBudgetTime:e.organicLayoutSettings.computationBudgetTime,repulsionRadiusMultiplier:e.organicLayoutSettings.repulsionRadiusMultiplier,idealEdgeLengthMultiplier:t}}_createSublayer(e){return new $({objectType:e,parentCompositeLayer:this,graphType:e.type})}_handleSublayersChange(e,t){t&&(t.forEach(i=>{i.parent=null}),this.removeHandles("sublayers-owner")),e&&(e.forEach(i=>{i.parent=this}),this.addHandles([e.on("after-add",({item:i})=>{i.parent=this}),e.on("after-remove",({item:i})=>{i.parent=null})],"sublayers-owner"))}};M([w()],f.prototype,"dataPreloadedInLocalCache",void 0),M([w()],f.prototype,"defaultLinkChartConfig",void 0),M([w()],f.prototype,"dataManager",void 0),M([w()],f.prototype,"inclusionModeDefinition",null),M([w()],f.prototype,"knowledgeGraph",void 0),M([w({type:Y.ofType($),json:{write:{ignoreOrigin:!0}}})],f.prototype,"layers",void 0),M([w()],f.prototype,"entityLinkChartDiagramLookup",void 0),M([w()],f.prototype,"relationshipLinkChartDiagramLookup",void 0),M([w()],f.prototype,"linkChartExtent",void 0),M([w()],f.prototype,"memberEntityTypes",void 0),M([w()],f.prototype,"memberRelationshipTypes",void 0),M([w({type:["LinkChartLayer"]})],f.prototype,"operationalLayerType",void 0),M([w()],f.prototype,"sublayerIdsCache",void 0),M([w({type:Y.ofType($),json:{write:{ignoreOrigin:!0}}})],f.prototype,"tables",void 0),M([w({json:{read:!1}})],f.prototype,"type",void 0),M([w({json:{read:!1}})],f.prototype,"chronologicalAuxiliaryGraphics",void 0),f=M([Ie("esri.layers.LinkChartLayer")],f);const Ga=f;export{Ga as default};
