import{i as qt,e as At}from"./SimpleGeometryCursor-DSF_YyIm-TAMgMsbK.js";import{Y as Et,R as Rt,G as ut,V as St,d as zt,Z as T,i as Bt,s as Yt,q as Xt,h as V,au as Ot,c as Ft,a as Wt,v as w,r as k,b7 as q,t as O}from"./Point2D-CaHJVGk1-JqvJXjLr.js";import{Envelope2D as M}from"./Envelope2D-DlBzXkgv-eKRxGysX.js";import{h as J,u as N,m as Jt,R as Ut,V as ct,b as gt,F as U,s as nt,e as Dt,o as pt,q as $,A as Vt,t as $t,B,M as K,W as jt,x as Ht,G as Z,J as Pt,a as xt,N as mt,P as ot,Q as Lt,U as at,_ as A,$ as Y,C as x,D as S,H as Qt,a7 as Kt,a5 as Zt,a6 as te,a0 as it,a1 as tt,a2 as et,a3 as bt,a4 as ee}from"./ProjectionTransformation-DQ4GElxa-BRBTH2Y-.js";import{im as v,io as E}from"./main-DXQSfJ4c.js";import{E as W}from"./Transformation2D-CXWnDKXs-CjsleQQw.js";import{g as se}from"./GeometryCleaner-BEJM7I4l-DzJanffG-DFuxyxcM.js";import"./OperatorDefinitions-DJdq_wrt-DP7_WWTp.js";function ne(p,t,s,e,o,m){e<Number.MAX_VALUE&&e>-Number.MAX_VALUE||ut("Geodesic_bufferer.buffer - bad distance"),St(p);const i=se(p),r=i.getGeometryType();if(zt(r)){const n=i.getPointCount(),u=8e6;if(Math.abs(e)>u&&(n>50||r!==T.enumMultiPoint&&s===4&&n>2)){let a=i;const _=e>0?1:-1,h=7e6;let c=e,l=1;do l++,c=(Math.abs(c)-h)*_;while(Math.abs(c)>u);c=e;for(let f=0;f<l-1;f++)a=ht(a,t,s,h*_,o,l,m),c=(Math.abs(c)-h)*_;return a=ht(a,t,s,c,o,l,m),a}}return ht(i,t,s,e,o,1,m)}class ie{constructor(t){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=t}bufferPolygon(t){const s=new N,e=new Ct(this,t,s);return this.processGnomonicBufferPiecesCursor(!0,e)}bufferPolyline(t){const s=new Ct(this,t,null);return this.processGnomonicBufferPiecesCursor(!0,s)}bufferMultiPoint(t){const s=new oe(this,t);return this.processGnomonicBufferPiecesCursor(!1,s)}bufferPoint(t){const s=t.getXY();s.scale(this.m_rpu);let e=new N;if(this.bufferPoint2D(s,!1,e)){const o=B(null,e,!0);e=K(e,o,!0,!0,-1,this.m_progressTracker,0,!1)}return e=new $().foldInto360RangeGeodetic(e,this.m_gcs,2),e}processGnomonicBufferPiecesCursor(t,s){const e=s;let o=e.getGnomonic();const m=jt(Ht());let i=new Z,r=new J().executeMany(i,m,this.m_progressTracker,2);const n=Ft(6,!1),u=Wt(M,6);this.initializeGrid(n,u);const a=[null,null,null,null,null,null],_=[null,null,null,null,null,null],h=[null,null,null,null,null,null];let c,l,f;for(;(c=e.next())!==null;){if(l=e.getGnomonic(),l!==o){if(o!==null){let g=r.next();if(i=null,r=null,g!=null){const C=B(m,g,!0),P=U(C);g=o.unproject(g,P,this.m_progressTracker),this.putInGridCursors(t,g,m,!0,n,u,a,_,h)}}l!==null&&(i=new Z,r=new J().executeMany(i,m,this.m_progressTracker,2)),o=l}if(e.isRunningInGnomonic()){if(l.project(c),e.needsSimplify()){const g=B(null,c,!0);c=K(c,g,!0,!0,-1,this.m_progressTracker,0,!1)}i.tick(st(c)),r.tock()}else this.putInGridCursors(t,c,m,!0,n,u,a,_,h)}let d=!1;for(let g=0;g<6;g++)if(h[g]!=null){d=!0;break}if(d){let g=!1;const C=[null,null,null,null,null,null];if(t){const b=e.m_densified;if(e.m_densified=null,b!==null){const y=new W;y.scale(1/this.m_rpu,1/this.m_rpu),b.applyTransformation(y),this.m_distance>0?this.putInGridCursors(t,b,m,!1,n,u,a,_,h):(this.processInGrid(t,b,!1,n,u,a,C),g=!0)}}const P=new Z,D=new J().executeMany(P,this.m_gcs,this.m_progressTracker,2);if(r!==null){let b=r.next();i=null,r=null;const y=B(m,b,!0),G=U(y);b=o.unproject(b,G,this.m_progressTracker),this.putInGridCursors(t,b,m,!0,n,u,a,_,h)}for(let b=0;b<6;b++)if(h[b]!=null){let y=h[b].next();h[b]=null,_[b]=null,g&&C[b]!==null&&(y=new Pt().execute(C[b],y,m,this.m_progressTracker));const G=B(m,y,!0),I=U(G);y=a[b].unproject(y,I,this.m_progressTracker),y=new xt().execute(y,this.m_gcs,!0,this.m_progressTracker),P.tick(st(y)),D.tock()}f=D.next()}else{let g,C=!1;if(t){let y=e.m_densified;if(e.m_densified=null,y!==null){const G=new W;G.scale(1/this.m_rpu,1/this.m_rpu),y.applyTransformation(G),l.project(y);const I=B(null,y,!0);y=K(y,I,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(i.tick(st(y)),r.tock()):(g=y,C=!0)}}let P=r.next();i=null,r=null,C&&(P=new Pt().execute(g,P,m,this.m_progressTracker));const D=B(m,P,!0),b=U(D);f=o.unproject(P,b,this.m_progressTracker),f=new xt().execute(f,this.m_gcs,!0,this.m_progressTracker)}return f=new $().foldInto360RangeGeodetic(f,this.m_gcs,2),f}putInGridCursors(t,s,e,o,m,i,r,n,u){const a=[null,null,null,null,null,null];this.processInGrid(t,s,o,m,i,r,a);for(let _=0;_<6;_++)a[_]!==null&&(n[_]===null&&(n[_]=new Z,u[_]=new J().executeMany(n[_],e,this.m_progressTracker,2)),n[_].tick(st(a[_])),u[_].tock())}processInGrid(t,s,e,o,m,i,r){const n=this.insertGeodeticPointsAlongGrid(s,m,.01);for(let u=0;u<6;u++){if(o[u])continue;const a=m[u].clone();a.inflateCoords(.01,.01);const _=mt(s,a),h=nt(null,_,!1).total();let c=ot(n,a,h,Number.NaN,this.m_progressTracker);if(c!==null&&!c.isEmpty()){if(c===n&&(c=c.clone()),i[u]===null){const f=new w;u<3?f.setCoords(0,1):f.setCoords(0,-1);const d=new w;d.setAdd(m[u].getCenter(),f),i[u]=H(this.m_gcs,d)}i[u].project(c);const l=B(null,c,!0);c=K(c,l,e,!0,-1,this.m_progressTracker,0,!1),r[u]=c}}}insertGeodeticPointsAlongGrid(t,s,e){const o=M.construct(s[3].xmin,s[3].ymin,s[2].xmax,s[2].ymax),m=Lt(this.m_gcs,o,t,!0,this.m_progressTracker),i=new at,r=i.addGeometry(m);return A(i,r,this.m_gcs,0,2,!0,s[0].xmax+e),A(i,r,this.m_gcs,0,2,!0,s[1].xmax+e),A(i,r,this.m_gcs,0,2,!1,s[1].ymin+e),e!==0&&(A(i,r,this.m_gcs,0,2,!0,s[0].xmax-e),A(i,r,this.m_gcs,0,2,!0,s[1].xmax-e),A(i,r,this.m_gcs,0,2,!1,s[1].ymin-e)),i.getGeometry(r)}initializeGrid(t,s){for(let e=0;e<6;e++)t[e]=!1;s[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),s[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),s[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),s[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),s[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),s[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(t,s,e,o,m,i){const r=t[0],n=t.at(-1),u=r.y<n.y?r.y:n.y,a=r.y>n.y?r.y:n.y,_=ct.q(this.m_a,this.m_eSquared,u),h=ct.q(this.m_a,this.m_eSquared,a);if(this.m_q90-(_+s+this.m_absDistance)>.001&&this.m_q90+(h-s-this.m_absDistance)>.001)return!1;const c=e-O,l=o+O,f=c-Math.PI,d=c+Math.PI,g=l+Math.PI,C=[Number.NaN],P=[Number.NaN],D=[Number.NaN],b=[Number.NaN];let y=!1;if(yt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,r,c,f,n,l,C,P),yt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,n,g,l,r,f,D,b),(l<C[0]&&C[0]<g||l<P[0]&&P[0]<g)&&(y=!0),y||(f<D[0]&&D[0]<c||f<b[0]&&b[0]<c)&&(y=!0),!y&&m)return!1;const G=[];for(let R=t.length-1;R>=0;R--)G.push(t[R]);i.setEmpty(),i.addPathPoint2D(null,0,!0);let I=0;I=lt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,t,c,l,m,I,i),I=j(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,n,l,g,this.m_cornerStep,m,I,i,C[0],P[0]),I=lt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,G,g,d,m,I,i),I=j(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,r,f,c,this.m_cornerStep,m,I,i,D[0],b[0]);let X=!1;return m||(X=this.checkAndPrepForPole(i)),y||X}bufferPoint2D(t,s,e){e.setEmpty(),e.addPathPoint2D(null,0,!0),j(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,t,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,s,0,e);let o=!1;return s||(o=this.checkAndPrepForPole(e)),o}checkAndPrepForPole(t){const s=this.checkAndPrepForPoleTouch(t),e=this.checkAndPrepForPoleWrap(t);return s||e}checkAndPrepForPoleTouch(t){const s=new M;return t.queryEnvelope(s),!(!Y(s.ymax,this.m_gcs90)&&!Y(s.ymin,-this.m_gcs90))&&(this.prepPoleTouch(t),!0)}checkAndPrepForPoleWrap(t){const s=t.getXY(0),e=t.getXY(t.getPointCount()-1);return Math.abs(s.x-e.x)>this.m_gcs180?(this.prepSinglePoleWrap(t),!0):this.checkAndPrepForDoublePoleWrap(t)}checkAndPrepForDoublePoleWrap(t){return t.calculateArea2D()<0&&(this.prepDoublePoleWrap(t),!0)}prepPoleTouch(t){const s=new N;s.insertPath2D(-1,null,0,0,!0);const e=t.getPathStart(0),o=t.getPathEnd(0),m=o-e;let i=-1;for(i=e;i<o;i++){const a=t.getXY(i),_=Y(a.y,this.m_gcs90),h=Y(a.y,-this.m_gcs90);if(!_&&!h)break}let r=i,n=!1,u=Number.NaN;do{const a=t.getXY(r),_=Y(a.y,this.m_gcs90),h=Y(a.y,-this.m_gcs90),c=e+(r+1-e)%m;if(_||h){let l=w.construct(u,a.y);s.insertPoint2D(0,-1,l);const f=t.getXY(c),d=Y(f.y,this.m_gcs90),g=Y(f.y,-this.m_gcs90);d||g||(l=w.construct(f.x,a.y),n?s.setXY(s.getPointCount()-1,l):s.insertPoint2D(0,-1,l)),n=!0}else s.insertPoint2D(0,-1,a),u=a.x,n=!1;r=c}while(r!==i);t.setEmpty(),t.add(s,!1)}prepSinglePoleWrap(t){const s=new N,e=new N,o=new W,m=t.getXY(t.getPathStart(0)),i=t.getXY(t.getPathEnd(0)-1),r=this.m_gcs360,n=this.m_gcs180,u=new M;u.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const a=new M;t.queryEnvelope(a);const _=Math.ceil(a.width()/r);let h,c;m.x>i.x?(h=-r,c=this.m_gcs90):(h=r,c=-this.m_gcs90),o.setShiftCoords(h,0),s.addPath(t,0,!0),e.add(s,!1);const l=new Dt;for(let z=0;z<_;z++)e.applyTransformation(o),e.getPointByVal(0,l),s.lineToPoint(l),s.addSegmentsFromPath(e,0,0,e.getSegmentCount()-1,!1);const f=s.getXY(0),d=s.getXY(s.getPointCount()-1);f.y=c,d.y=c,s.lineTo(d);const g=new w;for(g.setCoordsPoint2D(d),g.x-=.5*h;Math.abs(g.x-f.x)>n;)s.lineTo(g),g.x-=.5*h;s.lineTo(f);const C=u.getCenterX(),P=new M;s.queryEnvelope(P);let D=0;const b=P.getCenter().x;b-C>n?D=-Math.ceil((b-C-n)/r):C-b>n&&(D=Math.ceil((C-b-n)/r)),D!==0&&(o.setShiftCoords(D*r,0),s.applyTransformation(o));const y=new at,G=y.addGeometry(s);A(y,G,this.m_gcs,0,2,!0,u.xmin),A(y,G,this.m_gcs,0,2,!0,u.xmax);const I=y.getGeometry(G),X=mt(I,u);X.inflateCoords(0,1);const R=nt(null,X,!0).total(),F=ot(I,u,R,Number.NaN,this.m_progressTracker);t.setEmpty(),t.add(F,!1)}prepDoublePoleWrap(t){const s=this.m_gcs360,e=this.m_gcs180,o=new M;o.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const m=o.getCenter().x,i=new M;t.queryPathEnvelope(0,i);let r,n=0,u=i.getCenter().x;if(u-m>e?n=-Math.ceil((u-m-e)/s):m-u>e&&(n=Math.ceil((m-u-e)/s)),n!==0){const c=new W;c.setShiftCoords(n*s,0),t.getImpl().applyTransformationToPath(c,0),t.queryPathEnvelope(0,i),u=i.getCenter().x}const a=new M;o.containsExclusiveEnvelope(i)?(r=!1,a.setCoords({env2D:o})):(r=!0,a.setCoords({env2D:o}),a.xmin-=s,a.xmax+=s);let _=t.createInstance();_.addPathPoint2D(null,0,!0);const h=new w;if(h.setCoords(a.xmin,a.ymin),_.insertPoint2D(0,-1,h),h.setCoords(a.xmin,a.ymax),_.insertPoint2D(0,-1,h),h.setCoords(.5*(a.xmin+a.xmax),a.ymax),_.insertPoint2D(0,-1,h),h.setCoords(a.xmax,a.ymax),_.insertPoint2D(0,-1,h),h.setCoords(a.xmax,a.ymin),_.insertPoint2D(0,-1,h),h.setCoords(.5*(a.xmin+a.xmax),a.ymin),_.insertPoint2D(0,-1,h),r){_.addPath(t,0,!0);const c=new W;u<m?c.setShiftCoords(s,0):c.setShiftCoords(-s,0),t.getImpl().applyTransformationToPath(c,0),_.addPath(t,0,!0);const l=new at,f=l.addGeometry(_);A(l,f,this.m_gcs,0,2,!0,o.xmin),A(l,f,this.m_gcs,0,2,!0,o.xmax),_=l.getGeometry(f);const d=mt(_,o);d.inflateCoords(0,1);const g=nt(null,d,!0).total();_=ot(_,o,g,Number.NaN,this.m_progressTracker)}else _.addPath(t,0,!0);t.setEmpty(),t.add(_,!1)}setMinCornerStep(){const t={stack:[],error:void 0,hasError:!1};try{let s=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);s=Math.min(s,.125*this.m_a*Math.PI);const e=new w;e.setCoords(0,10*this.m_rpu);const o=0;let m=45*this.m_rpu;const i=v(t,new k(new x,new x),!1),r=v(t,new k(new x,new x),!1),n=v(t,new k(new x,new x),!1),u=v(t,new k(new x,new x),!1),a=new w,_=new w,h=new w,c=new w;for(S.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,o,i.at(0),i.at(1)),a.setCoords(i.at(0).val,i.at(1).val),S.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,m,r.at(0),r.at(1)),_.setCoords(r.at(0).val,r.at(1).val);;){const d={stack:[],error:void 0,hasError:!1};try{const g=.5*(o+m);S.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,g,n.at(0),n.at(1)),h.setCoords(n.at(0).val,n.at(1).val);const C=v(d,new x,!1),P=v(d,new x,!1);S.geodeticDistance(this.m_a,this.m_eSquared,a.x,a.y,_.x,_.y,C,P,null,2),S.geodeticCoordinate(this.m_a,this.m_eSquared,a.x,a.y,.5*C.val,P.val,u.at(0),u.at(1),2),c.setCoords(u.at(0).val,u.at(1).val);const D=v(d,new x,!1);if(S.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,c.x,c.y,D,null,null,2),D.val<=this.m_convergenceOffset)break;m*=.9,S.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,m,r.at(0),r.at(1)),_.setCoords(r.at(0).val,r.at(1).val)}catch(g){d.error=g,d.hasError=!0}finally{E(d)}}const l=m-o,f=2*Math.PI/Math.ceil(2*Math.PI/l);this.m_cornerStep=f}catch(s){t.error=s,t.hasError=!0}finally{E(t)}}setMinSegmentStep(){const t={stack:[],error:void 0,hasError:!1};try{let s=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);s=Math.min(s,.125*this.m_a*Math.PI);const e=new w,o=new w;e.setCoords(0,10*this.m_rpu),o.setCoords(10*this.m_rpu,10*this.m_rpu);const m=v(t,new x,!1),i=v(t,new x,!1),r=v(t,new x,!1);S.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,o.x,o.y,r,m,i,this.m_curveType);const n=v(t,new k(new x,new x),!1),u=v(t,new k(new x,new x),!1),a=new w,_=v(t,new x,!1),h=v(t,new k(new x,new x),!1),c=v(t,new k(new x,new x),!1),l=v(t,new k(new x,new x),!1),f=v(t,new k(new x,new x),!1),d=new w,g=new w,C=new w,P=new w,D=0;let b=1;const y=m.val,G=i.val,I=y-.5*Math.PI,X=G+.5*Math.PI,R=r.val;for(S.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,I,h.at(0),h.at(1)),d.setCoords(h.at(0).val,h.at(1).val),S.geodesicCoordinate(this.m_a,this.m_eSquared,o.x,o.y,s,X,c.at(0),c.at(1)),g.setCoords(c.at(0).val,c.at(1).val);;){const z={stack:[],error:void 0,hasError:!1};try{const rt=.5*(D+b);S.geodeticCoordinate(this.m_a,this.m_eSquared,e.x,e.y,rt*R,y,n.at(0),n.at(1),this.m_curveType),a.setCoords(n.at(0).val,n.at(1).val),S.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,a.x,a.y,null,null,_,this.m_curveType);const Tt=_.val+.5*Math.PI;S.geodesicCoordinate(this.m_a,this.m_eSquared,a.x,a.y,s,Tt,l.at(0),l.at(1)),C.setCoords(l.at(0).val,l.at(1).val);const _t=v(z,new x,!1),ft=v(z,new x,!1);S.geodeticDistance(this.m_a,this.m_eSquared,d.x,d.y,g.x,g.y,_t,ft,null,2),S.geodeticCoordinate(this.m_a,this.m_eSquared,d.x,d.y,.5*_t.val,ft.val,f.at(0),f.at(1),2),P.setCoords(f.at(0).val,f.at(1).val);const dt=v(z,new x,!1);if(S.geodeticDistance(this.m_a,this.m_eSquared,C.x,C.y,P.x,P.y,dt,null,null,2),dt.val<=this.m_convergenceOffset)break;{const L={stack:[],error:void 0,hasError:!1};try{b*=.9,S.geodeticCoordinate(this.m_a,this.m_eSquared,e.x,e.y,b*R,y,u.at(0),u.at(1),this.m_curveType),o.setCoords(u.at(0).val,u.at(1).val);const Q=v(L,new x,!1);S.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,o.x,o.y,null,null,Q,this.m_curveType);const kt=Q.val+.5*Math.PI;S.geodesicCoordinate(this.m_a,this.m_eSquared,o.x,o.y,s,kt,c.at(0),c.at(1)),g.setCoords(c.at(0).val,c.at(1).val)}catch(Q){L.error=Q,L.hasError=!0}finally{E(L)}}}catch(rt){z.error=rt,z.hasError=!0}finally{E(z)}}let F=b*R;F>1e5&&(F=1e5),this.m_segmentStep=F}catch(s){t.error=s,t.hasError=!0}finally{E(t)}}setConvergenceOffset(){let t;t=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/t<500&&(t=this.m_absDistance/500),t<.01&&(t=.01),this.m_convergenceOffset=t}}function ht(p,t,s,e,o,m,i){if(p.isEmpty())return new N({vd:p.getDescription()});let r=p;if(Bt(r)){const d=10*t.getTolerance(0);r=new Jt().execute(r,0,d,0,i,12e3)}const n=new ie(i);n.m_sr=t,n.m_gcs=t.getGCS(),n.m_transform=Ut(t,n.m_gcs,null);const u=Qt();n.m_gcs.querySpheroidData(u);const a=new M;r.queryEnvelope(a),n.m_a=u.majorSemiAxis,n.m_eSquared=u.e2,n.m_rpu=n.m_gcs.getUnit().getUnitToBaseFactor(),n.m_gcs90=.5*Math.PI/n.m_rpu,n.m_gcs180=Math.PI/n.m_rpu,n.m_gcs360=2*Math.PI/n.m_rpu,n.m_gcs60=n.m_gcs360/6,n.m_q90=ct.q90(n.m_a,n.m_eSquared),n.m_ellipticToGeodesicMaxRatio=.5*n.m_a*Math.PI/n.m_q90;const _=n.m_gcs.getTolerance(0);n.m_radTolerance=_*n.m_rpu,s===4?(n.m_curveType=2,n.m_bShapePreserving=!0):(n.m_curveType=s,n.m_bShapePreserving=!1),n.m_distance=e,n.m_absDistance=Math.abs(e),Number.isNaN(o)||o<=0?n.setConvergenceOffset():n.m_convergenceOffset=Math.max(o,.001),n.m_convergenceOffset/=m;let h,c=r.getGeometryType();if(Yt(c)){const d=new gt({vd:r.getDescription()});d.addSegment(r,!0),h=d,c=T.enumPolyline}else if(c===T.enumEnvelope){const d=r,g=new M;d.queryEnvelope(g);const C=U(nt(n.m_sr,a,!0));if(g.minDimension()<=C)if(g.maxDimension()===0){const P=new Dt({vd:r.getDescription()});d.getCenter(P),h=P,c=T.enumPoint}else{const P=new gt({vd:r.getDescription()});P.addEnvelope(d,!1),h=P,c=T.enumPolyline}else{const P=new N({vd:r.getDescription()});P.addEnvelope(d,!1),h=P,c=T.enumPolygon}}else h=r;if(n.setMinCornerStep(),Xt(c)||n.setMinSegmentStep(),n.m_absDistance<=.5*n.m_convergenceOffset)return c!==T.enumPolygon?new N({vd:h.getDescription()}):n.m_bShapePreserving?h:pt(h,n.m_sr,n.m_curveType,n.m_segmentStep,-1,i);if(n.m_distance<0&&c!==T.enumPolygon)return new N({vd:h.getDescription()});if(n.m_bShapePreserving&&V(c)){const d=pt(h,t,4,Number.NaN,n.m_convergenceOffset,i);h=new $().execute(d,n.m_transform,i)}else h=new $().execute(h,n.m_transform,i);if(h=Vt(h,n.m_gcs),h.isEmpty())return new N({vd:h.getDescription()});!n.m_bShapePreserving&&V(c)&&(h=$t(n.m_rpu,h)),h=re(h,n.m_gcs);let l=new N;switch(c){case T.enumPolygon:l=n.bufferPolygon(h);break;case T.enumPolyline:l=n.bufferPolyline(h);break;case T.enumMultiPoint:l=n.bufferMultiPoint(h);break;case T.enumPoint:l=n.bufferPoint(h);break;default:Ot("")}const f=new $().execute(l,n.m_transform.getInverse(),i);return f.mergeVertexDescription(h.getDescription()),f}function lt(p,t,s,e,o,m,i,r,n,u,a){const _={stack:[],error:void 0,hasError:!1};try{const h=new w;h.setNAN(),n||a.getPointCount()>0&&(h.setCoordsPoint2D(a.getXY(a.getPointCount()-1)),h.scale(s));const c=v(_,new x,!1),l=v(_,new k(new x,new x),!1),f=new w,d=new w,g=m.at(-1),C=1/s;for(let P=0;P<m.length;P++){const D=m[P];let b;P===0?b=i:P===m.length-1?b=r:(S.geodeticDistance(p,t,g.x,g.y,D.x,D.y,null,null,c,o),b=c.val-.5*Math.PI),S.geodesicCoordinate(p,t,D.x,D.y,e,b,l.at(0),l.at(1)),n?d.setCoords(l.at(0).val,l.at(1).val):(f.setCoords(l.at(0).val,l.at(1).val),u=It(D.x,f.x,h.x,u),d.setCoords(u+f.x,f.y),h.setCoordsPoint2D(d)),d.scale(C),a.insertPoint2D(0,-1,d)}return u}catch(h){_.error=h,_.hasError=!0}finally{E(_)}}function j(p,t,s,e,o,m,i,r,n,u,a,_=Number.NaN,h=Number.NaN){const c={stack:[],error:void 0,hasError:!1};try{if(i-m<r)return u;const l=v(c,new k(new x,new x),!1),f=new w,d=new w,g=new w;d.setNAN(),n||a.getPointCount()>0&&(d.setCoordsPoint2D(a.getXY(a.getPointCount()-1)),d.scale(s));let C=Math.ceil(m/r),P=C++*r;P===m&&(P=C++*r);let D=m;const b=1/s;for(;P<i+r&&(D<_&&_<P?(P=_,C--):D<h&&h<P&&(P=h,C--),!(P>=i));)S.geodesicCoordinate(p,t,o.x,o.y,e,P,l.at(0),l.at(1)),n?g.setCoords(l.at(0).val,l.at(1).val):(f.setCoords(l.at(0).val,l.at(1).val),u=It(o.x,f.x,d.x,u),g.setCoords(u+f.x,f.y),d.setCoordsPoint2D(g)),g.scale(b),a.insertPoint2D(0,-1,g),D=P,P=C++*r;return u}catch(l){c.error=l,c.hasError=!0}finally{E(c)}}function yt(p,t,s,e,o,m,i,r,n,u,a){const _={stack:[],error:void 0,hasError:!1};try{const h=new w,c=new w,l=v(_,new k(new x,new x),!1);S.geodesicCoordinate(p,t,o.x,o.y,e,m,l.at(0),l.at(1)),h.setCoords(l.at(0).val,l.at(1).val),S.geodesicCoordinate(p,t,o.x,o.y,e,i,l.at(0),l.at(1)),c.setCoords(l.at(0).val,l.at(1).val);const f=v(_,new x,!1);for(S.geodeticDistance(p,t,r.x,r.y,h.x,h.y,null,f,null,0),u[0]=f.val,S.geodeticDistance(p,t,r.x,r.y,c.x,c.y,null,f,null,0),a[0]=f.val;u[0]<=a[0];)u[0]+=q;for(;u[0]>a[0];)u[0]-=q;for(;u[0]>=n;)u[0]-=q,a[0]-=q;for(;u[0]<n;)u[0]+=q,a[0]+=q}catch(h){_.error=h,_.hasError=!0}finally{E(_)}}function It(p,t,s,e){if(Number.isNaN(s)){for(;e+t-p>Math.PI;)e-=q;for(;p-(e+t)>Math.PI;)e+=q;return e}return e+t-s>Math.PI?e-=q:s-(e+t)>Math.PI&&(e+=q),e}function re(p,t){const s=p.getGeometryType();let e;if(e=V(s)?p.getPathCount():s===T.enumMultiPoint?p.getPointCount():1,e===1)return p;const o=[],m=[];for(let r=0;r<e;r++){o.push(r);const n=new w;if(V(s)){const a=new M;p.queryPathEnvelope(r,a),n.assign(a.getCenter())}else n.assign(p.getXY(r));const u=t.toGeohash(n);m.push(u)}o.sort((r,n)=>m[r]<m[n]?-1:m[r]>m[n]?1:0);const i=p.createInstance();for(let r=0;r<e;r++){const n=o[r];V(s)?i.addPath(p,n,!0):i.addPoints(p,n,n+1)}return i}function Gt(p,t,s,e,o,m){const i={stack:[],error:void 0,hasError:!1};try{if(e>=m)return!1;const r=s[0],n=s.at(-1),u=v(i,new x,!1),a=v(i,new x,!1),_=v(i,new x,!1);S.greatEllipticDistance(p,t,o.x,o.y,r.x,r.y,u,null,null),S.greatEllipticDistance(p,t,o.x,o.y,n.x,n.y,a,null,null),S.greatEllipticDistance(p,t,r.x,r.y,n.x,n.y,_,null,null);let h=Math.min(u.val,a.val)+_.val,c=h+e;if(c<m)return!0;const l=v(i,new x,!1);h=Math.max(u.val,a.val);for(let f=1;f<s.length-1;f++){const d=s[f];S.greatEllipticDistance(p,t,o.x,o.y,d.x,d.y,l,null,null),l.val>h&&(h=l.val)}return c=h+e,c<m}catch(r){i.error=r,i.hasError=!0}finally{E(i)}}function wt(p,t,s,e,o,m,i,r){let n;if(e.length%2==0){const _=e.length>>1,h=e[_],c=e[_-1];n=w.lerp(h,c,.5)}else n=e[e.length-1>>1].clone();const u=n.clone(),a=it(p,t,u,75/180*Math.PI);return!!Gt(p,t,e,o,u,a)&&(m!==null&&(m.setCoordsPoint2D(n),m.scale(1/s)),i!==null&&i.setCoordsPoint2D(u),r!==null&&(r[0]=a),!0)}function Mt(p,t,s,e,o,m){const i={stack:[],error:void 0,hasError:!1};try{if(e>=m)return!1;const r=v(i,new x,!1);return S.greatEllipticDistance(p,t,o.x,o.y,s.x,s.y,r,null,null),r.val+e<m}catch(r){i.error=r,i.hasError=!0}finally{E(i)}}function me(p,t,s,e,o,m,i,r){const n=it(p,t,e,.4166666666666667*Math.PI);return!!Mt(p,t,e,o,e,n)&&(m!==null&&(m.setCoordsPoint2D(e),m.scale(1/s)),i!==null&&i.setCoordsPoint2D(e),r!==null&&(r[0]=n),!0)}function H(p,t){return new Kt(p,t)}function st(p){return Zt(p,0)||te(p,0),p}class Nt{constructor(t){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new w,this.m_minGnomonicRadius=Number.NaN,this.m_progressTracker=t}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}}class Ct extends Nt{constructor(t,s,e){super(t.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new N,this.m_densifiedPoints=[],this.m_bufferer=t,this.m_multiPath=s,this.m_densified=e,this.m_bNeedsSimplify=!0;const o=new M;this.m_multiPath.queryEnvelope(o);const m=o.getCenter(),i=m.clone();i.scale(this.m_bufferer.m_rpu),this.m_gnomonic=H(this.m_bufferer.m_gcs,m),this.m_gnomonicCenterRad=i.clone(),this.m_minGnomonicRadius=it(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,i,75/180*Math.PI)}next(){let t;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),t=this.m_bufferHelper.clone(),t;if(this.m_segIter===null){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;this.m_densified!==null&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;this.m_densified!=null&&this.m_densified.addPathPoint2D(null,0,!0)}let s=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=Number.NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;const e=16;let o=0;const m=new w,i=new w;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<e;){const r=this.m_segIter.nextSegment();if(m.setCoordsPoint2D(r.getStartXY()),i.setCoordsPoint2D(r.getEndXY()),m.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),tt(m,i))m.x=i.x;else if(et(m,i))i.x=m.x;else{let u=-1,a=-1;const _=this.m_segIter.getPathIndex(),h=this.m_multiPath.getPathStart(_),c=this.m_multiPath.getPathEnd(_);if(u=this.m_segIter.getStartPointIndex()-1,a=this.m_segIter.getEndPointIndex()+1,u<h&&(u=this.m_multiPath.isClosedPath(_)?c-1:-1),a>c-1&&(a=this.m_multiPath.isClosedPath(_)?h:-1),u!==-1){const l=this.m_multiPath.getXY(u);l.scale(this.m_bufferer.m_rpu),et(l,m)&&(m.x=l.x)}if(a!==-1){const l=this.m_multiPath.getXY(a);l.scale(this.m_bufferer.m_rpu),tt(i,l)&&(i.x=l.x)}}this.m_densifiedPoints.length=0;const n=bt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,m,i,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(o===0)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if(wt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(n===0||ee(m,i)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(m,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(n,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),s===null&&(s=new N,s.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(s),o++}if(this.m_currentDensifiedDelta=[0],o>0){const r=this.m_segIter.getStartPointIndex(),n=this.m_segIter.getPathIndex();for(;o>0;){if(this.m_segIter.previousSegment(),m.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),i.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),m.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if(tt(m,i))m.x=i.x;else if(et(m,i))i.x=m.x;else{let u=-1,a=-1;const _=this.m_segIter.getPathIndex(),h=this.m_multiPath.getPathStart(_),c=this.m_multiPath.getPathEnd(_);if(u=this.m_segIter.getStartPointIndex()-1,a=this.m_segIter.getEndPointIndex()+1,u<h&&(u=this.m_multiPath.isClosedPath(_)?c-1:-1),a>c-1&&(a=this.m_multiPath.isClosedPath(_)?h:-1),u!==-1){const l=this.m_multiPath.getXY(u);l.scale(this.m_bufferer.m_rpu),et(l,m)&&(m.x=l.x)}if(a!==-1){const l=this.m_multiPath.getXY(a);l.scale(this.m_bufferer.m_rpu),tt(i,l)&&(i.x=l.x)}}this.m_densifiedPoints.length=0,bt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,i,m,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(s),o--}return m.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),m.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=j(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,m,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,s),this.m_segIter.resetToVertex(r,n),this.m_segIter.nextSegment(),s}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),t=this.m_bufferHelper.clone(),t}isSegmentBufferInCurrentGnomonic(t){return this.m_gnomonic!==null&&Gt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(t){const s=new w,e=new w,o=[0];return wt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,s,e,o)?(this.m_gnomonicCenterRad.setCoordsPoint2D(e),this.m_minGnomonicRadius=o[0],this.m_gnomonic=H(this.m_bufferer.m_gcs,s),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(t,s){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,t,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,s)}addJoinAndBufferLeftSide(t){const s=this.m_densifiedPoints[0];let e=Number.NaN,o=this.m_startAzimuth[0]-O;const m=this.m_endAzimuth[0]+O;let i=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(e=this.m_lastAzimuth+O,o=e+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(e=this.m_lastAzimuth+O,o=e+Math.PI-(q-(this.m_startAzimuth[0]-this.m_lastAzimuth))),i=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI)&&!(this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let r=!1;if(Math.abs(o-e)<=.5*this.m_bufferer.m_cornerStep&&(i||(r=!0)),r){if(t.removePointFromPath(0,t.getPointCount()-1),!this.m_bRunningInGnomonic){const n=new w;n.setCoordsPoint2D(t.getXY(t.getPointCount()-1)),n.scale(this.m_bufferer.m_rpu),n.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=q:n.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=q)}o=.5*(o+e)}else if(i){const n=new w;n.setCoordsPoint2D(s),n.scale(1/this.m_bufferer.m_rpu),t.insertPoint2D(0,-1,n)}else j(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],e,o,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,lt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,o,m,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_lastAzimuth=this.m_endAzimuth[0]}}class oe extends Nt{constructor(t,s){super(t.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=t,this.m_multiPoint=s,this.m_bNeedsSimplify=!1;const e=new M;this.m_multiPoint.queryEnvelope(e);const o=e.getCenter(),m=o.clone();m.scale(this.m_bufferer.m_rpu),this.m_gnomonic=H(this.m_bufferer.m_gcs,o),this.m_gnomonicCenterRad=m.clone(),this.m_minGnomonicRadius=it(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,m,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;const t=this.m_multiPoint.getXY(this.m_pointIndex);t.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(t),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(t));const s=new N,e=this.m_bufferer.bufferPoint2D(t,this.m_bRunningInGnomonic,s);return this.m_bNeedsSimplify=e,s}isPointBufferInCurrentGnomonic(t){return this.m_gnomonic!==null&&Mt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(t){const s=new w,e=new w,o=[0];return me(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,s,e,o)?(this.m_gnomonicCenterRad.setCoordsPoint2D(e),this.m_minGnomonicRadius=o[0],this.m_gnomonic=H(this.m_bufferer.m_gcs,s),!0):(this.m_gnomonic=null,!1)}}class ge{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(t,s,e){return!1}canAccelerateGeometry(t){return!1}executeMany(t,s,e,o,m,i,r,n){if(r){const u=new vt(t,s,e,o,m,!1,i,n);return new J().executeMany(u,s,n)}return new vt(t,s,e,o,m,!1,i,n)}execute(t,s,e,o,m,i,r){const n=new qt([t]),u=[o],a=this.executeMany(n,s,e,u,m,!1,i,r).next();return a||Et("geodesic buffer null output"),a}}class vt extends At{constructor(t,s,e,o,m,i,r,n){super(),this.m_currentUnionEnvelope2D=new M,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=n,i&&Rt(""),s||ut(""),s.getCoordinateSystemType()===0&&ut(""),this.m_inputGeoms=t,this.m_spatialReference=s,this.m_curveType=e,this.m_distances=o,this.m_convergenceOffset=m,this.m_bOutlineOnly=i,this.m_bUnion=r}next(){let t;for(;t=this.m_inputGeoms.next();)return St(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(t,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(t,s){return ne(t,this.m_spatialReference,this.m_curveType,s,this.m_convergenceOffset,this.m_progressTracker)}}export{ge as OperatorGeodesicBuffer};
