import{gL as T,gD as Y,co as rt,gU as st,gV as x,ds as $,a6 as at}from"./main-DbyY3WHi.js";import{X as R,P as ct}from"./sphere-zPMQWhGG-CvwbLP4I.js";import{z as ut,G as gt,s as bt}from"./mat4-OOmHNWi7-VcAcYx7s.js";import{n as X}from"./mat4f64-xsZDPPj0-Dq35B4BL.js";import{_ as u,L as l,P as p,A as M,g as ft,b as I,W as lt,y as h,r as C,R as A,Y as m,l as B,v as k}from"./vec32-Cj8pVsU0-quFqo9kj.js";import{M as pt,E as K,S as dt}from"./lineSegment-BAWQVP9P-Cp8vHKXB.js";import{y as E,K as mt,w as ht,t as O,d as It,o as Pt,a as $t,s as Mt,e as W,i as Nt,$ as y,Y as yt}from"./plane-Cf3Koz3c-BShtdfq6.js";import{q as s,b as N}from"./vectorStacks-5ZZtmT9E-pJaB9sUY.js";const V=()=>at.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class wt{constructor(){this.plane=E(),this.origin=$(),this.basis1=$(),this.basis2=$()}}const Et=wt;function P(t=et){return{plane:E(t.plane),origin:Y(t.origin),basis1:Y(t.basis1),basis2:Y(t.basis2)}}function _t(t,i,n){const o=Bt.get();return o.origin=t,o.basis1=i,o.basis2=n,o.plane=mt(0,0,0,0),v(o),o}function _(t,i=P()){return Z(t.origin,t.basis1,t.basis2,i)}function vt(t,i){u(i.origin,t.origin),u(i.basis1,t.basis1),u(i.basis2,t.basis2),ht(i.plane,t.plane)}function Z(t,i,n,o=P()){return u(o.origin,t),u(o.basis1,i),u(o.basis2,n),v(o),jt(o,"fromValues()"),o}function v(t){O(t.basis2,t.basis1,t.origin,t.plane)}function D(t,i,n){t!==n&&_(t,n);const o=l(s.get(),f(t),i);return p(n.origin,n.origin,o),n.plane[3]-=i,n}function St(t,i,n){return H(i,n),D(n,U(t,t.origin),n),n}function Tt(t,i){const n=t.basis1[0],o=t.basis2[1],[e,r]=t.origin;return rt(e-n,r-o,e+n,r+o,i)}function H(t,i=P()){const n=(t[2]-t[0])/2,o=(t[3]-t[1])/2;return M(i.origin,t[0]+n,t[1]+o,0),M(i.basis1,n,0,0),M(i.basis2,0,o,0),It(0,0,1,0,i.plane),i}function F(t,i,n){return!!Pt(t.plane,i,n)&&it(t,n)}function Yt(t,i,n){if(F(t,i,n))return n;const o=Q(t,i,s.get());return p(n,i.origin,l(s.get(),i.direction,ft(i.origin,o)/I(i.direction))),n}function Q(t,i,n){const o=w.get();ot(t,i,o,w.get());let e=Number.POSITIVE_INFINITY;for(const r of z){const a=j(t,r,S.get()),g=s.get();if($t(o,a,g)){const c=lt(s.get(),i.origin,g),b=Math.abs(st(h(i.direction,c)));b<e&&(e=b,u(n,g))}}return e===Number.POSITIVE_INFINITY?J(t,i,n):n}function xt(t,i){return(i-t)/i}function J(t,i,n){if(F(t,i,n))return n;const o=w.get(),e=w.get();ot(t,i,o,e);let r=Number.POSITIVE_INFINITY;for(const a of z){const g=j(t,a,S.get()),c=s.get();if(Mt(o,g,c)){const b=ct(i,c);if(!W(e,c))continue;b<r&&(r=b,u(n,c))}}return G(t,i.origin)<r&&tt(t,i.origin,n),n}function tt(t,i,n){const o=Nt(t.plane,i,s.get()),e=K(L(t,t.basis1),o,-1,1,s.get()),r=K(L(t,t.basis2),o,-1,1,s.get());return C(n,p(s.get(),e,r),t.origin),n}function nt(t,i,n){const{origin:o,basis1:e,basis2:r}=t,a=C(s.get(),i,o),g=N(e,a),c=N(r,a),b=N(f(t),a);return M(n,g,c,b)}function G(t,i){const n=nt(t,i,s.get()),{basis1:o,basis2:e}=t,r=I(o),a=I(e),g=Math.max(Math.abs(n[0])-r,0),c=Math.max(Math.abs(n[1])-a,0),b=n[2];return g*g+c*c+b*b}function At(t,i){return Math.sqrt(G(t,i))}function Vt(t,i){let n=Number.NEGATIVE_INFINITY;for(const o of z){const e=j(t,o,S.get()),r=dt(e,i);r>n&&(n=r)}return Math.sqrt(n)}function qt(t,i){return W(t.plane,i)&&it(t,i)}function Ot(t,i,n,o){return Ut(t,n,o)}function U(t,i){const n=-t.plane[3];return N(f(t),i)-n}function Rt(t,i,n,o){const e=U(t,i),r=l(zt,f(t),n-e);return p(o,i,r),o}function Ct(t,i){return A(t.basis1,i.basis1)&&A(t.basis2,i.basis2)&&A(t.origin,i.origin)}function Ft(t,i,n){return t!==n&&_(t,n),ut(d,i),gt(d,d),m(n.basis1,t.basis1,d),m(n.basis2,t.basis2,d),m(y(n.plane),y(t.plane),d),m(n.origin,t.origin,i),yt(n.plane,n.plane,n.origin),n}function Gt(t,i,n,o){return t!==o&&_(t,o),bt(q,i,n),m(o.basis1,t.basis1,q),m(o.basis2,t.basis2,q),v(o),o}function f(t){return y(t.plane)}function Ut(t,i,n){switch(i){case x.X:u(n,t.basis1),B(n,n);break;case x.Y:u(n,t.basis2),B(n,n);break;case x.Z:u(n,f(t))}return n}function it(t,i){const n=C(s.get(),i,t.origin),o=k(t.basis1),e=k(t.basis2),r=h(t.basis1,n),a=h(t.basis2,n);return-r-o<0&&r-o<0&&-a-e<0&&a-e<0}function L(t,i){const n=S.get();return u(n.origin,t.origin),u(n.vector,i),n}function j(t,i,n){const{basis1:o,basis2:e,origin:r}=t,a=l(s.get(),o,i.origin[0]),g=l(s.get(),e,i.origin[1]);p(n.origin,a,g),p(n.origin,n.origin,r);const c=l(s.get(),o,i.direction[0]),b=l(s.get(),e,i.direction[1]);return l(n.vector,p(c,c,b),2),n}function jt(t,i){Math.abs(h(t.basis1,t.basis2)/(I(t.basis1)*I(t.basis2)))>1e-6&&V().warn(i,"Provided basis vectors are not perpendicular"),Math.abs(h(t.basis1,f(t)))>1e-6&&V().warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-h(f(t),t.origin)-t.plane[3])>1e-6&&V().warn(i,"Plane offset is not consistent with plane origin")}function ot(t,i,n,o){const e=f(t);O(e,i.direction,i.origin,n),O(y(n),e,i.origin,o)}const et={plane:E(),origin:T(0,0,0),basis1:T(1,0,0),basis2:T(0,1,0)},w=new R(E),S=new R(pt),zt=$(),Bt=new R(()=>P()),z=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=X(),q=X(),Qt=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:Et,altitudeAt:U,axisAt:Ot,cameraFrustumCoverage:xt,closestPoint:J,closestPointOnSilhouette:Q,copy:_,copyWithoutVerify:vt,create:P,distance:At,distance2:G,distanceToSilhouette:Vt,elevate:D,equals:Ct,extrusionContainsPoint:qt,fromAABoundingRect:H,fromValues:Z,getExtent:Tt,intersectRay:F,intersectRayClosestSilhouette:Yt,normal:f,projectPoint:tt,projectPointLocal:nt,rotate:Gt,setAltitudeAt:Rt,setExtent:St,transform:Ft,up:et,updateUnboundedPlane:v,wrap:_t},Symbol.toStringTag,{value:"Module"}));export{Z as C,_ as M,v as N,Qt as U,P as h,H as k,At as n};
