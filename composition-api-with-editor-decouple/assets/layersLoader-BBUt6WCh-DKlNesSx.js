import{h as y,iv as h,bq as F,bC as H,en as M,it as $}from"./main-DbyY3WHi.js";import{o as g,b as P}from"./fetchService-IPSkq0MP-DAcCHs73.js";import{u as f,p as G,w as k,d as I,l as m,g as x,h as C,L as D,f as b}from"./loadUtils-B4p6zboh-BMegIfUY.js";import{s as v}from"./jsonContext-C9WBVzLb-CmZLRhDw.js";import{o as R}from"./portalItemUtils-BfWDJg-S-1362THwx.js";import{g as V}from"./styleUtils-BnJpZ0Gl-Cxiecsju.js";import"./associatedFeatureServiceUtils-5tlRvHRs-XCxsST_W.js";import"./PortalItem-BP-IQXnZ-D45rIHMm.js";import"./projectionUtils-B-CplN3q-CxkpUOEL.js";import"./asyncUtils-BPUlNCrX-DwSwPJ-n.js";async function se(t,n){const r=t.instance.portalItem;if(r?.id)return await r.load(n),j(t),t.validateItem&&t.validateItem(r),A(t,n)}function j(t){const n=t.instance.portalItem;if(!n?.type||!t.supportedTypes.includes(n.type))throw new y("portal:invalid-layer-item-type","Invalid layer item type '${type}', expected '${expectedType}'",{type:n?.type,expectedType:t.supportedTypes.join(", ")})}async function A(t,n){const r=t.instance,e=r.portalItem;if(!e)return;let{url:o}=e;const{title:a}=e,i=v(e,"portal-item");if(r.type==="group")return E(r,i,t);o&&r.type!=="media"&&r.read({url:o},i);const l=new b,{data:u,preferredHost:s}=await L(t,l,n);return o=e.url,"isUrlHostModified"in r&&(s?r.applyPreferredHost({preferredHost:s}):r.applyHostFromPortalItem()),u&&r.read(u,i),r.resourceReferences={portalItem:e,paths:i.readResourcePaths??[]},r.type!=="subtype-group"&&r.read({title:a},i),V(r,i)}async function E(t,n,r){const e=t.portalItem;if(!t.sourceIsPortalItem)return;const{title:o,type:a}=e;if(a==="Group Layer"){if(!R(e,"Map"))throw new y("portal:invalid-layer-item-typekeyword","'Group Layer' item without 'Map' type keyword is not supported");return J(t,r)}return t.read({title:o},n),N(t,r)}async function J(t,n){const r=t.portalItem,e=await r.fetchData("json");if(!e)return;if(!n.populateGroupLayer)throw new y("portal:missing-populate-group-layer","Missing populate group layer");const o=v(r,"web-map");t.read(e,o),await n.populateGroupLayer(t,e,{context:o}),t.resourceReferences={portalItem:r,paths:o.readResourcePaths??[]}}async function N(t,n){let r;const{portalItem:e}=t;if(!e)return;const o=e.type,a=n.layerModuleTypeMap;if(!a)throw new y("portal:missing-layer-module-type-map","Layer module type map is required to construct sub layers");switch(o){case"Feature Service":case"Feature Collection":r=a.FeatureLayer;break;case"Stream Service":r=a.StreamLayer;break;case"Scene Service":r=a.SceneLayer;break;case"Video Service":r=a.VideoLayer;break;default:throw new y("portal:unsupported-item-type-as-group",`The item type '${o}' is not supported as a 'IGroupLayer'`)}const i=o==="Video Service",l=new b;let[u,{data:s}]=await Promise.all([r(),i?{data:null}:L(n,l)]),p=()=>u;if(i)return q(t,p,a);if(o==="Feature Service"){const c=f(s)?.customParameters;s=e.url?(await G(s,e.url,l)).data:{},p=await W(s,a)||p;const{provider:S,preferredHost:T}=await Q(e.url,{customParameters:c,loadContext:l});return h(e,T),await d(t,p,p,s,a,S)}return o==="Scene Service"&&e.url&&(s=await k(e,s,l)),I(s)>0?await d(t,p,null,s,a):await O(t,p,a)}async function O(t,n,r){const{portalItem:e}=t;if(!e?.url)return;const o=await g(e.url);o&&d(t,n,null,{layers:o.layers?.map(m),tables:o.tables?.map(m)},r)}async function q(t,n,r){const{portalItem:e}=t;if(!e?.url)return;const o=await g(e.url);o&&d(t,n,null,{layers:o.layers?.map(({id:a,name:i})=>({id:a,name:i}))},r)}async function d(t,n,r,e,o,a){let i=e.layers||[];const l=e.tables||[];if(t.portalItem?.type==="Feature Collection"?(i.forEach((u,s)=>{u.id=s,u?.layerDefinition?.type==="Table"&&l.push(u)}),i=i.filter(u=>u?.layerDefinition?.type!=="Table")):(i.reverse(),l.reverse()),i.forEach(u=>{const s=a?.(u);if(s||!a){const p=w(t,n(u),e,u,s);t.add(p)}}),l.length){const u=r?null:await o.FeatureLayer();l.forEach(s=>{const p=a?.(s);if(p||!a){const c=w(t,r?r(s):u,e,s,p);t.tables.add(c)}})}}function w(t,n,r,e,o){const a=t.portalItem,i={portalItem:a.clone(),layerId:e.id};e.url!=null&&(i.url=e.url);const l=new n(i);if("sourceJSON"in l&&(l.sourceJSON=o),l.type!=="subtype-group"&&l.type!=="catalog"&&(l.sublayerTitleMode="service-name"),a.type==="Feature Collection"){const u={origin:"portal-item",portal:a.portal||F.getDefault()};l.read(e,u);const s=r.showLegend;s!=null&&l.read({showLegend:s},u)}return l}async function L(t,n,r){if(t.supportsData===!1)return{data:void 0};const e=t.instance,o=e.portalItem;if(!o)return{data:void 0};let a=null;try{a=await o.fetchData("json",r)}catch{}if(z(e)){let i=null;const{count:l,preferredHost:u}=await B(o,a,n);if(h(o,u),(a?.layers||a?.tables)&&l>0){if(e.layerId==null){const s=x(e.type),p=s?.length?C(a,s)[0]:f(a);p&&(e.layerId=p.id)}i=U(a,e),i?.layerType==="OrientedImageryLayer"&&e.type==="oriented-imagery"&&e.supportedSourceTypes.add("Feature Layer"),i&&a.showLegend!=null&&(i.showLegend=a.showLegend)}return l>1&&"sublayerTitleMode"in e&&e.sublayerTitleMode!=="service-name"&&(e.sublayerTitleMode="item-title-and-service-name"),{data:i,preferredHost:u}}return{data:a}}async function B(t,n,r){if(n?.layers&&n?.tables)return{count:I(n)};const e=H(t.url);if(!e)return{count:1};const o=e.url.path,a=await r.fetchServiceMetadata(o,{customParameters:f(n)?.customParameters}).catch(()=>null);return{count:(n?.layers?.length??a?.layers?.length??0)+(n?.tables?.length??a?.tables?.length??0),preferredHost:M(t)?$():null}}function U(t,n){const{layerId:r}=n,e=t.layers?.find(o=>o.id===r)||t.tables?.find(o=>o.id===r);return e&&K(e,n)?e:null}function z(t){return t.type!=="stream"&&"layerId"in t}function K(t,n){const r="layerType"in t&&t.layerType,{type:e}=n;return!(e==="feature"&&r&&t.layerType!=="ArcGISFeatureLayer"||e==="catalog"&&!r||e==="oriented-imagery"&&!r||e==="subtype-group"&&!r)}async function Q(t,n){const{layersJSON:r,preferredHost:e}=await P(t,n);if(!r)return{provider:null,preferredHost:e};const o=[...r.layers,...r.tables];return{provider:a=>o.find(i=>i.id===a.id),preferredHost:e}}async function W(t,n){const{layers:r,tables:e}=t,o=[...r??[],...e??[]];if(!o.length)return;const a=new Set,i=[];for(const{layerType:s}of o){const p=s??"ArcGISFeatureLayer";if(a.has(p))continue;a.add(p);const c=n[D(p)];i.push(c())}const l=await Promise.all(i),u=new Map;return Array.from(a).forEach((s,p)=>{u.set(s,l[p])}),({layerType:s})=>{const p=s??"ArcGISFeatureLayer";return u.get(p)}}export{se as load};
