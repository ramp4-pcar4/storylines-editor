import{b9 as N,v as m,S as l,n as q,ac as H,bv as z,u as w,at as T,t as $,cN as k,e5 as W}from"./main-D6SnduPa.js";import{a as A}from"./TileInfo-U28GysF5-DYLfV_55.js";import{h as B}from"./BitmapTechnique-CHUhq2KJ-Cjl3JWwW.js";import{k as C}from"./enums-CQnCd4Rx-CQBztbs2.js";import{s as I}from"./TileKey-_zikB14n-Bl9i8NgX.js";const U=Math.PI/180;function V(p){return p*U}function D(p,a){const e=V(a.rotation),r=Math.abs(Math.cos(e)),t=Math.abs(Math.sin(e)),[s,o]=a.size;return p[0]=Math.round(o*t+s*r),p[1]=Math.round(o*r+s*t),p}function O(p,a,e,r){const[t,s]=a,[o,d]=r,i=.5*e;return p[0]=t-i*o,p[1]=s-i*d,p[2]=t+i*o,p[3]=s+i*d,p}const u=N(),c=[0,0],_=new I(0,0,0,0),M={imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let h=class extends H{constructor(a){super(a),this._imagePromise=null,this.bitmaps=[],this.hidpi=M.hidpi,this.imageMaxWidth=M.imageMaxWidth,this.imageMaxHeight=M.imageMaxHeight,this.imageRotationSupported=M.imageRotationSupported,this.imageNormalizationSupported=M.imageNormalizationSupported,this.update=z(async(e,r)=>{if(w(r),!e.stationary||this.destroyed)return;const t=e.state,s=T(t.spatialReference),o=this.hidpi?e.pixelRatio:1,d=t.worldScreenWidth>0,i=d&&this.imageNormalizationSupported&&t.worldScreenWidth<t.size[0],f=Math.round((this.imageMaxWidth??0)/o),x=Math.round((this.imageMaxHeight??0)/o);i?(c[0]=t.worldScreenWidth,c[1]=t.size[1]):this.imageRotationSupported?(c[0]=t.size[0],c[1]=t.size[1]):D(c,t);const S=Math.floor(c[0])>f||Math.floor(c[1])>x,v=s&&(t.extent.xmin<s.valid[0]||t.extent.xmax>s.valid[1]),R=!this.imageNormalizationSupported&&v,y=!S&&!R,b=this.imageRotationSupported?t.rotation:0,E=this.container.children.slice();if(y){const n=i?t.paddedViewState.center:t.center;this._imagePromise=this._singleExport(t,c,n,t.resolution,b,o,r)}else{let n=Math.min(f,x);d&&(n=Math.min(t.worldScreenWidth,n),n=Math.round(t.worldScreenWidth/Math.ceil(t.worldScreenWidth/n))),this._imagePromise=this._tiledExport(t,n,o,r)}try{const n=await this._imagePromise??[];w(r);const P=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=n;for(const g of E)n.includes(g)||P.push(g.fadeOut().then(()=>{g.remove(),g.destroy()}));for(const g of n)P.push(g.fadeIn());await Promise.all(P)}catch(n){this._imagePromise=null,$(n)}},5e3),this.updateExports=z(async e=>{const r=[];for(const t of this.container.children){if(!t.visible||!t.stage)return;r.push(e(t).then(()=>{t.invalidateTexture(),t.requestRender()}))}this._imagePromise=k(r).then(()=>this._imagePromise=null),await this._imagePromise})}destroy(){this.bitmaps.forEach(a=>a.destroy()),this.bitmaps=[]}get updating(){return!this.destroyed&&this._imagePromise!==null}async _export(a,e,r,t,s,o){const d=await this.fetchSource(a,Math.floor(e*s),Math.floor(r*s),{rotation:t,pixelRatio:s,signal:o});w(o);const i=new B(null,!0);return i.x=a.xmin,i.y=a.ymax,i.resolution=a.width/e,i.rotation=t,i.pixelRatio=s,i.opacity=0,this.container.addChild(i),await i.setSourceAsync(d,o),w(o),i}async _singleExport(a,e,r,t,s,o,d){O(u,r,t,e);const i=W(u,a.spatialReference);return[await this._export(i,e[0],e[1],s,o,d)]}_tiledExport(a,e,r,t){const s=A.create({size:e,spatialReference:a.spatialReference,scales:[a.scale]}),o=new C(s),d=o.getTileCoverage(a);if(!d)return null;const i=[];return d.forEach((f,x,S,v)=>{_.set(f,x,S,0),o.getTileBounds(u,_);const R=W(u,a.spatialReference);i.push(this._export(R,e,e,0,r,t).then(y=>(v!==0&&(_.set(f,x,S,v),o.getTileBounds(u,_),y.x=u[0],y.y=u[3]),y)))}),Promise.all(i)}};m([l()],h.prototype,"_imagePromise",void 0),m([l()],h.prototype,"bitmaps",void 0),m([l()],h.prototype,"container",void 0),m([l()],h.prototype,"fetchSource",void 0),m([l()],h.prototype,"hidpi",void 0),m([l()],h.prototype,"imageMaxWidth",void 0),m([l()],h.prototype,"imageMaxHeight",void 0),m([l()],h.prototype,"imageRotationSupported",void 0),m([l()],h.prototype,"imageNormalizationSupported",void 0),m([l()],h.prototype,"requestUpdate",void 0),m([l()],h.prototype,"updating",null),h=m([q("esri.views.2d.layers.support.ExportStrategy")],h);export{h};
