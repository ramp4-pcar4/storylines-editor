import{ac as X,a0 as Y,v as L,S as P,du as C,n as K,az as Q}from"./main-BwrA98zM.js";import{u as W,c as G}from"./Cyclical-DgD7_U1C-CUQYX7EX.js";import{o as H,t as A}from"./quantityUtils-B1Ov7DZK-Ct5fMyM2.js";import{b as u}from"./elevationInfoUtils-Ccn2Wfoe-CUPonxzP.js";import{D as Z,z as $,B as m,I as M,M as f,R as F,S as b,T as y,X as ee,_ as R,Y as z,a0 as te,c as ie,a1 as q,n as c,J as _,a2 as I,a3 as se,a4 as T,a5 as re,C as ne,a6 as oe,a7 as ae,a8 as he}from"./SketchViewModel-B0qFHK0t-Dd24rjqA.js";import{M as J,i as B,P as de,l as pe,y as ce,A as le,f as j}from"./vec2-BnynUbeJ-CKtGJQAy.js";import{o as O}from"./vec2f64-CkowXrDb-3zFQ3LNH.js";import{N as ge,r as fe,A as ue}from"./vec32-Cj8pVsU0-B1j-O7Zo.js";import"./ElevationInfo-DE5to86a-BP3iYVui.js";import"./lengthUtils-C61nRlXw-Dob_XEh_.js";import"./UpdatingHandles-Bd2FQ26N-CbV3hzQf.js";import"./projectionUtils-B-CplN3q-DxIO03Jo.js";import"./GraphicsLayer-BiEC2-gS-CZpeSxuq.js";import"./GraphicsCollection-uWAVmks7-Bl0VRym2.js";import"./Layer-DvVVmz9x-SxsuM8AS.js";import"./TimeExtent-Cf2Pienb-CwVjhCH7.js";import"./BlendLayer-DjW_5k0v-BGgBD2VW.js";import"./layerContainerType-ChWdCT09-G5sdAsSy.js";import"./jsonUtils-BwLwuQj7-Dz3pr5Nc.js";import"./parser-CWccHtwJ-B0j4YZRx.js";import"./mat4f32-BdRMyjXW-CWt6U0BP.js";import"./mat4-OOmHNWi7-CjSS9WE9.js";import"./common-CYWrYyJl-E8-sukrT.js";import"./ScaleRangeLayer-x42fwED3-j9XWTMoE.js";import"./editableLayers-DFUBlMJy-Ch1GV9oQ.js";import"./utils-Dd8gTonD-QkV3yg0-.js";import"./Queue-DV3gpSdl-CbVdS62U.js";import"./Version-CnwD6MZa-CKHDqXFg.js";import"./projectVectorToVector-DcyiGOWJ-R8cg3Z2R.js";import"./projectPointToVector-BZJhoF_5-CnEaWRCH.js";import"./geodesicUtils-DKS2UG72-DiH81x-a.js";import"./asyncUtils-BPUlNCrX-D9-2F_OI.js";import"./Query-n1aoaaFC-CxDHBCLC.js";import"./Field-BIQ-quF4-2jecDKOo.js";import"./fieldType-PhcL4ff8-DkDi8HIE.js";import"./vec42-D8CJyqHG-DnfLTeQH.js";import"./vec4f64-DD-nkcCV-CSNWKRqG.js";import"./plane-Cf3Koz3c-nQG-lKBC.js";import"./vectorStacks-5ZZtmT9E-DwcfzudV.js";import"./mat3f64-BnNZDR5l-Bz3OL2oI.js";import"./mat4f64-xsZDPPj0-Dq35B4BL.js";import"./quatf64-C16JxGFv-BKWK1F8U.js";import"./sphere-zPMQWhGG-B-gHxcPh.js";import"./mat3-DOnW3DjW-C3hbW9XY.js";import"./geodeticLengthOperator-DHGBHzf3-B4bRixeF.js";import"./geodeticCurveType-D_etKnbP-CirnHLSB.js";import"./earcut-C6NeZYSh-Da0ULCQ5.js";import"./triangle-BM89wdHY-hQvJuo3g.js";import"./lineSegment-BAWQVP9P-D_srrCK-.js";import"./spatialReferenceEllipsoidUtils-BK0OQJn2-C9OSBBFv.js";class k{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=_.shortLineThreshold*_.shortLineThreshold}snap(e,t){return t.vertexHandle!=null?t.vertexHandle.type!=="vertex"?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(f(e.leftVertex.pos,this.view,t),f(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:i}){return this.squaredShortLineThreshold===0||y(m(t,i,u,this.view),m(e,i,u,this.view))>this.squaredShortLineThreshold}isVertical(e,t,{spatialReference:i}){const s=Q(i);return j(c(e),c(t))*s<_.verticalLineThresholdMeters}squaredProximityThreshold(e){return e==="touch"?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}}class me extends k{constructor(e,t,i){super(e,t),this._geodesicLengthMeasurementUtils=i}snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,n=[];if(s<1)return n;const{spatialReference:o}=t,h=m(e,o,u,this.view),{view:a}=this,d=i.edges[s-1];let p=d;do{if(this.edgeExceedsShortLineThreshold(p,t)){const l=M(p,a,t);this._processCandidateProposal(l.left,l.right,e,h,t,n)}p=p.leftVertex.leftEdge}while(p&&p!==d);return n}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,n=s.component;if(n.edges.length<2)return i;const{view:o}=this,{spatialReference:h}=t,a=m(e,h,u,o),d=s.leftEdge,p=s.rightEdge;d&&p&&this.edgeExceedsShortLineThreshold(d,t)&&this.edgeExceedsShortLineThreshold(p,t)&&this._processCandidateProposal(f(d.leftVertex.pos,o,t),f(p.rightVertex.pos,o,t),e,a,t,i);const l=n.edges[0];let g=l;do{if(g!==s.leftEdge&&g!==s.rightEdge&&this.edgeExceedsShortLineThreshold(g,t)){const v=M(g,o,t);this._processCandidateProposal(v.left,v.right,e,a,t,i)}g=g.rightVertex.rightEdge}while(g&&g!==l);return i}_processCandidateProposal(e,t,i,s,n,o){const{spatialReference:h,pointer:a}=n,d=C();xe(d,e,t,i,n,this._geodesicLengthMeasurementUtils);const p=F(b(d));y(s,m(p,h,u,this.view))<this.squaredProximityThreshold(a)&&o.push(new ee({lineStart:e,lineEnd:t,targetPoint:p,isDraped:n.elevationInfo?.mode==="on-the-ground"}))}}function xe(r,e,t,i,s,n){ve(r,e,t,i,s,n)||Ee(r,i,e,t)}function ve(r,e,t,i,{spatialReference:s},n){const o=R(e,t,s,s);if(o==null)return!1;const h=R(t,i,s,s);if(h==null)return!1;const a=n.geodesicDistance(t,i,s);if(a==null)return!1;const d=Math.abs(W.shortestSignedDiff(o,h))>Math.PI/2?G.normalize(o+Math.PI):o;return z(r,t,s,H(a,"meters"),A(d,"radians","geographic"),"geodesic"),r[2]=i[2],!0}function Ee(r,e,t,i){te(e,{start:t,end:i,type:ie.LINE},r),r[2]=e[2]}let we=class extends k{snapNewVertex(r,e){const t=e.editGeometryOperations.data.components[0],i=t.edges.length,s=t.vertices.length,n=[];if(i<2)return n;const{view:o}=this,h=m(r,e.spatialReference,u,o),a=f(t.vertices[s-1].pos,o,e),d=f(t.vertices[0].pos,o,e),p=t.edges[i-1];let l=p;do{if(this.edgeExceedsShortLineThreshold(l,e)){const g=M(l,o,e);this._checkEdgeForParallelLines(g,a,r,h,e,n),this._checkEdgeForParallelLines(g,d,r,h,e,n)}l=l.leftVertex.leftEdge}while(l&&l!==p);return n}snapExistingVertex(r,e){const t=[],i=e.vertexHandle,s=i.component;if(s.edges.length<3)return t;const{view:n}=this,o=m(r,e.spatialReference,u,n),h=i.leftEdge,a=i.rightEdge,d=s.vertices[0],p=f(d.pos,n,e),l=s.vertices.length,g=s.vertices[l-1],v=f(g.pos,n,e),w=s.edges[0];let x=w;do{if(x!==h&&x!==a&&this.edgeExceedsShortLineThreshold(x,e)){const S=M(x,n,e);h&&this._checkEdgeForParallelLines(S,f(h.leftVertex.pos,n,e),r,o,e,t),a&&this._checkEdgeForParallelLines(S,f(a.rightVertex.pos,n,e),r,o,e,t),i===d?this._checkEdgeForParallelLines(S,v,r,o,e,t):i===g&&this._checkEdgeForParallelLines(S,p,r,o,e,t)}x=x.rightVertex.rightEdge}while(x&&x!==w);return t}_checkEdgeForParallelLines(r,e,t,i,s,n){const o=r.left,h=r.right;if(q(E,c(e),c(o),c(h)),J(E,c(e))<_.parallelLineThreshold)return;q(E,c(t),c(o),c(h),c(e));const{spatialReference:a,pointer:d}=s,p=F(I(E[0],E[1],t[2]));if(y(i,m(p,a,u,this.view))<this.squaredProximityThreshold(d)){if(this.isVertical(p,e,s)||this.isVertical(o,h,s)||Ve(r,n))return;n.push(new se({referenceLine:r,lineStart:e,targetPoint:p,isDraped:s.elevationInfo?.mode==="on-the-ground"}))}}};function Ve(r,e){const t=r.left,i=r.right;for(const s of e)if(q(E,c(i),c(s.constraint.start),c(s.constraint.end),c(t)),J(E,c(i))<_.parallelLineThreshold)return s.addReferenceLine(r),!0;return!1}const E=O();class Le extends k{constructor(e,t,i){super(e,t),this._geodesicLengthMeasurementUtils=i}snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=[];if(i.vertices.length<2)return s;const{view:n}=this,o=m(e,t.spatialReference,u,n),h=i.vertices.at(-1);this._checkForSnappingCandidate(T.LastVertex,s,h.leftEdge,h,h.leftEdge.leftVertex,e,o,t);const a=i.vertices[0];return this._checkForSnappingCandidate(T.FirstVertex,s,a.rightEdge,a,a.rightEdge.rightVertex,e,o,t),s}snapExistingVertex(e,t){const i=[],s=t.vertexHandle;if(s.component.vertices.length<3)return i;const{view:n}=this,o=m(e,t.spatialReference,u,n),h=s.leftEdge,a=s.rightEdge;if(h?.leftVertex.leftEdge){const d=h.leftVertex.leftEdge;this._checkForSnappingCandidate(T.ExistingEdge,i,d,d.rightVertex,d.leftVertex,e,o,t)}if(a?.rightVertex.rightEdge){const d=a.rightVertex.rightEdge;this._checkForSnappingCandidate(T.ExistingEdge,i,d,d.leftVertex,d.rightVertex,e,o,t)}return i}_checkForSnappingCandidate(e,t,i,s,n,o,h,a){if(!this.edgeExceedsShortLineThreshold(i,a))return;const d=this.view,p=f(s.pos,d,a),l=f(n.pos,d,a);_e(N,l,p,o,a,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(e,t,l,p,N,o,h,a)}_checkForSnappingCandidateAlongProjectedRay(e,t,i,s,n,o,h,a){const{spatialReference:d,pointer:p}=a,l=B(D,c(o),c(s)),g=de(n,l)/pe(n),v=ce(D,c(s),n,g),w=F(I(v[0],v[1],o[2]));if(y(h,m(w,d,u,this.view))>this.squaredProximityThreshold(p)||this.isVertical(w,s,a)||this.isVertical(s,i,a))return;const x=ge(C(),s,n,Math.sign(g));t.push(new re({targetPoint:w,constraint:new ne(s,b(x)),previousVertex:i,otherVertex:s,otherVertexType:oe.CENTER,selfSnappingType:e,isDraped:a.elevationInfo?.mode==="on-the-ground"}))}}function _e(r,e,t,i,s,n){ye(r,e,t,i,s,n)||Se(r,e,t)}function ye(r,e,t,i,{spatialReference:s},n){const o=R(e,t,s,s);if(o==null)return!1;const h=R(t,i,s,s);if(h==null)return!1;const a=Math.sign(G.shortestSignedDiff(o,h))*Math.PI*.5,d=A(o+a,"radians","geographic"),p=C(),l=n.geodesicDistance(t,i,s);return l!=null&&(z(p,t,s,H(l,"meters"),d,"geodesic"),fe(r,p,t),!0)}function Se(r,e,t){const i=B(D,c(t),c(e));ue(r,i[1],-i[0],0)}const D=O(),N=C();let Pe=class extends k{snapNewVertex(r,e){const t=e.editGeometryOperations.data.components[0],i=[],s=t.vertices.length;if(e.editGeometryOperations.data.type!=="polygon"||s<2)return i;const{view:n}=this,o=t.vertices[0],h=t.vertices[s-1],a=f(o.pos,n,e),d=f(h.pos,n,e);return this._processCandidateProposal(a,d,r,e,i),i}snapExistingVertex(r,e){const t=[],i=e.vertexHandle,s=i.component;if(s.edges.length<2||e.editGeometryOperations.data.type==="polyline"&&(i.index===0||i.index===s.vertices.length-1))return t;const{view:n}=this,o=f(i.leftEdge.leftVertex.pos,n,e),h=f(i.rightEdge.rightVertex.pos,n,e);return this._processCandidateProposal(o,h,r,e,t),t}_processCandidateProposal(r,e,t,i,s){if(!this.exceedsShortLineThreshold(r,e,i))return;const n=le(U,c(r),c(e),.5),o=.5*j(c(r),c(e)),h=ae(U,c(t),n,o),a=F(I(h[0],h[1],t[2])),{spatialReference:d,pointer:p}=i,l=m(t,d,u,this.view);if(y(l,m(a,d,u,this.view))<this.squaredProximityThreshold(p)){if(this.isVertical(r,a,i)||this.isVertical(a,e,i))return;s.push(new he({targetPoint:a,point1:r,point2:e,isDraped:i.elevationInfo?.mode==="on-the-ground"}))}}};const U=O();let V=class extends X{constructor(r){super(r),this.updating=!1,this._snappers=new Y,this._domain=Z.SELF}initialize(){this._snappers.push(new we(this.view,this.options),new me(this.view,this.options,this.geodesicLengthMeasurementUtils),new Le(this.view,this.options,this.geodesicLengthMeasurementUtils),new Pe(this.view,this.options))}set options(r){this._set("options",r);for(const e of this._snappers)e.options=r}async fetchCandidates(r,e,t){if(!(e&this._domain&&this.options.effectiveSelfEnabled))return[];const i=[];for(const s of this._snappers.items)for(const n of s.snap(r,t))i.push(n);return $(r,i),i}};L([P({readOnly:!0})],V.prototype,"updating",void 0),L([P({constructOnly:!0})],V.prototype,"view",void 0),L([P({constructOnly:!0})],V.prototype,"geodesicLengthMeasurementUtils",void 0),L([P()],V.prototype,"options",null),V=L([K("esri.views.interactive.snapping.SelfSnappingEngine")],V);export{V as SelfSnappingEngine};
